{"pages":[],"posts":[{"title":"标准输入与标准输出","text":"概述C语言中使用函数scanf和printf作为标准输入和输出，在C++中引入了类cin和cout进行标准输入和输出，所需头文件为，命名空间是std。这里所说的标准输入和输出是相对程序而言，输入是通过IO设备，如键盘输入到程序，输出是指输出到IO设备，如程序输出到屏幕。 标准输入cin是标准输入流对象，是istream类的对象。cin是从缓冲区读取数据，如果缓冲区数据为空，cin对象的成员函数就会阻塞等待数据到来，直到检测到缓冲区有数据了才去读取。 开发过程中经常用到cin &gt;&gt;abc, cin.get()，cin.getline() cin&gt;&gt;abcabc为cin接受的类型，经常用到的是变量，先看张图： 12345678910111213141516#include &lt;iostream&gt; using namespace std; int main(){ int a; short b; char c; cin &gt;&gt; a &gt;&gt; b &gt;&gt; c; cout &lt;&lt; a &lt;&lt; endl; cout &lt;&lt; b &lt;&lt; endl; cout &lt;&lt; c &lt;&lt; endl;} 运行输入11[空格/回车]22[空格/回车]a[回车]，程序输出结果如下： cin.get()表示获取输入的一个字符，常用方式如下： 1234567char a;a = cin.get();cout &lt;&lt; a &lt;&lt; endl; char b;cin.get(b);cout &lt;&lt; b &lt;&lt; endl; cin.getline():表示读取多个字符，包括空白字符。直到读满N-1个，或遇到指定的结束符为止。可以指定结束符，默认结束符为’\\0’。 用法： cin.getline(字符指针(char*),字符个数N(int),结束符(char)); 123456789//使用默认结束符char a[32] = {0};cin.getline(a, 3);cout &lt;&lt; a &lt;&lt; endl; //指定结束符为&apos;p&apos;char b[32] = {0};cin.getline(b, 12, &apos;p&apos;);cout &lt;&lt; b &lt;&lt; endl; 标准输出cout是标准输入流对象，是ostream类的对象。 cout对象属性包括一个插入运算符(&lt;&lt;)，右侧的信息可以插入到流中。 12//简单使用cout &lt;&lt; &quot;this is cout!&quot; &lt;&lt; endl; //控制符endl，光标会另起一行 进制输出： dec:十进制输出整数，效果所及：长效，头文件： hex:十六进制输出整数，效果所及：长效，头文件： oct:八进制输出整数，效果所及：长效，头文件： 长效意思：设置后对以后所有的输入输出有效，直到重新设置为止。 短效：只对当前输入输出有效。 setbase(n) :表示以 n 进制显示，头文件&lt; iomanip &gt; 中，n 只能取 8, 10, 16 三个值 12345678910111213141516int a = 28; //十进制输出cout &lt;&lt; dec &lt;&lt; a &lt;&lt; endl;//十六进制输出cout &lt;&lt; hex &lt;&lt; a &lt;&lt; endl;//八进制输出cout &lt;&lt; oct &lt;&lt; a &lt;&lt; endl; //设置十进制输出cout &lt;&lt; setbase(10);cout &lt;&lt; a &lt;&lt; endl; //设置字符为大写cout &lt;&lt; setiosflags(ios::uppercase) ;cout &lt;&lt; hex &lt;&lt; a &lt;&lt; endl; setw(int n):设置输出数据的域宽为n，靠域宽右侧显示，域余填充空格，数据超出域宽按实际数据显示。效果所及：短效，头文件。 setfill(char c):对输出域余用字符c填充。效果所及：长效，头文件。 setprecision(int n):设置输出精度为n，float最多可取6位有效数，double最多可取15位有效数。效果所及：长效，头文件。","link":"/2019/07/15/01标准输入与标准输出/"},{"title":"函数重载","text":"函数重载指在相同作用域中多个函数名相同，函数的形参不同。 遵循规则： 1.函数名相同 2.函数的参数，类型，个数或顺序不一样都可以构成重载。 3.函数返回值得类型不同不构成重载，编译直接报错，存在二义性(ambiiguous) 12345678910111213141516171819202122232425262728293031#include &lt;iostream&gt; using namespace std; void foo(int a){ cout &lt;&lt; &quot;foo(int a)&quot; &lt;&lt; endl;} void foo(int a, int b){ cout &lt;&lt; &quot;foo(int a, int b)&quot; &lt;&lt; endl;} void foo(double a, int b){ cout &lt;&lt; &quot;foo(double a, int b)&quot; &lt;&lt; endl;} int main(){ int a = 1; int b = 2; int c = 6.8; foo(a); foo(a, b); foo(c, b); return 0;} 运行结果： 实现原理C++的重载使用了name mangling技术，有人翻译成命名粉碎，命名倾轧等。编译器会把原有的名字与其参数结合生成一个新的名字。 验证：把上文源码文件编译成目标namemangling.o，使用nm指令查看该文件：","link":"/2019/07/16/02函数重载/"},{"title":"内联函数","text":"函数的使用使得相同代码不必多次重写，但会带来额外的开销，函数调用的过程中会有入栈和出栈，这些都会消耗时间。 如果一个函数在程序运行过程中被成千上万次调用，那么这个开销也是不容忽视的，C++中引入了内联函数，直接在函数前面加上inline，在编译过程中直接把函数代码内嵌，避免了运行过程中的函数调用，但会增加程序代码段的空间。可以任务以空间来换取时间。 示例1234inline int foo(int a, int b) { return a+b; } ###总结内联函数优点：程序运行时避免了调用函数入栈，出栈导致的额外开销。 内联函数缺点：编译时直接函数代码内嵌，增加了代码段空间。 一般函数体行数不多(谷歌编程规范明确指出内联函数不超过10行代码)，且被频繁调用的函数适合用内联函数。","link":"/2019/07/17/03内联函数/"},{"title":"new和delete","text":"1.malloc,free和new,delete区别。 &emsp;a.malloc,free是C/C++的标准库函数。new,delete是c++的操作符。 &emsp;b.malloc申请的是内存，严格意义不是“对象”，new申请的可以理解为“对象”，new 时会调用构造函数，返回指向该对象的指针。 &emsp;c.对于class类型，必须用new/delete来创建和销毁，自动调用构造和析构函数，malloc/free无法胜任。 2.使用new遵循原则： &emsp;a.用new申请的内存，必须用delete释放。 &emsp;b.用new[]申请的内存，必须用delete[]释放。 &emsp;c.delete释放内存后，指针值不变，良好的风格是释放后指针置为NULL，如,delete p； p = NULL。 使用1.申请一个对象 123int* p1 = new int;delete p1;p1 = NULL; 2.申请多个对象 123int* p1 = new int[12];delete[] p1;p1 = NULL; 3.申请一个长度为1024的char数组 1234567char* pArray = new char[1024];for (int i=0; i &lt; 1024; i++){ pArray[i] = i;}delete[] pArray;pArray = NULL; 4.申请一个类对象 123456789101112131415#include &lt;stdio.h&gt; class Student{public: char name[32]; int age;};int main(){ Student* pStu = new Student(); delete pStu; pStu = NULL; return 1;} 5.申请1024个类对象 123456789101112131415161718192021222324252627#include &lt;stdio.h&gt; class Student{public: int age; Student() { ... } ~Student() { ... }}; int main(){ Student* pStu = new Student[1024]; for (int i=0; i&lt;1024; i++) { pStu[i].age = i+1; } delete[] pStu; pStu = NULL; return 1;} new多个对象不能传参数，要求该类必须有默认构造函数。","link":"/2019/07/17/04new和delete/"},{"title":"动态分配内存(malloc, free)","text":"操作系统中存在一个内存管理器(Memory Manager)，简称MM，它负责管理内存。 MM提供的服务：应用程序可以向MM申请一块指定大小的内存(借出)，用完之后应用程序应该释放(还回)。 所需头文件 &lt;stdlib.h&gt; 123如：void* p = malloc(1024);//申请，从MMM借出内存free(p); //释放，还回MM 1.MM管理的内存区域成为堆(Heap)。 2.只要应用malloc，MM都会借出，如应用不归还，MM也不会主动要求你free。如果有个应用不停地malloc，而不free，最终会用光MM的内存。 当MM没有更多闲置内存时，malloc返回NULL，表明内存已经用完。 malloc函数123456void* malloc(int size) 参数size：指定要申请内存空间大小 返回值：void*，指向这一块内存地址。(MM不关心你拿这块内存来存储何种数据，所以返回void*)(MM不关心你拿这块内存来存储何种数据，所以返回void*) (MM不关心你拿这块内存来存储何种数据，所以返回void*) free函数1234void free(void* ptr) 参数ptr: 先前malloc返回的内存地址 返回值: void* ，指向这一块内存地址 使用举例123456789101112131415161718192021222324252627#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;string.h&gt; class Object{public: int a; int b; char name[32];}; int main(){ //申请堆内存 Object *object = (Object *)malloc(sizeof(Object)); //存放数据 object-&gt;a = 1; object-&gt;b = 5; strcpy(object-&gt;name, &quot;wpf&quot;); //释放内存 free(object); object = NULL; //良好的编程风格 return 1;}","link":"/2019/07/17/05动态分配内存(malloc,free)/"},{"title":"命名空间(namespace)","text":"命名空间可以解决程序中的同名冲突，尤其大型项目多人开发中经常用到。比如我们使用C++的标准输出std::cout就使用了std命名空间。 使用作用域符:: 123456789101112131415161718192021#include &lt;iostream&gt; using namespace std; int var = 10; void foo(){ cout &lt;&lt; &quot;this is foo&quot; &lt;&lt; endl;} int main(){ int var = 20; cout &lt;&lt; var &lt;&lt; endl; //输出局部变量 cout &lt;&lt; ::var &lt;&lt; endl; //输出全局变量 foo(); //不加作用域符 ::foo(); //加作用域符 return 0;} 命名空间会对全局的变量和函数进行作用域打包。 在某些第三方库中是有namespace的，因此我们在使用这些库的时，要确定是否使用using namespace来解除名字前缀。 使用语法： 12345678910namespace XXX{ int var = 10; class A { public: ... };} //没有分号 使用假设有命名空间namespace Animal； 12345678namespace Animal { int age = 10; void action() { cout &lt;&lt; &quot;eatiing&quot; &lt;&lt; endl; }} 用法一：直接使用命名空间成员 12cout &lt;&lt; Animal::age &lt;&lt; endl;Animal::action(); 用法二： using使用命名空间成员 12using Animal::age;cout &lt;&lt; age &lt;&lt; endl; 用法三：使用命名空间全部成员 123using namespace Animal;cout &lt;&lt; age &lt;&lt; endl;foo(); 同时命名空间也支持嵌 1234567891011121314151617181920#include &lt;stdio.h&gt;namespace XXX{ class A { public: void test() { printf(&quot;this is namespace XXX class A\\n&quot;); } };}using namespace XXX; int main(){ A* p = new A(); p-&gt;test(); return 1;} 相同的命名空间编译时会合并 12345678910111213141516171819#include &lt;iostream&gt; using namespace std; namespace Space { int a = 10;} namespace Space { int b = 20;} using namespace Space;int main(){ cout &lt;&lt; &quot;a = &quot; &lt;&lt; a &lt;&lt; endl; cout &lt;&lt; &quot;b = &quot; &lt;&lt; b &lt;&lt; endl; return 0;}","link":"/2019/07/17/06命名空间(namespace)/"},{"title":"类的分离式写法","text":"类的分离式写法，使得代码更加规范，增强了阅读性。 分离式写法的规则： 1.类的变量：写在类的里面 2.成员函数：类中写函数的声明，函数的定义写在类体外。 3.写在类外函数定义时，类名前加限定(Object: :)，其中， ::理解为表示范围的符号。 代码演示头文件：Object.h 12345678910111213141516#ifndef _OBJECT_H_#define _OBJECT_H_ class Student{private: char name[32]; int age; public: void SetName(char* pName); void SetAge(int age); void Printf_Stu();}; #endif 源文件：Object.cpp 12345678910111213141516171819202122232425262728#include &lt;stdio.h&gt;#include &lt;string.h&gt;#include &quot;Object.h&quot; void Student::SetName(char* pName){ strcpy(this-&gt;name, pName);} void Student::SetAge(int age){ this-&gt;age = age;} void Student::Printf_Stu(){ printf(&quot;name = %s, age = %d\\n&quot;, this-&gt;name, this-&gt;age);} int main(){ Student stu; stu.SetName(&quot;aaaa&quot;); stu.SetAge(30); stu.Printf_Stu(); return 1;}","link":"/2019/07/17/07类的分离式写法/"},{"title":"构造函数与析构函数","text":"1.构造函数是种特殊的类成员函数，遵循如下规则： a.函数名与类名必须相同。 b.没有返回值 12345678910例如：class Obj{...public: Obj() { ... }}; 2.构造函数可以带参数，也可以重载 12345678910111213class Obj{...public: Obj() { ... } Obj(int x, int y) { ... }}; 3.构造函数和普通成员函数不一样，一般不显示调用。在创建一个对象时，构造函数自动调用(编译器来完成)。 析构函数(destructor)1.析构和构造是一对相反的过程，对象被创建时调用构造函数，对象被销毁时调用析构函数，遵循如下规则： a.名称固定，类名前加上波浪线~ b.没有返回值 c.不能带参数12345678例如，class Obj{public: ~Obj() { }}; 2.析构函数只能有一个，不允许重载。 3.析构函数不显示调用，对象销毁时编译器自动调用。 重新实现链表(使用类，构造和析构函数)创建DataObj.h头文件 1234567891011121314151617181920212223#ifndef _OBJECT_H_#define _OBJECT_H_ struct Student{ char name[32]; int age; Student* pNext;}; class DataObj{public: DataObj(); ~DataObj(); void add(Student* pStu); void find(int age); void printNode(Student* pNode);private: Student m_head;}; #endif 创建DataObj.cpp源文件 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788#include &lt;stdio.h&gt;#include &lt;string.h&gt;#include &lt;stdlib.h&gt;#include &quot;DataObj.h&quot; //构造有头链表DataObj::DataObj(){ m_head.pNext = NULL;}DataObj::~DataObj(){ //指向每个节点的头部 Student* p = m_head.pNext; //释放所有节点 while(p) { Student *next = p-&gt;pNext; free(p); p = next; } } void DataObj::add(Student* pNode){ //指向每个节点的头部 Student* p = &amp;m_head; //通过头节点查找到链表尾部节点 while (p) { if (p-&gt;pNext == NULL) { break; } p = p-&gt;pNext; } //添加节点到尾部 p-&gt;pNext = pNode;}void DataObj::find(int age){ //标记是否找到 bool bFind = false; Student* p = &amp;m_head; while(p) { if (p-&gt;age == age) { bFind = true; printNode(p); } p = p-&gt;pNext; } if (!bFind) { printf(&quot;没有找到该age的节点&quot;); }}void DataObj::printNode(Student* pNode){ printf(&quot;name = %s, age = %d\\n&quot;, pNode-&gt;name, pNode-&gt;age);} int main(){ //构造节点 Student* pStu = (Student*) malloc(sizeof(Student)); strcpy(pStu-&gt;name, &quot;aaaa&quot;); pStu-&gt;age = 30; pStu-&gt;pNext = NULL; { DataObj dataObj; //添加节点 dataObj.add(pStu); //查找节点 dataObj.find(31); } return 1;}","link":"/2019/07/17/08构造函数与析构函数/"},{"title":"拷贝构造函数，浅拷贝和深拷贝","text":"拷贝构造函数是一种特殊的构造函数，遵循如下的规则： 1.函数名和类名一致，没有返回值。 2.必须有一个参数，参数是本类型的一个引用变量。 3.拷贝构造函数可以访问参数对象的任意成员(private也可以)。 4.若自己不提供拷贝构造函数，系统会提供默认构造函数，若自己定义，系统将不再提供。 5.系统提供的拷贝构造是浅拷贝。书写示例如下： 123456789101112class Student{public: //构造函数 Student(int a, char* p); //拷贝构造函数 Student(const Student&amp; stu); char name[32]; int age;}; 拷贝构造函数调用1234567//调用方法1Object obj1;Object obj2(obj1); //或者写成:Object obj2 = obj1;//调用方法2Object obj1;Object* obj2 = new Object(obj1); 浅拷贝浅拷贝不开辟新空间，只增加一个指针，指向原有的内存。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748#include &lt;iostream&gt;using namespace std; class Student{public: //构造函数 Student(const char* myName) { int len = strlen(myName); name = new char[len + 1]{0}; strcpy_s(this-&gt;name, len+1, myName); cout &lt;&lt; &quot;构造：&quot; &lt;&lt; hex &lt;&lt; (int)name &lt;&lt; endl; } //析构函数 ~Student() { if (name) { cout &lt;&lt; &quot;析构：&quot; &lt;&lt; hex &lt;&lt; (int)name &lt;&lt; endl; delete[] name; name = NULL; } } //拷贝构造函数（浅拷贝） Student(const Student&amp; stu) { name = stu.name; cout &lt;&lt; &quot;调用拷贝构造函数&quot; &lt;&lt; endl; } private: char* name;}; int main(){ { Student stu1(&quot;hongshaorou&quot;); Student stu2(stu1); } } 运行过程中发生了崩溃 是因为对相同的内存地址做了两次析构导致，打印出内存地址一目了然。 深拷贝深拷贝会开辟新的内存空间，把原有的对象复制过来。见下图： 对上边浅拷贝代码进行修改 123456789101112131415161718192021222324252627282930313233343536class Student{public: //构造函数 Student(const char* myName) { int len = strlen(myName); name = new char[len + 1]{0}; strcpy_s(this-&gt;name, len+1, myName); cout &lt;&lt; &quot;构造：&quot; &lt;&lt; hex &lt;&lt; (int)name &lt;&lt; endl; } //析构函数 ~Student() { if (name) { cout &lt;&lt; &quot;析构：&quot; &lt;&lt; hex &lt;&lt; (int)name &lt;&lt; endl; delete[] name; name = NULL; } } //拷贝构造函数（深拷贝） Student(const Student&amp; stu) { int len = strlen(stu.name); name = new char[len + 1]; strcpy_s(name, len + 1, stu.name); cout &lt;&lt; &quot;调用拷贝构造函数&quot; &lt;&lt; hex &lt;&lt; (int)name&lt;&lt; endl; } private: char* name;}; 再次运行不会发生崩溃现象，打印内存地址可见，开辟了内存空间。","link":"/2019/07/17/09拷贝构造函数，浅拷贝和深拷贝/"},{"title":"const关键字","text":"C++中const关键字无处不在，我这里做下汇总，作为工具文章方便翻阅。 一：修饰数据成员修饰的成员一单定义初始化后不能再进行修改，如： const int a = 10; a =20; //重新赋值直接会报错 当修饰类的成员函数时，先来段错误的代码 12345678910class Student{public: Student(int i) { this-&gt;age = i; //age是const类型直接复制会报错 }private: const int age;}; 解决上面的错误有两种方法 方法一：使用参数列表的形式(推荐使用) 12345678910class Student{public: Student(int i):age(i) { }private: const int age;}; 方法二：定义age时直接赋值 12345678class Student{public: Student ();private: const int age = 20;}; 二：修饰成员函数在声明之后，实现体之前 格式为： 类型 函数名(参数….) const const修饰的成员函数不能修改类中的成员函数，函数中只能调用const修饰的函数。 123456789101112131415161718192021class Student{public: Student (int i ):age(i) { } void update () const { age = age +1; //const 修饰的成员函数不能修改类中的成员变量 display(); //const 修饰的成员函数，函数中只能调用const修饰的成员函数 } void display() { cout &lt;&lt; &quot;age:&quot; &lt;&lt; endl; }private: int age;}; 三：修饰类对象const修饰的对象，只能调用const修饰的成员函数 12345678910111213141516171819202122232425262728class Student{public: Student (int i ):age(i) { } void update () const { cout &lt;&lt; &quot;this is update&quot; &lt;&lt; endl; } void display() { cout &lt;&lt; &quot;age:&quot; &lt;&lt; endl; }private: int age;};int main(){ const Student stu(30); stu.update(); stu.display(); //const修饰的类对象 只能调用const修饰的成员函数 return 1;} 成员函数有无const修饰可以构成重载，非const对象调用时优先调用非const修饰的成员函数，如不构成重载也可以调用const修饰成员函数。 12345678910111213141516171819202122232425262728class Student{public: Student (int i ):age(i) { } void display() { cout &lt;&lt; &quot;void display()&quot; &lt;&lt; endl; } void display() const { cout &lt;&lt; &quot;display() const&quot; &lt;&lt; endl; }private: int age;};int main(){ Student stu(30); stu.display(); return 1;} 输出结果：","link":"/2019/07/17/10const关键字/"},{"title":"友元","text":"C++封装的类增加了对类中数据成员的访问限制，从而保证了安全性。如想访问类中的私有成员需要通过类中提供的公共接口来访问，这样间接的访问方式，无疑使得程序的运行效率有所降低。 友元的提出可以使得类外的函数来访问类中的私有成员，保护成员。 友元的使用分为三类： 1.类外的普通函数声明为该类的友元函数。 格式： friend 类型 函数名(形参)2.其他类的成员函数声明为该类的友元函数。 格式：friend 类型 类名::函数名(形参)3.其他类为该类的友元类，这样类中的所有成员函数都是该类的友元函数。 格式：friend class 类名代码演示： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071#include &lt;iostream&gt;using namespace std;class A;class B{public: //类B的成员函数为类A的友元函数 void display(A &amp;a);};class C{public: //类C是类A的友元类 void display(A &amp;a);};class A{public: A(int i):x(i){} int getX() { return x; } friend void display(A &amp;a); friend void B::display(A &amp;a); friend C;private: int x;};//类外普通函数为类A的友元函数void display(A &amp;a){ cout &lt;&lt; a.x &lt;&lt; endl; //友元函数直接访问类中的私有成员}void B::display(A &amp;a){ cout &lt;&lt; a.x &lt;&lt; endl;}void C::display(A &amp;a){ cout &lt;&lt; a.x &lt;&lt; endl;}int main(){ A a(18); //无法直接访问类A的私有变量x，需要通过对外提供的函数来访问 cout &lt;&lt; a.getX() &lt;&lt; endl; //类B的成员函数为类的A的友元函数 B b; b.display(a); //类C是类A的友元类 C c; c.display(a); return 0;} ###总结： 1.友元声明在类中，但并不属于该类的成员。 2.友元的关系不能继承。 3.在类的任何位置声明友元都行，不受访问权限限制。 4.友元关系提高了程序效率，但破坏了数据的安全性。慎重使用。 5.友元的关系是单向。如类B是类A的友元，反过来类A不一定是类B的友元，看类B中是否有声明。","link":"/2019/07/17/11友元/"}],"tags":[{"name":"标准输入与输出","slug":"标准输入与输出","link":"/tags/标准输入与输出/"},{"name":"函数重载","slug":"函数重载","link":"/tags/函数重载/"},{"name":"内联函数","slug":"内联函数","link":"/tags/内联函数/"},{"name":"new","slug":"new","link":"/tags/new/"},{"name":"delete","slug":"delete","link":"/tags/delete/"},{"name":"malloc","slug":"malloc","link":"/tags/malloc/"},{"name":"free","slug":"free","link":"/tags/free/"},{"name":"命名空间","slug":"命名空间","link":"/tags/命名空间/"},{"name":"类的分离式写法","slug":"类的分离式写法","link":"/tags/类的分离式写法/"},{"name":"构造函数","slug":"构造函数","link":"/tags/构造函数/"},{"name":"析构函数","slug":"析构函数","link":"/tags/析构函数/"},{"name":"浅拷贝","slug":"浅拷贝","link":"/tags/浅拷贝/"},{"name":"深拷贝","slug":"深拷贝","link":"/tags/深拷贝/"},{"name":"const","slug":"const","link":"/tags/const/"},{"name":"友元","slug":"友元","link":"/tags/友元/"}],"categories":[{"name":"C++基础","slug":"C-基础","link":"/categories/C-基础/"}]}