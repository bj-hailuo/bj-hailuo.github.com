{"pages":[{"title":"","text":"关于我 本科通信工程专业，研究生通信与信息系统，从事开发十余年，coding带来无限乐趣，现就职一家创业公司，有倒下的倾向。 早期开发余年是C/C++，写后台服务，也使用MFC和Qt做过页面开发，近几年在用java，对spring boot，spring cloud略懂一二。 开源项目，一款股票行情的软件：https://github.com/woniu201/WnStock ，如感兴趣记得来个star。 公众号 码农code之路，定期分享优质技术文章，互联网趣事，快讯，还有高薪内推职位，欢迎关注！","link":"/about/index.html"}],"posts":[{"title":"标准输入与标准输出","text":"概述C语言中使用函数scanf和printf作为标准输入和输出，在C++中引入了类cin和cout进行标准输入和输出，所需头文件为，命名空间是std。这里所说的标准输入和输出是相对程序而言，输入是通过IO设备，如键盘输入到程序，输出是指输出到IO设备，如程序输出到屏幕。 标准输入cin是标准输入流对象，是istream类的对象。cin是从缓冲区读取数据，如果缓冲区数据为空，cin对象的成员函数就会阻塞等待数据到来，直到检测到缓冲区有数据了才去读取。 开发过程中经常用到cin &gt;&gt;abc, cin.get()，cin.getline() cin&gt;&gt;abcabc为cin接受的类型，经常用到的是变量，先看张图： 12345678910111213141516#include &lt;iostream&gt; using namespace std; int main(){ int a; short b; char c; cin &gt;&gt; a &gt;&gt; b &gt;&gt; c; cout &lt;&lt; a &lt;&lt; endl; cout &lt;&lt; b &lt;&lt; endl; cout &lt;&lt; c &lt;&lt; endl;} 运行输入11[空格/回车]22[空格/回车]a[回车]，程序输出结果如下： cin.get()表示获取输入的一个字符，常用方式如下： 1234567char a;a = cin.get();cout &lt;&lt; a &lt;&lt; endl; char b;cin.get(b);cout &lt;&lt; b &lt;&lt; endl; cin.getline():表示读取多个字符，包括空白字符。直到读满N-1个，或遇到指定的结束符为止。可以指定结束符，默认结束符为’\\0’。 用法： cin.getline(字符指针(char*),字符个数N(int),结束符(char)); 123456789//使用默认结束符char a[32] = {0};cin.getline(a, 3);cout &lt;&lt; a &lt;&lt; endl; //指定结束符为&apos;p&apos;char b[32] = {0};cin.getline(b, 12, &apos;p&apos;);cout &lt;&lt; b &lt;&lt; endl; 标准输出cout是标准输入流对象，是ostream类的对象。 cout对象属性包括一个插入运算符(&lt;&lt;)，右侧的信息可以插入到流中。 12//简单使用cout &lt;&lt; &quot;this is cout!&quot; &lt;&lt; endl; //控制符endl，光标会另起一行 进制输出： dec:十进制输出整数，效果所及：长效，头文件： hex:十六进制输出整数，效果所及：长效，头文件： oct:八进制输出整数，效果所及：长效，头文件： 长效意思：设置后对以后所有的输入输出有效，直到重新设置为止。 短效：只对当前输入输出有效。 setbase(n) :表示以 n 进制显示，头文件&lt; iomanip &gt; 中，n 只能取 8, 10, 16 三个值 12345678910111213141516int a = 28; //十进制输出cout &lt;&lt; dec &lt;&lt; a &lt;&lt; endl;//十六进制输出cout &lt;&lt; hex &lt;&lt; a &lt;&lt; endl;//八进制输出cout &lt;&lt; oct &lt;&lt; a &lt;&lt; endl; //设置十进制输出cout &lt;&lt; setbase(10);cout &lt;&lt; a &lt;&lt; endl; //设置字符为大写cout &lt;&lt; setiosflags(ios::uppercase) ;cout &lt;&lt; hex &lt;&lt; a &lt;&lt; endl; setw(int n):设置输出数据的域宽为n，靠域宽右侧显示，域余填充空格，数据超出域宽按实际数据显示。效果所及：短效，头文件。 setfill(char c):对输出域余用字符c填充。效果所及：长效，头文件。 setprecision(int n):设置输出精度为n，float最多可取6位有效数，double最多可取15位有效数。效果所及：长效，头文件。","link":"/2015/07/15/01标准输入与标准输出/"},{"title":"函数重载","text":"函数重载指在相同作用域中多个函数名相同，函数的形参不同。 遵循规则： 1.函数名相同 2.函数的参数，类型，个数或顺序不一样都可以构成重载。 3.函数返回值得类型不同不构成重载，编译直接报错，存在二义性(ambiiguous) 12345678910111213141516171819202122232425262728293031#include &lt;iostream&gt; using namespace std; void foo(int a){ cout &lt;&lt; &quot;foo(int a)&quot; &lt;&lt; endl;} void foo(int a, int b){ cout &lt;&lt; &quot;foo(int a, int b)&quot; &lt;&lt; endl;} void foo(double a, int b){ cout &lt;&lt; &quot;foo(double a, int b)&quot; &lt;&lt; endl;} int main(){ int a = 1; int b = 2; int c = 6.8; foo(a); foo(a, b); foo(c, b); return 0;} 运行结果： 实现原理C++的重载使用了name mangling技术，有人翻译成命名粉碎，命名倾轧等。编译器会把原有的名字与其参数结合生成一个新的名字。 验证：把上文源码文件编译成目标namemangling.o，使用nm指令查看该文件：","link":"/2015/07/16/02函数重载/"},{"title":"内联函数","text":"函数的使用使得相同代码不必多次重写，但会带来额外的开销，函数调用的过程中会有入栈和出栈，这些都会消耗时间。 如果一个函数在程序运行过程中被成千上万次调用，那么这个开销也是不容忽视的，C++中引入了内联函数，直接在函数前面加上inline，在编译过程中直接把函数代码内嵌，避免了运行过程中的函数调用，但会增加程序代码段的空间。可以任务以空间来换取时间。 示例1234inline int foo(int a, int b) { return a+b; } ###总结内联函数优点：程序运行时避免了调用函数入栈，出栈导致的额外开销。 内联函数缺点：编译时直接函数代码内嵌，增加了代码段空间。 一般函数体行数不多(谷歌编程规范明确指出内联函数不超过10行代码)，且被频繁调用的函数适合用内联函数。","link":"/2015/07/17/03内联函数/"},{"title":"new和delete","text":"1.malloc,free和new,delete区别。 &emsp;a.malloc,free是C/C++的标准库函数。new,delete是c++的操作符。 &emsp;b.malloc申请的是内存，严格意义不是“对象”，new申请的可以理解为“对象”，new 时会调用构造函数，返回指向该对象的指针。 &emsp;c.对于class类型，必须用new/delete来创建和销毁，自动调用构造和析构函数，malloc/free无法胜任。 2.使用new遵循原则： &emsp;a.用new申请的内存，必须用delete释放。 &emsp;b.用new[]申请的内存，必须用delete[]释放。 &emsp;c.delete释放内存后，指针值不变，良好的风格是释放后指针置为NULL，如,delete p； p = NULL。 使用1.申请一个对象 123int* p1 = new int;delete p1;p1 = NULL; 2.申请多个对象 123int* p1 = new int[12];delete[] p1;p1 = NULL; 3.申请一个长度为1024的char数组 1234567char* pArray = new char[1024];for (int i=0; i &lt; 1024; i++){ pArray[i] = i;}delete[] pArray;pArray = NULL; 4.申请一个类对象 123456789101112131415#include &lt;stdio.h&gt; class Student{public: char name[32]; int age;};int main(){ Student* pStu = new Student(); delete pStu; pStu = NULL; return 1;} 5.申请1024个类对象 123456789101112131415161718192021222324252627#include &lt;stdio.h&gt; class Student{public: int age; Student() { ... } ~Student() { ... }}; int main(){ Student* pStu = new Student[1024]; for (int i=0; i&lt;1024; i++) { pStu[i].age = i+1; } delete[] pStu; pStu = NULL; return 1;} new多个对象不能传参数，要求该类必须有默认构造函数。","link":"/2015/07/17/04new和delete/"},{"title":"动态分配内存(malloc, free)","text":"操作系统中存在一个内存管理器(Memory Manager)，简称MM，它负责管理内存。 MM提供的服务：应用程序可以向MM申请一块指定大小的内存(借出)，用完之后应用程序应该释放(还回)。 所需头文件 &lt;stdlib.h&gt; 123如：void* p = malloc(1024);//申请，从MMM借出内存free(p); //释放，还回MM 1.MM管理的内存区域成为堆(Heap)。 2.只要应用malloc，MM都会借出，如应用不归还，MM也不会主动要求你free。如果有个应用不停地malloc，而不free，最终会用光MM的内存。 当MM没有更多闲置内存时，malloc返回NULL，表明内存已经用完。 malloc函数123456void* malloc(int size) 参数size：指定要申请内存空间大小 返回值：void*，指向这一块内存地址。(MM不关心你拿这块内存来存储何种数据，所以返回void*)(MM不关心你拿这块内存来存储何种数据，所以返回void*) (MM不关心你拿这块内存来存储何种数据，所以返回void*) free函数1234void free(void* ptr) 参数ptr: 先前malloc返回的内存地址 返回值: void* ，指向这一块内存地址 使用举例123456789101112131415161718192021222324252627#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;string.h&gt; class Object{public: int a; int b; char name[32];}; int main(){ //申请堆内存 Object *object = (Object *)malloc(sizeof(Object)); //存放数据 object-&gt;a = 1; object-&gt;b = 5; strcpy(object-&gt;name, &quot;wpf&quot;); //释放内存 free(object); object = NULL; //良好的编程风格 return 1;}","link":"/2015/07/17/05动态分配内存(malloc,free)/"},{"title":"命名空间(namespace)","text":"命名空间可以解决程序中的同名冲突，尤其大型项目多人开发中经常用到。比如我们使用C++的标准输出std::cout就使用了std命名空间。 使用作用域符:: 123456789101112131415161718192021#include &lt;iostream&gt; using namespace std; int var = 10; void foo(){ cout &lt;&lt; &quot;this is foo&quot; &lt;&lt; endl;} int main(){ int var = 20; cout &lt;&lt; var &lt;&lt; endl; //输出局部变量 cout &lt;&lt; ::var &lt;&lt; endl; //输出全局变量 foo(); //不加作用域符 ::foo(); //加作用域符 return 0;} 命名空间会对全局的变量和函数进行作用域打包。 在某些第三方库中是有namespace的，因此我们在使用这些库的时，要确定是否使用using namespace来解除名字前缀。 使用语法： 12345678910namespace XXX{ int var = 10; class A { public: ... };} //没有分号 使用假设有命名空间namespace Animal； 12345678namespace Animal { int age = 10; void action() { cout &lt;&lt; &quot;eatiing&quot; &lt;&lt; endl; }} 用法一：直接使用命名空间成员 12cout &lt;&lt; Animal::age &lt;&lt; endl;Animal::action(); 用法二： using使用命名空间成员 12using Animal::age;cout &lt;&lt; age &lt;&lt; endl; 用法三：使用命名空间全部成员 123using namespace Animal;cout &lt;&lt; age &lt;&lt; endl;foo(); 同时命名空间也支持嵌 1234567891011121314151617181920#include &lt;stdio.h&gt;namespace XXX{ class A { public: void test() { printf(&quot;this is namespace XXX class A\\n&quot;); } };}using namespace XXX; int main(){ A* p = new A(); p-&gt;test(); return 1;} 相同的命名空间编译时会合并 12345678910111213141516171819#include &lt;iostream&gt; using namespace std; namespace Space { int a = 10;} namespace Space { int b = 20;} using namespace Space;int main(){ cout &lt;&lt; &quot;a = &quot; &lt;&lt; a &lt;&lt; endl; cout &lt;&lt; &quot;b = &quot; &lt;&lt; b &lt;&lt; endl; return 0;}","link":"/2015/07/17/06命名空间(namespace)/"},{"title":"类的分离式写法","text":"类的分离式写法，使得代码更加规范，增强了阅读性。 分离式写法的规则： 1.类的变量：写在类的里面 2.成员函数：类中写函数的声明，函数的定义写在类体外。 3.写在类外函数定义时，类名前加限定(Object: :)，其中， ::理解为表示范围的符号。 代码演示头文件：Object.h 12345678910111213141516#ifndef _OBJECT_H_#define _OBJECT_H_ class Student{private: char name[32]; int age; public: void SetName(char* pName); void SetAge(int age); void Printf_Stu();}; #endif 源文件：Object.cpp 12345678910111213141516171819202122232425262728#include &lt;stdio.h&gt;#include &lt;string.h&gt;#include &quot;Object.h&quot; void Student::SetName(char* pName){ strcpy(this-&gt;name, pName);} void Student::SetAge(int age){ this-&gt;age = age;} void Student::Printf_Stu(){ printf(&quot;name = %s, age = %d\\n&quot;, this-&gt;name, this-&gt;age);} int main(){ Student stu; stu.SetName(&quot;aaaa&quot;); stu.SetAge(30); stu.Printf_Stu(); return 1;}","link":"/2015/07/17/07类的分离式写法/"},{"title":"构造函数与析构函数","text":"1.构造函数是种特殊的类成员函数，遵循如下规则： a.函数名与类名必须相同。 b.没有返回值 12345678910例如：class Obj{...public: Obj() { ... }}; 2.构造函数可以带参数，也可以重载 12345678910111213class Obj{...public: Obj() { ... } Obj(int x, int y) { ... }}; 3.构造函数和普通成员函数不一样，一般不显示调用。在创建一个对象时，构造函数自动调用(编译器来完成)。 析构函数(destructor)1.析构和构造是一对相反的过程，对象被创建时调用构造函数，对象被销毁时调用析构函数，遵循如下规则： a.名称固定，类名前加上波浪线~ b.没有返回值 c.不能带参数12345678例如，class Obj{public: ~Obj() { }}; 2.析构函数只能有一个，不允许重载。 3.析构函数不显示调用，对象销毁时编译器自动调用。 重新实现链表(使用类，构造和析构函数)创建DataObj.h头文件 1234567891011121314151617181920212223#ifndef _OBJECT_H_#define _OBJECT_H_ struct Student{ char name[32]; int age; Student* pNext;}; class DataObj{public: DataObj(); ~DataObj(); void add(Student* pStu); void find(int age); void printNode(Student* pNode);private: Student m_head;}; #endif 创建DataObj.cpp源文件 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788#include &lt;stdio.h&gt;#include &lt;string.h&gt;#include &lt;stdlib.h&gt;#include &quot;DataObj.h&quot; //构造有头链表DataObj::DataObj(){ m_head.pNext = NULL;}DataObj::~DataObj(){ //指向每个节点的头部 Student* p = m_head.pNext; //释放所有节点 while(p) { Student *next = p-&gt;pNext; free(p); p = next; } } void DataObj::add(Student* pNode){ //指向每个节点的头部 Student* p = &amp;m_head; //通过头节点查找到链表尾部节点 while (p) { if (p-&gt;pNext == NULL) { break; } p = p-&gt;pNext; } //添加节点到尾部 p-&gt;pNext = pNode;}void DataObj::find(int age){ //标记是否找到 bool bFind = false; Student* p = &amp;m_head; while(p) { if (p-&gt;age == age) { bFind = true; printNode(p); } p = p-&gt;pNext; } if (!bFind) { printf(&quot;没有找到该age的节点&quot;); }}void DataObj::printNode(Student* pNode){ printf(&quot;name = %s, age = %d\\n&quot;, pNode-&gt;name, pNode-&gt;age);} int main(){ //构造节点 Student* pStu = (Student*) malloc(sizeof(Student)); strcpy(pStu-&gt;name, &quot;aaaa&quot;); pStu-&gt;age = 30; pStu-&gt;pNext = NULL; { DataObj dataObj; //添加节点 dataObj.add(pStu); //查找节点 dataObj.find(31); } return 1;}","link":"/2015/07/17/08构造函数与析构函数/"},{"title":"拷贝构造函数，浅拷贝和深拷贝","text":"拷贝构造函数是一种特殊的构造函数，遵循如下的规则： 1.函数名和类名一致，没有返回值。 2.必须有一个参数，参数是本类型的一个引用变量。 3.拷贝构造函数可以访问参数对象的任意成员(private也可以)。 4.若自己不提供拷贝构造函数，系统会提供默认构造函数，若自己定义，系统将不再提供。 5.系统提供的拷贝构造是浅拷贝。书写示例如下： 123456789101112class Student{public: //构造函数 Student(int a, char* p); //拷贝构造函数 Student(const Student&amp; stu); char name[32]; int age;}; 拷贝构造函数调用1234567//调用方法1Object obj1;Object obj2(obj1); //或者写成:Object obj2 = obj1;//调用方法2Object obj1;Object* obj2 = new Object(obj1); 浅拷贝浅拷贝不开辟新空间，只增加一个指针，指向原有的内存。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748#include &lt;iostream&gt;using namespace std; class Student{public: //构造函数 Student(const char* myName) { int len = strlen(myName); name = new char[len + 1]{0}; strcpy_s(this-&gt;name, len+1, myName); cout &lt;&lt; &quot;构造：&quot; &lt;&lt; hex &lt;&lt; (int)name &lt;&lt; endl; } //析构函数 ~Student() { if (name) { cout &lt;&lt; &quot;析构：&quot; &lt;&lt; hex &lt;&lt; (int)name &lt;&lt; endl; delete[] name; name = NULL; } } //拷贝构造函数（浅拷贝） Student(const Student&amp; stu) { name = stu.name; cout &lt;&lt; &quot;调用拷贝构造函数&quot; &lt;&lt; endl; } private: char* name;}; int main(){ { Student stu1(&quot;hongshaorou&quot;); Student stu2(stu1); } } 运行过程中发生了崩溃 是因为对相同的内存地址做了两次析构导致，打印出内存地址一目了然。 深拷贝深拷贝会开辟新的内存空间，把原有的对象复制过来。见下图： 对上边浅拷贝代码进行修改 123456789101112131415161718192021222324252627282930313233343536class Student{public: //构造函数 Student(const char* myName) { int len = strlen(myName); name = new char[len + 1]{0}; strcpy_s(this-&gt;name, len+1, myName); cout &lt;&lt; &quot;构造：&quot; &lt;&lt; hex &lt;&lt; (int)name &lt;&lt; endl; } //析构函数 ~Student() { if (name) { cout &lt;&lt; &quot;析构：&quot; &lt;&lt; hex &lt;&lt; (int)name &lt;&lt; endl; delete[] name; name = NULL; } } //拷贝构造函数（深拷贝） Student(const Student&amp; stu) { int len = strlen(stu.name); name = new char[len + 1]; strcpy_s(name, len + 1, stu.name); cout &lt;&lt; &quot;调用拷贝构造函数&quot; &lt;&lt; hex &lt;&lt; (int)name&lt;&lt; endl; } private: char* name;}; 再次运行不会发生崩溃现象，打印内存地址可见，开辟了内存空间。","link":"/2015/07/17/09拷贝构造函数，浅拷贝和深拷贝/"},{"title":"const关键字","text":"C++中const关键字无处不在，我这里做下汇总，作为工具文章方便翻阅。 一：修饰数据成员修饰的成员一单定义初始化后不能再进行修改，如： const int a = 10; a =20; //重新赋值直接会报错 当修饰类的成员函数时，先来段错误的代码 12345678910class Student{public: Student(int i) { this-&gt;age = i; //age是const类型直接复制会报错 }private: const int age;}; 解决上面的错误有两种方法 方法一：使用参数列表的形式(推荐使用) 12345678910class Student{public: Student(int i):age(i) { }private: const int age;}; 方法二：定义age时直接赋值 12345678class Student{public: Student ();private: const int age = 20;}; 二：修饰成员函数在声明之后，实现体之前 格式为： 类型 函数名(参数….) const const修饰的成员函数不能修改类中的成员函数，函数中只能调用const修饰的函数。 123456789101112131415161718192021class Student{public: Student (int i ):age(i) { } void update () const { age = age +1; //const 修饰的成员函数不能修改类中的成员变量 display(); //const 修饰的成员函数，函数中只能调用const修饰的成员函数 } void display() { cout &lt;&lt; &quot;age:&quot; &lt;&lt; endl; }private: int age;}; 三：修饰类对象const修饰的对象，只能调用const修饰的成员函数 12345678910111213141516171819202122232425262728class Student{public: Student (int i ):age(i) { } void update () const { cout &lt;&lt; &quot;this is update&quot; &lt;&lt; endl; } void display() { cout &lt;&lt; &quot;age:&quot; &lt;&lt; endl; }private: int age;};int main(){ const Student stu(30); stu.update(); stu.display(); //const修饰的类对象 只能调用const修饰的成员函数 return 1;} 成员函数有无const修饰可以构成重载，非const对象调用时优先调用非const修饰的成员函数，如不构成重载也可以调用const修饰成员函数。 12345678910111213141516171819202122232425262728class Student{public: Student (int i ):age(i) { } void display() { cout &lt;&lt; &quot;void display()&quot; &lt;&lt; endl; } void display() const { cout &lt;&lt; &quot;display() const&quot; &lt;&lt; endl; }private: int age;};int main(){ Student stu(30); stu.display(); return 1;} 输出结果：","link":"/2015/07/17/10const关键字/"},{"title":"友元","text":"C++封装的类增加了对类中数据成员的访问限制，从而保证了安全性。如想访问类中的私有成员需要通过类中提供的公共接口来访问，这样间接的访问方式，无疑使得程序的运行效率有所降低。 友元的提出可以使得类外的函数来访问类中的私有成员，保护成员。 友元的使用分为三类： 1.类外的普通函数声明为该类的友元函数。 格式： friend 类型 函数名(形参)2.其他类的成员函数声明为该类的友元函数。 格式：friend 类型 类名::函数名(形参)3.其他类为该类的友元类，这样类中的所有成员函数都是该类的友元函数。 格式：friend class 类名代码演示： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071#include &lt;iostream&gt;using namespace std;class A;class B{public: //类B的成员函数为类A的友元函数 void display(A &amp;a);};class C{public: //类C是类A的友元类 void display(A &amp;a);};class A{public: A(int i):x(i){} int getX() { return x; } friend void display(A &amp;a); friend void B::display(A &amp;a); friend C;private: int x;};//类外普通函数为类A的友元函数void display(A &amp;a){ cout &lt;&lt; a.x &lt;&lt; endl; //友元函数直接访问类中的私有成员}void B::display(A &amp;a){ cout &lt;&lt; a.x &lt;&lt; endl;}void C::display(A &amp;a){ cout &lt;&lt; a.x &lt;&lt; endl;}int main(){ A a(18); //无法直接访问类A的私有变量x，需要通过对外提供的函数来访问 cout &lt;&lt; a.getX() &lt;&lt; endl; //类B的成员函数为类的A的友元函数 B b; b.display(a); //类C是类A的友元类 C c; c.display(a); return 0;} ###总结： 1.友元声明在类中，但并不属于该类的成员。 2.友元的关系不能继承。 3.在类的任何位置声明友元都行，不受访问权限限制。 4.友元关系提高了程序效率，但破坏了数据的安全性。慎重使用。 5.友元的关系是单向。如类B是类A的友元，反过来类A不一定是类B的友元，看类B中是否有声明。","link":"/2015/07/17/11友元/"},{"title":"类的继承","text":"面向对象的设计思想，类对数据做了封装，并可以加入访问权限，类的继承是面向对象思想的精髓。类的继承可以让新类从以有的类中获得已有的特征。原有类称为基类或父类，新类称为派生类或子类。 语法： 1234class 子类类名：[继承方式] 父类类名{ } ; 继承的方式有三种： 1.共有继承：(使用最广泛) 在派生类中原来的公有成员，保护成员身份不变。原私有成员仍不可访问。 2.私有继承： 在派生类中原来的公有成员，保护成员都称为了保护成员。原私有成员仍不可访问。 3.保护继承：在派生类中原来的公有成员，保护成员都称为了私有成员。原私有成员仍不可访问。 派生类的构造函数和析构函数派生类继承基类过程中，基类的构造函数和析构是不能继承下来的。所以，派生类必须设置自己的构造函数和析构函数。 派生类构造函数语法： 1234派生类名::派生类名(参数):基类名(参数),派生类新成员(){ } 构造调用顺序： 基类构造---&gt;派生类构造析构函数调用顺序 派生类析构---&gt;基类析构代码演示： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667#include &lt;iostream&gt;#include &lt;string&gt; using namespace std; class Man{public: Man(string sn, int i):name(sn),age(i) { cout &lt;&lt; &quot;Man construct&quot; &lt;&lt; endl; } ~Man() { cout &lt;&lt; &quot;Man destruct&quot; &lt;&lt; endl; } void dis() { cout &lt;&lt; &quot;ame:&quot; &lt;&lt; name &lt;&lt; endl; cout &lt;&lt; &quot;age:&quot; &lt;&lt; age &lt;&lt; endl; }private: string name; int age;}; class Birthday{public: Birthday(int y, int m):year(y), month(m) { cout &lt;&lt; &quot;Birthday construct &quot; &lt;&lt; endl; } ~Birthday() { cout &lt;&lt; &quot;Birthday destruct &quot; &lt;&lt; endl; }private: int year; int month;}; class Student:public Man{public: Student(string name, int age, float fs):Man(name, age),bday(10, 10),_score(fs) { cout &lt;&lt; &quot;Student construct&quot; &lt;&lt; endl; } ~Student() { cout &lt;&lt; &quot;Student destruct&quot; &lt;&lt; endl; }private: float _score; Birthday bday;}; int main(){ Student stu(&quot;wpf&quot;, 18, 100); stu.dis();} 运行结果： 同名隐藏子类中定义了与父类同名的方法（不管参数），子类的该方法将会隐藏掉所有的父类的同名方法； 12345678910111213141516171819202122232425262728293031 class Father{public: void show() { cout &lt;&lt; &quot;Father show()&quot; &lt;&lt; endl; } void show(int a) { cout &lt;&lt; &quot;Father show(int a)&quot; &lt;&lt; endl; }}; class Son : public Father{public: void show() { cout &lt;&lt; &quot;Son show()&quot; &lt;&lt; endl; }}; int main(){ Son son; son.show(); //调用子类中的方法 son.show(1); //父类中的同名方法，void show(int a)被隐藏，无法调用 getchar();} 多继承多继承是的新建的获得多个类(&gt;=2)中获得已有的特征， 并非所有面向对象的语言都有这种语法，如Java，C#取消了多继承，多继承可能引起多种问题，如二义性等。 多继承语法： 1234派生类名:public 基类名1，public 基类名2{ }; 代码演示： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263#include &lt;iostream&gt;#include &lt;string&gt; using namespace std; //基类Xclass X{public: X(int a):i(a) { cout &lt;&lt; &quot;construct X&quot; &lt;&lt; endl; } void displayX() { cout &lt;&lt; &quot;X:&quot; &lt;&lt; i &lt;&lt; endl; }private: int i;}; //基类Yclass Y{public: Y(int a):i(a) { cout &lt;&lt; &quot;construct Y&quot; &lt;&lt; endl; } void displayY() { cout &lt;&lt; &quot;Y:&quot; &lt;&lt; i &lt;&lt; endl; }private: int i;}; //派生类Zclass Z: public X, public Y{public: Z(int a, int b, int c):X(a), Y(b), i(c) { cout &lt;&lt; &quot;construct Z&quot; &lt;&lt; endl; } void displayZ() { cout &lt;&lt; &quot;Z:&quot; &lt;&lt; i &lt;&lt; endl; } private: int i;}; int main(){ Z z(1,2,3); z.displayX(); z.displayY(); z.displayZ();} 运行结果：","link":"/2015/07/18/12类的继承/"},{"title":"虚继承","text":"由于多重继承产生的二义性引入了类的虚继承，先看下什么是二义性。 类D是类B和类C的派生类，而类B，类C就是继承于类A，当D调用类A中的函数时不知道是类B继承A的，还是类C继承A的，引起了二义性。虚继承可以解决这个问题。 使用语法： 123class 派生类:virtual 继承方式 虚基类{}; 上图中类D 实例化过程中的初始化顺序： 祖父类(A)—&gt;父类(从左到又)—&gt;子类，并且最后一次初始化有效 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677#include &lt;iostream&gt;#include &lt;string&gt; using namespace std; class A{public: A(int a):i(a) { cout &lt;&lt; &quot;construct A&quot; &lt;&lt; endl; } void displaya() { cout &lt;&lt; &quot;A:&quot; &lt;&lt; i &lt;&lt; endl; }private: int i;}; class B:virtual public A //虚继承{public: B(int a): A(a),i(a) { cout &lt;&lt; &quot;construct B&quot; &lt;&lt; endl; } void displayb() { cout &lt;&lt; &quot;B:&quot; &lt;&lt; i &lt;&lt; endl; }private: int i;}; class C:virtual public A //虚继承{public: C(int a):A(2),i(a) { cout &lt;&lt; &quot;construct C&quot; &lt;&lt; endl; } void displayc() { cout &lt;&lt; &quot;C:&quot; &lt;&lt; i &lt;&lt; endl; }private: int i;}; class D: public B, public C //多重继承{public: D(int a, int b, int c, int d):A(a), B(b), C(d), i(c) //必须初始化虚基类X,X(d) { cout &lt;&lt; &quot;construct Z&quot; &lt;&lt; endl; } void displayd() { cout &lt;&lt; &quot;D:&quot; &lt;&lt; i &lt;&lt; endl; } private: int i;}; int main(){ D d(1,2,3, 4); d.displaya(); d.displayb(); d.displayc(); d.displayd();} 运行结果： 编译器在实例化D时，之调用了一次虚基类的构造函数，忽略了虚基类A派生类B，C对续虚基类构造函数的调用，保证了虚基类的数据成员不会被初始化多次。","link":"/2015/07/18/13虚继承/"},{"title":"赋值兼容","text":"赋值兼容的规则时在需要使用基类对象的任何地方都可以使用公有派生类对象来替代。公有继承派生类可获得基类中除构造函数，析构函数外的所有成员，能用基类解决的问题，派生类也能解决。更直白点说，如果一个类是从一个基类公有继承过来，那么这个派生类就可以替代基类，反过来基类不能替代派生类。 常用赋值兼容情况： 1.派生类对象赋值给基类对象。 2.派生类对象初始化基类对象引用。 3.派生类对象地址赋值给指向基类对象指针。12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152#include &lt;iostream&gt; using namespace std; class Father{public: void show() { cout &lt;&lt; &quot;Father show()&quot; &lt;&lt; endl; } void showFather() { cout &lt;&lt; &quot;showFather()&quot; &lt;&lt; endl; }}; class Son : public Father{public: void show() { cout &lt;&lt; &quot;Son show()&quot; &lt;&lt; endl; } void showSon() { cout &lt;&lt; &quot;showSon()&quot; &lt;&lt; endl; }}; int main(){ Father father1; Son son1; father1 = son1; //子类对象赋值给父类对象 father1.show(); //调用父类中的show()方法 father1.showFather(); //调用父类中的showFather()方法 Son son2; Father&amp; father2 = son2; //子类对象初始化父类对象引用 father2.show(); //调用父类中的show()方法 father2.showFather(); //调用父类中的showFather()方法 Son son3; Father* father3 = &amp;son3;//子类对象地址赋值给指向父对象指针 father3-&gt;show(); //调用父类中的show()方法 father3-&gt;showFather(); //调用父类中的showFather()方法 getchar();}","link":"/2015/07/18/14赋值兼容/"},{"title":"C++生成和解析XML文件","text":"1.xml 指可扩展标记语言(EXtensible Markup Language)2.xml 是一种标记语言，类似html3.xml 的设计宗旨是传输数据，而非显示数据4.xml 标签没有被预定义。需要自行定义标签 XML与HTML区别1.xml 不是 html 的替代。2.xml 和 html 为不同的目的而设计：3.xml 被设计为传输和存储数据，其焦点是数据的内容。4.html 被设计用来显示数据，其焦点是数据的外观。5.html 旨在显示信息，而 xml 旨在传输信息。 第三方库XML第三方解析库,选用TinyXML,TinyXML也是一个开源的解析XML解析库，使用简单正如其名，用于C++开发，支持Windows和Linux。TinyXML通过DOM模型遍历和分析XML。官网地址：http://www.grinninglizard.com/tinyxml/ 生成XML文件123456789101112131415161718192021222324252627282930TiXmlDocument xmlDocument;// 添加XML声明xmlDocument.LinkEndChild(new TiXmlDeclaration( &quot;1.0&quot;, &quot;GBK&quot;, &quot;&quot; ));// 添加根元素TiXmlElement * xmlRoot = new TiXmlElement(&quot;root&quot;);xmlDocument.LinkEndChild(xmlRoot);//根元素下添加子元素1TiXmlElement* xmlChild1 = new TiXmlElement(&quot;name&quot;);xmlRoot-&gt;LinkEndChild(xmlChild1);xmlChild1-&gt;LinkEndChild(new TiXmlText(&quot;woniu&quot;));xmlChild1-&gt;SetAttribute(&quot;id&quot;, &quot;0001&quot;);//设置属性//根元素下添加子元素2TiXmlElement* xmlChild2 = new TiXmlElement(&quot;Student&quot;);xmlRoot-&gt;LinkEndChild(xmlChild2);TiXmlElement* xmlChild2_01 = new TiXmlElement(&quot;name&quot;);xmlChild2-&gt;LinkEndChild(xmlChild2_01);xmlChild2_01-&gt;LinkEndChild(new TiXmlText(&quot;woniu201&quot;)); TiXmlElement* xmlChild2_02 = new TiXmlElement(&quot;classes&quot;);xmlChild2-&gt;LinkEndChild(xmlChild2_02);xmlChild2_02-&gt;LinkEndChild(new TiXmlText(&quot;86&quot;));//保存xml文件xmlDocument.SaveFile(&quot;woniu.xml&quot;); 生成XML如下： 解析XML文件123456789101112131415161718192021222324TiXmlDocument xmlDocument;if (!xmlDocument.LoadFile(&quot;woniu.xml&quot;)){ return -1;}//根节点TiXmlElement* xmlRoot = xmlDocument.RootElement();if (xmlRoot == NULL){ return -1;}//获取子节点信息1TiXmlElement* xmlNode1Name = xmlRoot-&gt;FirstChildElement(&quot;name&quot;);const char* node1Name = xmlNode1Name-&gt;GetText();const char* node1AttId = xmlNode1Name-&gt;Attribute(&quot;id&quot;);//获取子节点信息2TiXmlElement* xmlNode2Stu = xmlRoot-&gt;FirstChildElement(&quot;Student&quot;);TiXmlElement* xmlNode2_name = xmlNode2Stu-&gt;FirstChildElement(&quot;name&quot;);TiXmlElement* xmlname2_classes = xmlNode2Stu-&gt;FirstChildElement(&quot;classes&quot;);const char* node2Name = xmlNode2_name-&gt;GetText();const char* node2Classes = xmlname2_classes-&gt;GetText(); 关注下面公众号，回复”101”获取源码","link":"/2017/07/31/Applied01C++生成和解析XML文件/"},{"title":"C++构造和解析JSON","text":"JSON是一种轻量级的数据交互格式，易于人阅读和编写，同时也易于机器解析和生成，并有效地提升网络传输效率，实际项目中经常用到，相比xml有很多优点，问问度娘，优点一箩筐。 第三方库json解析选用jsoncpp作为第三方库，jsoncpp使用广泛，c++开发首选。 jsoncpp目前已经托管到了github上，地址：https://github.com/open-source-parsers/jsoncpp 使用使用c++进行构造json和解析json，选用vs2010作为IDE。工程中使用jsoncpp的源码进行编译，没有使用jsoncpp的库，为方便大家使用把dll和lib库也放到了我的工程jsoncpplib文件夹下，有需要的可以直接引用库。 待解析的json数据格式如下图： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156/********************************************************Copyright (C), 2016-2017,FileName: mainAuthor: woniu201Email: wangpengfei.201@163.comCreated: 2017/09/06Description:use jsoncpp src , not use dll, but i also provide dll and lib.********************************************************/ #include &quot;stdio.h&quot;#include &lt;string&gt;#include &quot;jsoncpp/json.h&quot; using namespace std; /************************************@ Brief: read file@ Author: woniu201 @ Created: 2017/09/06@ Return: file data ************************************/char *getfileAll(char *fname){ FILE *fp; char *str; char txt[1000]; int filesize; if ((fp=fopen(fname,&quot;r&quot;))==NULL){ printf(&quot;open file %s fail \\n&quot;,fname); return NULL; } fseek(fp,0,SEEK_END); filesize = ftell(fp); str=(char *)malloc(filesize); str[0]=0; rewind(fp); while((fgets(txt,1000,fp))!=NULL){ strcat(str,txt); } fclose(fp); return str;} /************************************@ Brief: write file@ Author: woniu201 @ Created: 2017/09/06@ Return: ************************************/int writefileAll(char* fname,const char* data){ FILE *fp; if ((fp=fopen(fname, &quot;w&quot;)) == NULL) { printf(&quot;open file %s fail \\n&quot;, fname); return 1; } fprintf(fp, &quot;%s&quot;, data); fclose(fp); return 0;} /************************************@ Brief: parse json data@ Author: woniu201 @ Created: 2017/09/06@ Return: ************************************/int parseJSON(const char* jsonstr){ Json::Reader reader; Json::Value resp; if (!reader.parse(jsonstr, resp, false)) { printf(&quot;bad json format!\\n&quot;); return 1; } int result = resp[&quot;Result&quot;].asInt(); string resultMessage = resp[&quot;ResultMessage&quot;].asString(); printf(&quot;Result=%d; ResultMessage=%s\\n&quot;, result, resultMessage.c_str()); Json::Value &amp; resultValue = resp[&quot;ResultValue&quot;]; for (int i=0; i&lt;resultValue.size(); i++) { Json::Value subJson = resultValue[i]; string cpuRatio = subJson[&quot;cpuRatio&quot;].asString(); string serverIp = subJson[&quot;serverIp&quot;].asString(); string conNum = subJson[&quot;conNum&quot;].asString(); string websocketPort = subJson[&quot;websocketPort&quot;].asString(); string mqttPort = subJson[&quot;mqttPort&quot;].asString(); string ts = subJson[&quot;TS&quot;].asString(); printf(&quot;cpuRatio=%s; serverIp=%s; conNum=%s; websocketPort=%s; mqttPort=%s; ts=%s\\n&quot;,cpuRatio.c_str(), serverIp.c_str(), conNum.c_str(), websocketPort.c_str(), mqttPort.c_str(), ts.c_str()); } return 0;} /************************************@ Brief: create json data@ Author: woniu201 @ Created: 2017/09/06@ Return: ************************************/int createJSON(){ Json::Value req; req[&quot;Result&quot;] = 1; req[&quot;ResultMessage&quot;] = &quot;200&quot;; Json::Value object1; object1[&quot;cpuRatio&quot;] = &quot;4.04&quot;; object1[&quot;serverIp&quot;] = &quot;42.159.116.104&quot;; object1[&quot;conNum&quot;] = &quot;1&quot;; object1[&quot;websocketPort&quot;] = &quot;0&quot;; object1[&quot;mqttPort&quot;] = &quot;8883&quot;; object1[&quot;TS&quot;] = &quot;1504665880572&quot;; Json::Value object2; object2[&quot;cpuRatio&quot;] = &quot;2.04&quot;; object2[&quot;serverIp&quot;] = &quot;42.159.122.251&quot;; object2[&quot;conNum&quot;] = &quot;2&quot;; object2[&quot;websocketPort&quot;] = &quot;0&quot;; object2[&quot;mqttPort&quot;] = &quot;8883&quot;; object2[&quot;TS&quot;] = &quot;1504665896981&quot;; Json::Value jarray; jarray.append(object1); jarray.append(object2); req[&quot;ResultValue&quot;] = jarray; Json::FastWriter writer; string jsonstr = writer.write(req); printf(&quot;%s\\n&quot;, jsonstr.c_str()); writefileAll(&quot;createJson.json&quot;, jsonstr.c_str()); return 0;} int main(){ char* json = getfileAll(&quot;parseJson.json&quot;); parseJSON(json); printf(&quot;===============================\\n&quot;); createJSON(); getchar(); return 1;} 关注下面公众号，回复”104”获取源码","link":"/2017/09/06/Applied02C++构造和解析Json/"},{"title":"C++操作文件行(读取，删除，修改指定行)","text":"纯C++实现对文件行的增删改查 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140/********************************************************Copyright (C), 2016-2018,FileName: mainAuthor: woniu201Email: wangpengfei.201@163.comCreated: 2018/08/31Description: 文件操作：读取指定行，删除指定行，修改指定行********************************************************/#include &lt;iostream&gt;#include &lt;fstream&gt;#include &lt;string&gt;using namespace std; /************************************@ Brief: 读取指定行数据@ Author: woniu201 @ Created: 2018/08/31@ Return: ************************************/void ReadLineData(char* fileName, int lineNum, char* data){ ifstream in; in.open(fileName); int line = 1; while (in.getline(data, 1024)) { if (lineNum == line) { break; } line ++ ; } in.close();} /************************************@ Brief: 字符串转string类型@ Author: woniu201 @ Created: 2018/08/31@ Return: ************************************/string CharToStr(char * contentChar){ string tempStr; for (int i=0;contentChar[i]!=&apos;\\0&apos;;i++) { tempStr+=contentChar[i]; } return tempStr;} /************************************@ Brief: 删除指定行@ Author: woniu201 @ Created: 2018/08/31@ Return: ************************************/void DelLineData(char* fileName, int lineNum){ ifstream in; in.open(fileName); string strFileData = &quot;&quot;; int line = 1; char lineData[1024] = {0}; while(in.getline(lineData, sizeof(lineData))) { if (line == lineNum) { strFileData += &quot;\\n&quot;; } else { strFileData += CharToStr(lineData); strFileData += &quot;\\n&quot;; } line++; } in.close(); //写入文件 ofstream out; out.open(fileName); out.flush(); out&lt;&lt;strFileData; out.close();} /************************************@ Brief: 修改行数据@ Author: woniu201 @ Created: 2018/08/31@ Return: ************************************/void ModifyLineData(char* fileName, int lineNum, char* lineData){ ifstream in; in.open(fileName); string strFileData = &quot;&quot;; int line = 1; char tmpLineData[1024] = {0}; while(in.getline(tmpLineData, sizeof(tmpLineData))) { if (line == lineNum) { strFileData += CharToStr(lineData); strFileData += &quot;\\n&quot;; } else { strFileData += CharToStr(tmpLineData); strFileData += &quot;\\n&quot;; } line++; } in.close(); //写入文件 ofstream out; out.open(fileName); out.flush(); out&lt;&lt;strFileData; out.close();} int main(){ char lineData[1024] = {0}; ReadLineData(&quot;D:\\\\project\\\\cpp\\\\2010\\\\jsondemo\\\\jsondemo\\\\1.json&quot;, 21, lineData); cout &lt;&lt; lineData &lt;&lt; endl; DelLineData(&quot;D:\\\\project\\\\cpp\\\\2010\\\\jsondemo\\\\jsondemo\\\\1.json&quot;, 10); ModifyLineData(&quot;D:\\\\project\\\\cpp\\\\2010\\\\jsondemo\\\\jsondemo\\\\1.json&quot;, 10, &quot;aaaaaaaaaaaaaa&quot;); getchar();}","link":"/2018/11/16/Applied04C++操作文件行(读取，删除，修改指定行)/"},{"title":"windows和linux环境下使用google的glog日志库","text":"glog是google推出的一款轻量级c++开源日志框架，源码在github上，目前最新release版本是v0.3.5。 githut地址：https://github.com/google/glog，避免新版本踏坑，习惯性选用低版本v0.3.3。 一：生成windows库源码下载完成后，根目录下会有google-glog.sln工程文件呢，用visual studio打开会有四个项目，分别如下：1.libglog:生成动态库的源码2.libglog_static:生成静态库的源码3.libglog_unittest:测试动态库的源码工程4.libglog_unittest_static:测试静态库的源码工程 windows下使用动态库演示，编译libglog工程，生成”libglog.dll”和”libglog.lib”库文件 二：windows下使用glog库1.如你使用静态库，需要添加#define GOOGLE_GLOG_DLL_DECL，动态库不需要添加2.如你工程中添加了&lt;windows.h&gt;,直接编译会报如下错误： &quot;ERROR macro is defined. Define GLOG_NO_ABBREVIATED_SEVERITIES before including logging.h. See the document for detail.&quot; 解决办法：添加宏 &quot;#define GLOG_NO_ABBREVIATED_SEVERITIES&quot;，并且代码中的要使用google::GLOG_ERROR代替google::ERROR,google::GLOG_INFO代替google::INFO,google::GLOG_WARNING代替google::WARNING,google::GLOG_FATAL代替google::FATAL 原因：windows.h中定义的宏ERROR与glog中定义的宏ERROR冲突。测试代码如下： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950/********************************************************Copyright (C), 2016-2018,FileName: mainAuthor: woniu201Email: wangpengfei.201@163.comCreated: 2017/08/23Description: Glog使用Demo********************************************************/#include &lt;Windows.h&gt;#define GLOG_NO_ABBREVIATED_SEVERITIES#include &lt;iostream&gt;#include &lt;string&gt;#include &quot;glog/logging.h&quot; using namespace std;#pragma comment(lib, &quot;lib/libglog.lib&quot;) void main(){ //初始化参数 FLAGS_logtostderr = FALSE; //TRUE:标准输出,FALSE:文件输出 FLAGS_alsologtostderr = TRUE; //除了日志文件之外是否需要标准输出 FLAGS_colorlogtostderr = FALSE; //标准输出带颜色 FLAGS_logbufsecs = 0; //设置可以缓冲日志的最大秒数，0指实时输出 FLAGS_max_log_size = 10; //日志文件大小(单位：MB) FLAGS_stop_logging_if_full_disk = true; //磁盘满时是否记录到磁盘 //FLAGS_minloglevel = google::GLOG_INFO //glog初始化 google::InitGoogleLogging(&quot;mqttserver&quot;); google::SetLogDestination(google::GLOG_INFO,&quot;D:\\\\project\\\\vm\\\\test&quot;); while (1) { LOG(INFO)&lt;&lt;&quot;this is info log&quot; ; LOG(WARNING)&lt;&lt;&quot;this is warning log&quot;; LOG(ERROR)&lt;&lt;&quot;this is error log&quot;; //LOG(FATAL) &lt;&lt; &quot;this is fatal log&quot;; Sleep(1000); } //条件日志输出 int i = 4; LOG_IF(INFO, i == 4)&lt;&lt;&quot;if log&quot;; google::ShutdownGoogleLogging(); getchar(); return;} 运行输出结果如下： 三：生成linux库Linux版本使用的centos7.3，编译生成库 1. cd glog-0.3.3 2. ./configure 3. makemake完成后会在.lib下生成相应的库文件 四.Linux下使用glog库Linux使用静态库来测试，copy静态库libglog.a和src/glog的头文件到自己的工程目录，创建main.cpp文件，添加如下代码： 1234567891011121314151617181920212223242526272829/********************************************************Copyright (C), 2016-2018,FileName: mainAuthor: woniu201Email: wangpengfei.201@163.comCreated: 2017/08/23Description: Glog使用Demo********************************************************/#include &lt;stdio.h&gt;#include &quot;glog/logging.h&quot; int main(){ //初始化参数 FLAGS_logtostderr = FALSE; //TRUE:标准输出,FALSE:文件输出 FLAGS_alsologtostderr = TRUE; //除了日志文件之外是否需要标准输出 FLAGS_colorlogtostderr = FALSE; //标准输出带颜色 FLAGS_logbufsecs = 0; //设置可以缓冲日志的最大秒数，0指实时输出 FLAGS_max_log_size = 10; //日志文件大小(单位：MB) FLAGS_stop_logging_if_full_disk = true; //磁盘满时是否记录到磁盘 google::InitGoogleLogging(&quot;mqttserver&quot;); google::SetLogDestination(google::GLOG_INFO,&quot;./test&quot;); LOG(INFO) &lt;&lt; &quot;this is log&quot;; LOG(WARNING) &lt;&lt; &quot;this is warnning&quot;; LOG(ERROR) &lt;&lt; &quot;this is error&quot;; google::ShutdownGoogleLogging();} 编译：g++ main.cpp -o main -L. -lglog -lpthread 运行：./main 输出结果如下： 关注下面公众号，回复”102”获取windows源码 关注下面公众号，回复”103”获取linux源码","link":"/2017/08/23/Applied06windows和linux环境下使用google的glog日志库/"},{"title":"一次邮件发送协议SMTP问题排查","text":"项目中需要用到smtp协议来发送邮件告警，后端的技术栈主要是Java和C++，Java项目里直接在网上找的现成的类完美实现，163邮箱，腾讯邮箱和阿里邮箱均测试通过，不幸的是C++的项目也需要使用smtp协议来发送邮件，惯例先度娘，CSDN逛了一圈，例程也不少但是每个下边留言都有这样和那样的问题，copy过来直接运行，163邮箱完美测试通过，我们用的钉钉全家桶，测试钉钉邮箱时发现不能发送邮件，认证都有问题。好吧，还是先老老实实的学习遍SMTP协议吧 WireShark抓取一次完整的邮件交互过程(关闭ssl) 流程如下： 第一步：发送EHLO指令，申明身份，表示自己身份需要验证，注意这部分需要通过Telnet验证一下，是user@example.com还是user，否则会出错。 第二步：发送AUTH LOGIN指令，登录邮箱，这一部分一般要用base64加密。 第三步：发送MAIL指令，这个命令用来开始传送邮件，它的后面跟随发件方邮件地址（返回邮件地址）。它也用来当邮件无法送达时，发送失败通知。为保证邮件的成功发送，发件方的地址应是被对方或中间转发方同意接受的。这个命令会清空有关的缓冲区，为新的邮件做准备。 第四步：发送RCPT指令，这个命令告诉收件方收件人的邮箱。当有多个收件人时，需要多次使用该命令RCPT TO，每次只能指明一个人。如果接收方服务器不同意转发这个地址的邮件，它必须报550错误代码通知发件方。如果服务器同意转发，它要更改邮件发送路径，把最开始的目的地（该服务器）换成下一个服务器。 第五步：发送DATA指令，收件方把该命令之后的数据作为发送的数据。数据被加入数据缓冲区中，以单独一行是”.”的行结束数据。结束行对于接收方同时意味立即开始缓冲区内的数据传送，传送结束后清空缓冲区。如果传送接受，接收方回复OK。 第六步：发送QUIT指令，SMTP要求接收放必须回答OK，然后中断传输；在收到这个命令并回答OK前，收件方不得中断连接，即使传输出现错误。发件方在发出这个命令并收到OK答复前，也不得中断连接。 分析： 掌握了基本的流程和抓取了数据包，只要C++也按照这种数据格式发送即可，认证不通过，首先怀疑用户名和密码传输的数据有问题，抓取C++发送的数据包，果然User数据BASE64的值不一样，Pass的值是一样的，解Base64后发现一个是user@example.com，一个是user，显然问题出在这，163邮箱要求是user，钉钉邮箱要求是user@example.com，改正后认证成功，接着发送邮件也OK，完事大吉，然而。。。一周后项目完成交给测试人员，告诉我告警邮件发不过来，怎么可能，运行工程，打脸了，只能发送一次，接着就发不出去邮件了，难道钉钉给屏蔽了，Java测试了下，没问题，好吧，继续抓包，认证是没问题的，发送过去就是收不到。 Java发送抓取的DATA数据部分如下： C++发送抓取的DATA数据部分如下： 很明显差别太大了，From，To的格式不对，Content-Type也不对，但是明显差别的是少了Message-ID字段，所以重点先分析Message-ID，又抓取了多次比对后每次的Message-ID都是不同的，怀疑这给C++只能发送一次成功有关系，C++中增加了如下代码： 1234567891011121314151617181920212223 email = &quot;From: &quot;; email += user; email += &quot;\\r\\n&quot;; email += &quot;To: &quot;; email += targetAddr; email += &quot;\\r\\n&quot;; //新增 email += &quot;Message-ID: &quot;; email += “1”; email += &quot;\\r\\n&quot;; email += &quot;Subject: &quot;; email += title; email += &quot;\\r\\n&quot;; email += &quot;MIME-Version: 1.0&quot;; email += &quot;\\r\\n&quot;; email += &quot;Content-Type: multipart/mixed;boundary=qwertyuiop&quot;; email += &quot;\\r\\n&quot;; email += &quot;\\r\\n&quot;; 运行果然成功了，但是在运行又不成功了，把Message-ID值改为2又成功了，问题果然出在这里，大功告成，最终Message-ID改为：机器名+随机数。 总结： WireShark是个很好的工具，善于使用它分析网络传输协议，抓包能够说明一切，让问题一目了然。","link":"/2019/04/08/Applied07一次邮件发送协议SMTP问题排查/"},{"title":"【Docker】：全面认识Docker和基本指令","text":"Docker逐渐成为虚拟化技术的佼佼者，接下来会推出一系列的Docker相关技术文章，Docker技术也是架构师的必备技能。 什么是DockerDocker 是一个开源的应用容器引擎，基于Go语言，诞生于2013年初，最初发起者是dotCloud公司，开发者可以打包应用到一个轻量级、可移植的容器中，然后发布到主流Linux系统上运行。 为什么用Docker 持续交付和部署：使用Docker可以通过定制应用镜像来实现持续集成，持续交付，部署。开发人员构建后的镜像，结合持续集成系统进行集成测试，而运维人员则可以在生产环境中快速部署该镜像，也可以结合持续部署系统进行自动部署。 更高效的资源利用：Docker是基于内核级的虚拟化，可以实现更高效的性能，同时对资源的额外需求很低，相比传统虚拟机方式，相同配置的主机能够运行更多的应用。 更轻松的迁移和扩展：Docker容器几乎可以在任何平台上运行，同时支持主流的操作系统发行版本。 更快速的启动时间：传统的虚拟机技术启动应用服务往往需要数分钟，而Docker容器应用，由于直接运行于宿主内核，无需启动完整的操作系统，因此可以做到妙级，甚至毫秒级的启动时间，大大的节约了开发，测试，部署的时间。 Docker与传统虚拟机差异 传统虚拟化是在硬件层面实现虚拟化，需要有额外的虚拟机管理应用和虚拟机操作系统层，而Docker容器是在操作系统层面实现虚拟化，直接复用本地主机操作系统，更加轻量级。 核心概念 Docker镜像：类似于虚拟机里的镜像，是一个只读的模板，一个独立的文件系统，使用镜像可以创建容器，可以理解为镜像是容器的基石。 Docker容器：是由Docker镜像创建的运行实例，类似于轻量级的沙箱，每个容器之间都是相互隔离的。支持的操作有启动，停止，删除等。 Docker仓库：类似于经常使用的代码仓库，如github，它是Docker集中存放镜像文件的仓所，国内也有网易，阿里等镜像仓库。 镜像操作指令获取镜像： docker pull centos (默认获取centos最新的镜像) docker pull centos:7 (获取指定标签镜像)查看本地镜像： docker images查看镜像详细信息： docker inspect centos:7 查看镜像历史： docker history centos:7删除镜像： A:使用标签删除：docker rmi centos B:使用ID删除：docker rimi构建镜像： A:使用docker commit命令 B:使用Dockerfile构建使用docker commit 例：构建一个带有jdk的镜像 按照如下步骤操作 12345678910111213141516171819[root@localhost ~]# docker run -it centos:7 /bin/bash[root@060793baf536 /]# yum install wget[root@060793baf536 /]# wget --no-check-certificate --no-cookies --header &quot;Cookie: oraclelicense=accept-securebackup-cookie&quot; http://download.oracle.com/otn-pub/java/jdk/8u131-b11/d54c1d3a095b4ff2b6607d096fa80163/jdk-8u131-linux-x64.rpm [root@060793baf536 /]# rpm -ivh jdk-8u131-linux-x64.rpmPreparing... ################################# [100%]Updating / installing... 1:jdk1.8.0_131-2000:1.8.0_131-fcs ################################# [100%]Unpacking JAR files... tools.jar... plugin.jar... javaws.jar... deploy.jar... rt.jar... jsse.jar... charsets.jar... localedata.jar...[root@060793baf536 /]# exit[root@localhost ~]# docker commit 060793baf536 centos/jdk:2.0 通过docker images命令可以看到新增了centos/jdk 标签为2.0的镜像 使用Dockerfile构建 实际使用中不推荐使用docker commit构建，应使用更灵活和强大的Dockerfile构建docker镜像，直接举例来认识Dockerfile。 例：构建一个带有jdk的centos7镜像 12[root@localhost Dockerfile]# mkdir Dockerfile[root@localhost Dockerfile]# cd Dockerfile 编写Dockerfile： 123456FROM centos:7MAINTAINER Java-Road &quot;Java-Road@qq.com&quot; RUN mkdir /usr/local/jdkCOPY jdk-8u171-linux-x64.rpm /usr/local/jdk/RUN rpm -ivh /usr/local/jdk/jdk-8u171-linux-x64.rpm 执行如下指令： 1[root@localhost Dockerfile]# docker build -t centos/jdk . 运行结果如下： docker images可以看到新生成的centos/jdk镜像。 容器操作指令1.创建启动容器： [root@localhost ~]# docker run centos:7 /bin/echo&apos;hello world&apos; 容器运行完后直接退出2.交互形式创建启动容器 [root@localhost ~]# docker run -it centos:7 /bin/bash [root@802e3623e566 /]# ps PID TTY TIME CMD 1 ? 00:00:00 bash 13 ? 00:00:00 ps [root@802e3623e566 /]# exit执行exit才能退出容器 3.守护状态运行容器 [root@localhost ~]# docker run -d centos:7 /bin/sh -c &quot;while true; do echo hello world; sleep 1; done&quot;4.启动已有的容器： docker start 容器ID 例： [root@localhost ~]# docker start 802e3623e5665.停止运行的容器： docker stop 容器ID 例： [root@localhost ~]# docker stop 802e3623e5666.删除容器： [root@localhost ~]# docker stop 89566e38c7fb [root@localhost ~]# docker rm 89566e38c7fb7.进入运行的容器： [root@localhost ~]# docker exec -it cbd8b1f35dcc /bin/bash8.导出容器： 导出容器cbd8b1f35dcc到centos_test.tar文件 [root@localhost ~]# docker export -o centos_test.tar cbd8b1f35dcc 导出的tar文件可以在其他机器上，通过导入来重新运行9.导入容器： 把导出的文件centos_test.tar通过docker import导入变成镜像 [root@localhost ~]# docker import centos_test.tar test/centos 通过docker images命令可以看到增加了个test/centos镜像","link":"/2018/06/29/Docker01全面认识Docker和基本指令/"},{"title":"【Docker】：docker安装ELK(logstash,elasticsearch,kibana)","text":"一：安装logstash1.拉取镜像 docker pull logstash:5.6.11 2.创建目录 mkdir /docker/logstash cd /docker/logstash3.创建配置文件 touch logstash.config 文件内容： input { udp { port =&gt; 8888 codec =&gt; json } } output { elasticsearch{ hosts =&gt; &quot;192.168.186.129:9200&quot; index =&gt; &quot;indextest&quot; } stdout{ codec =&gt; rubydebug } }4.创建，启动logstash容器 docker run -p 8888:8888/udp -d -v /docker/logstash:/config-dir logstash:5.6.11 -f /config-dir/logstash.conf二：安装elasticsearch1.拉取镜像 docker pull elasticsearch:5.6.112.创建数据目录 mkdir /docker/es &amp;&amp; mkdir /docker/es/data 3.创建ES容器并启动 docker run -d -p 9200:9200 -p 9300:9300 \\ -v /docker/es/data:/usr/share/elasticsearch/data \\ elasticsearch:5.6.114.测试 5.启动问题排查 默认启动ES分配2G内存，如提示内存不足，可进行修改find /var/lib/docker/overlay/ -name jvm.options 查到如下结果： /var/lib/docker/overlay2/1fb59070a037d02dccfc33e15d6e24cf9127882cc19521a1654192d3d3b1c7ec/diff/etc/logstash/jvm.options /var/lib/docker/overlay2/d2b9e8e913dff7c015cbb27b34ca4b9921bdd43869a1bfb1413af468cb14465e/diff/etc/elasticsearch/jvm.options /var/lib/docker/overlay2/dd2634a4b14f8ef455ae969466af25d147f508c0e9785bb3e7703eb933675ecf/merged/etc/logstash/jvm.options 修改elasticsearch/jvm.options把 -Xms2g 改为 -Xms512m -Xmx2g 改为 -Xmx512m 6.安装IK分词器 a.docker exec -it 容器ID b.elasticsearch-plugin install https://github.com/medcl/elasticsearch-analysis-ik/releases/download/v5.6.11/elasticsearch-analysis-ik-5.6.11.zip 重启容器加载IK分词器时候会保存，IK分词器下缺少配置文件，没搞明白为什么5.6.11安装的IK插件缺少了，宿主机下载了解压后Copy到容器中 docker cp ik/config 容器ID:/usr/share/elasticsearch/plugins/analysis-ik 重启容器测试安装的分词器： GET _analyze?pretty { &quot;analyzer&quot;: &quot;ik_smart&quot;, &quot;text&quot;: &quot;中华人民共和国国歌&quot; }三：安装kibana1.拉取kibana镜像 docker pull kibana:5.6.112.创建kibana容器并启动 docker run -p 5601:5601 -e ELASTICSEARCH_URL=http://192.168.186.129:9200 -d kibana:5.6.11 3.测试","link":"/2018/11/06/Docker02docker安装ELK/"},{"title":"【Docker】：docker安装mysql，挂载外部配置和数据","text":"普通安装1.下载镜像，mysql 5.7 docker pull mysql:5.7 2.创建mysql容器，并后台启动 docker run -d -p 3306:3306 -e MYSQL_USER=&quot;woniu&quot; -e MYSQL_PASSWORD=&quot;123456&quot; -e MYSQL_ROOT_PASSWORD=&quot;123456&quot; --name mysqltest1 mysql:5.7 --character-set-server=utf8 --collation-server=utf8_general_ci参数说明： -e MYSQL_USER=&quot;woniu&quot; ：添加woniu用户 -e MYSQL_PASSWORD=&quot;123456&quot;：设置添加的用户密码 -e MYSQL_ROOT_PASSWORD=&quot;123456&quot;：设置root用户密码 --character-set-server=utf8：设置字符集为utf8 --collation-server=utf8_general_cli：设置字符比较规则为utf8_general_cli挂载外部配置和数据安装1.创建目录和配置文件my.cnf mkdir /docker mkdir /docker/mysql mkdir /docker/mysql/conf mkdir /docker/mysql/data创建my.cnf配置文件touch /docker/mysql/conf/my.cnf my.cnf添加如下内容： [mysqld] user=mysql character-set-server=utf8 default_authentication_plugin=mysql_native_password [client] default-character-set=utf8 [mysql] default-character-set=utf82.创建容器，并后台启动 docker run -d -p 3306:3306 --privileged=true -v /docker/mysql/conf/my.cnf:/etc/mysql/my.cnf -v /docker/mysql/data:/var/lib/mysql -e MYSQL_ROOT_PASSWORD=123456 --name mysqltest2 mysql:5.7参数说明： --privileged=true：容器内的root拥有真正root权限，否则容器内root只是外部普通用户权限 -v /docker/mysql/conf/my.cnf:/etc/my.cnf：映射配置文件 -v /docker/mysql/data:/var/lib/mysql：映射数据目录","link":"/2018/07/09/Docker03docker安装mysql/"},{"title":"博文导航","text":"Docker 01:全面认识Docker和基本指令 02:docker安装ELK(logstash,elasticsearch,kibana) 03:docker安装mysql，挂载外部配置和数据 C++应用篇 01:C++生成和解析XML文件 02:C++构造和解析JSON 03:纯C++实现操作配置文件(告别跨平台问题) 04:C++操作文件行(读取，删除，修改指定行) 05:基于libcurl实现REST风格http/https的get和post 06:windows和linux环境下使用google的glog日志库 07:一次邮件发送协议SMTP问题排查 08:windows和linux环境下java调用C++代码-JNI技术 C++基础篇 01:标准输入与标准输出 02:函数重载 03:内联函数 04:new和delete 05:动态分配内存(malloc,free) 06:命名空间(namespace) 07:类的分离式写法 08:构造函数与析构函数 09:拷贝构造函数，浅拷贝和深拷贝 10:const关键字 11:友元 12:类的继承 13虚继承 14:赋值兼容","link":"/2019/07/18/博文导航/"},{"title":"纯C++实现操作配置文件(告别跨平台问题)","text":"项目中经常用到操作配置文件，考虑到跨平台问题，使用纯C++来实现操作配置文件。 CConfig.h 123456789101112131415161718192021222324252627282930313233343536#ifndef _CCONFIG_H#define _CCONFIG_H#include &lt;iostream&gt;#include &lt;string&gt;#include &lt;fstream&gt;#include &lt;vector&gt; using namespace std; class CConfig{public: CConfig(); ~CConfig(); void SetFilePath(const string &amp;filePath); string GetFilePath(); bool GetValue(const string &amp;section, const string &amp;key, string &amp;value, string &amp;error); bool ModifyValue(const string &amp;section, const string &amp;key, const string &amp;value, string &amp;error); private: bool OpenFile(); bool FindSection(const string &amp;sectionName); bool FindKey(const string &amp;key); bool OpenFileRead(); bool OpenFileWrite(); bool SetValue(const string &amp;key, const string &amp;value); void WriteFile(vector&lt;string&gt; &amp;vContent); string m_filePath; fstream m_fout; fstream m_fin; string m_content; string m_value; string m_error;};#endif CConfig.cpp 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316/********************************************************Copyright (C), 2016-2018,FileName: CConfigAuthor: woniu201Created: 2018/11/16Description: 纯C++实现配置文件的操作********************************************************/#include &quot;CConfig.h&quot; CConfig::CConfig(){ } CConfig::~CConfig(){ } /************************************@ Brief: 设置配置文件路径@ Author: woniu201@ Created: 2018/12/21@ Return:************************************/void CConfig::SetFilePath(const string &amp;filePath){ m_filePath = filePath;} /************************************@ Brief: 读取配置文件路径@ Author: woniu201@ Created: 2018/12/21@ Return:************************************/string CConfig::GetFilePath(){ return this-&gt;m_filePath;} /************************************@ Brief: 打开配置文件@ Author: woniu201@ Created: 2018/12/21@ Return:************************************/bool CConfig::OpenFile(){ if (true == m_fin.is_open()) { m_fin.close(); } m_fin.open(m_filePath.c_str()); if (!m_fin.is_open()) { m_error = &quot;open file fail:&quot; + m_filePath; return false; } return true;} /************************************@ Brief: 找节名@ Author: woniu201@ Created: 2018/12/21@ Return:************************************/bool CConfig::FindSection(const string &amp;sectionName){ if (-1 != m_content.find(&apos;[&apos;)) { string sTemp = m_content.substr(m_content.find(&apos;[&apos;) + 1, m_content.find(&apos;]&apos;) - m_content.find(&apos;[&apos;) - 1); if (0 == strcmp(sTemp.c_str(), sectionName.c_str())) { return true; } else { return false; } } else { return false; }} /************************************@ Brief: 找键名@ Author: woniu201@ Created: 2018/12/21@ Return:************************************/bool CConfig::FindKey(const string &amp;key){ size_t iDelePlace = m_content.find((char)&apos;//&apos;, 0); size_t iFindEqual = m_content.find((char)&apos;=&apos;, 0); //被注释的行，或者是包含key但是已经被注视掉了，过滤 if ((-1 != iDelePlace &amp;&amp; iDelePlace &lt; iFindEqual) || (-1 != iDelePlace &amp;&amp; -1 == iFindEqual) || -1 == iFindEqual) { return false; } string sKey = m_content.substr(0, m_content.find(&apos;=&apos;)); if (0 == strcmp(sKey.c_str(), key.c_str())) { m_value = m_content.substr(m_content.find(&apos;=&apos;) + 1, m_content.length() - m_content.find(&apos;=&apos;) - 1); return true; } return false;} /************************************@ Brief: 读取节下Key对应的value值@ Author: woniu201@ Created: 2018/12/21@ Return:************************************/bool CConfig::GetValue(const string &amp;section, const string &amp;key, string &amp;value, string &amp;error){ m_error = &quot;&quot;; if (false == OpenFile()) { error = m_error; return false; } char str[4096] = { 0 }; bool bFindSection = false; while (m_fin.getline(str, sizeof(str))) { m_content = str; if (!bFindSection) { if (FindSection(section)) { bFindSection = true; } else { m_error = &quot;&quot;; m_error = &quot;节点&quot; + section + &quot;不存在&quot;; } } else { if (FindKey(key)) { m_fin.close(); m_error = &quot;&quot;; value = m_value; return true; } else { m_error = &quot;&quot;; m_error = &quot;键名&quot; + key + &quot;不存在&quot;; } } memset(str, 0, 4096); } error = m_error; m_fin.close(); return false;} /************************************@ Brief: 读的方式打开文件@ Author: woniu201@ Created: 2018/12/21@ Return:************************************/bool CConfig::OpenFileRead(){ m_fout.close(); //关闭后要在清空一下，否则下次打开会出错 m_fout.clear(); m_fout.open(m_filePath.c_str(), ios::in); if (!m_fout.is_open()) { m_error = &quot;open file fail:&quot; + m_filePath; return false; } return true;} /************************************@ Brief: 写的方式打开文件@ Author: woniu201@ Created: 2018/12/21@ Return:************************************/bool CConfig::OpenFileWrite(){ m_fout.close(); //关闭后要在清空一下，否则下次打开会出错 m_fout.clear(); m_fout.open(m_filePath.c_str(), ios::out | ios::trunc); if (!m_fout.is_open()) { m_error = &quot;can not open file &quot; + m_filePath; return false; } return true;} /************************************@ Brief: 找KEY，设置新值@ Author: woniu201@ Created: 2018/12/21@ Return:************************************/bool CConfig::SetValue(const string &amp;key, const string &amp;value){ size_t iDelePlace = m_content.find((char)&apos;//&apos;); size_t iFindEqual = m_content.find((char)&apos;=&apos;); //被注释的行，或者是包含key但是已经被注视掉了，过滤 if ((-1 != iDelePlace &amp;&amp; iDelePlace &lt; iFindEqual) || (-1 != iDelePlace &amp;&amp; -1 == iFindEqual) || -1 == iFindEqual) { return false; } string sKey = m_content.substr(0, m_content.find(&apos;=&apos;)); if (0 == strcmp(sKey.c_str(), key.c_str())) { m_content = m_content.substr(0, m_content.find(&apos;=&apos;) + 1) + value; return true; } return false;} /************************************@ Brief: 修改配置文件KEY对应的value@ Author: woniu201@ Created: 2018/12/21@ Return:************************************/bool CConfig::ModifyValue(const string &amp;section, const string &amp;key, const string &amp;value, string &amp;error){ m_error = &quot;&quot;; if (false == OpenFileRead()) { error = m_error; return false; } char str[4096] = { 0 }; vector&lt;string&gt; vContent; bool isModify = false; bool isFindSection = false; while ( (m_fout.getline(str, sizeof(str)))) { m_content = str; if (!isFindSection) { if (FindSection(section)) { isFindSection = true; } else { m_error = &quot;&quot;; m_error = &quot;节点&quot; + section + &quot;不存在&quot;; } } else { if (!isModify) { if (SetValue(key, value)) { isModify = true; } else { m_error = &quot;&quot;; m_error = &quot;键名&quot; + key + &quot;不存在&quot;; } } } vContent.push_back(m_content); m_content = &quot;&quot;; memset(str, 0, 4096); } error = m_error; WriteFile(vContent); m_fout.flush(); m_fout.close(); return isModify;} /************************************@ Brief: 写文件@ Author: woniu201@ Created: 2018/12/21@ Return:************************************/void CConfig::WriteFile(vector&lt;string&gt; &amp;vContent){ if (false == OpenFileWrite()) { m_fout.close(); return; } for (size_t iIndex = 0; iIndex &lt; vContent.size(); iIndex++) { m_fout &lt;&lt; vContent[iIndex] &lt;&lt; endl; } m_fout.close(); vector&lt;string&gt;().swap(vContent);} main.cpp 12345678910111213141516171819#include &quot;CConfig.h&quot; int main(){ CConfig config; config.SetFilePath(&quot;a.ini&quot;); string value = &quot;&quot;; string error = &quot;&quot;; config.GetValue(&quot;ServerUrl&quot;, &quot;PcName&quot;, value, error); cout &lt;&lt; value &lt;&lt; endl; cout &lt;&lt; error &lt;&lt; endl; error = &quot;&quot;; config.ModifyValue(&quot;ServerUrl&quot;, &quot;PcName&quot;, &quot;5.0&quot;, error); cout &lt;&lt; error &lt;&lt; endl; getchar();} 配置文件a.ini内容如下：","link":"/2018/11/16/Applied03纯C++实现操作配置文件(告别跨平台问题)/"},{"title":"基于libcurl实现REST风格http/https的get和post","text":"c/c++开发中经常要用到http/https协议，直接使用socket工作量很大，要是使用socket实现https，那更不可思议，开源的c/c++的http客户端框架，libcurl是首选，而且也相当成熟稳定，最近C++项目中用到https请求，就做下研究。 一：libcurl简介(来源官网)libcurl是一个跨平台的网络协议库，支持http, https, ftp, gopher, telnet, dict, file, 和ldap 协议。libcurl同样支持HTTPS证书授权，HTTP POST, HTTP PUT, FTP 上传, HTTP基本表单上传，代理，cookies,和用户认证。官网地址：https://curl.haxx.se/libcurl/ 二：实现HTTP/GETGet.cpp 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364/********************************************************Copyright (C), 2016-2018,FileName: GetAuthor: woniu201Email: wangpengfei.201@163.comCreated: 2018/10/15Description: 实现HTTP/HTTPS GET请求********************************************************/#include &quot;main.h&quot; size_t WriteGetResp(void *buffer, size_t size, size_t nmemb, void *userp){ ((string*)userp)-&gt;append((char*)buffer, 0, size*nmemb); return size*nmemb;} /************************************@ Brief: GET请求@ Author: woniu201 @ Created: 2018/10/15@ Return: ************************************/int HttpGet(char* url){ string respData; CURL* curl; CURLcode res; curl = curl_easy_init(); if (curl == NULL) { return 1; } curl_easy_setopt(curl, CURLOPT_URL, url); curl_easy_setopt(curl, CURLOPT_WRITEFUNCTION, WriteGetResp); curl_easy_setopt(curl, CURLOPT_WRITEDATA, &amp;respData); // curl_easy_setopt(curl, CURLOPT_CONNECTTIMEOUT_MS, 5000); //libcurl存在毫秒超时bug,如果设备小于1000ms立即返回失败// curl_easy_setopt(curl, CURLOPT_TIMEOUT_MS, 5000); //设置超时时间 bool bCA = FALSE; if (!bCA) { curl_easy_setopt(curl, CURLOPT_SSL_VERIFYPEER, FALSE);//设定为不验证证书和HOST curl_easy_setopt(curl, CURLOPT_SSL_VERIFYHOST, FALSE); } else { curl_easy_setopt(curl, CURLOPT_SSL_VERIFYPEER, TRUE); curl_easy_setopt(curl, CURLOPT_CAINFO, &quot;&quot;); } res = curl_easy_perform(curl); if (res != CURLE_OK) { cout &lt;&lt; curl_easy_strerror(res) &lt;&lt; endl; } curl_easy_cleanup(curl); cout &lt;&lt; Utf8ToAscii(respData) &lt;&lt; endl; return 0;} 三：实现HTTP/POSTPost.cpp 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182/********************************************************Copyright (C), 2016-2018,FileName: PostAuthor: woniu201Email: wangpengfei.201@163.comCreated: 2018/10/15Description: 实现HTTP/HTTPS POST请求********************************************************/#include &quot;main.h&quot; size_t WritePostBodyResp(void *buffer, size_t size, size_t nmemb, void *userp){ ((string*)userp)-&gt;append((char*)buffer, 0, size*nmemb); return size*nmemb;} size_t WritePostHeaderResp(void *buffer, size_t size, size_t nmemb, void *userp){ ((string*)userp)-&gt;append((char*)buffer, 0, size*nmemb); return size*nmemb;} /************************************@ Brief: POST请求@ Author: woniu201 @ Created: 2018/10/15@ Return: ************************************/int HttpPost(char* url, char* body){ string respBodyData; string respHeadData; CURL* curl; CURLcode res; //设置头 struct curl_slist *headers = NULL; headers = curl_slist_append(headers, &quot;Content-Type:application/json;charset=UTF-8&quot;); curl = curl_easy_init(); if (curl == NULL) { return 1; } curl_easy_setopt(curl, CURLOPT_URL, url); curl_easy_setopt(curl, CURLOPT_POSTFIELDS, body); curl_easy_setopt(curl, CURLOPT_HTTPHEADER, headers); curl_easy_setopt(curl, CURLOPT_HEADERFUNCTION, WritePostHeaderResp); curl_easy_setopt(curl, CURLOPT_WRITEFUNCTION, WritePostBodyResp); curl_easy_setopt(curl, CURLOPT_WRITEHEADER, &amp;respHeadData); curl_easy_setopt(curl, CURLOPT_WRITEDATA, &amp;respBodyData); // curl_easy_setopt(curl, CURLOPT_CONNECTTIMEOUT_MS, 5000); //libcurl存在毫秒超时bug,如果设备小于1000ms立即返回失败 // curl_easy_setopt(curl, CURLOPT_TIMEOUT_MS, 5000); //设置超时时间 bool bCA = FALSE; if (!bCA) { curl_easy_setopt(curl, CURLOPT_SSL_VERIFYPEER, FALSE);//设定为不验证证书和HOST curl_easy_setopt(curl, CURLOPT_SSL_VERIFYHOST, FALSE); } else { curl_easy_setopt(curl, CURLOPT_SSL_VERIFYPEER, TRUE); curl_easy_setopt(curl, CURLOPT_CAINFO, &quot;&quot;); } res = curl_easy_perform(curl); if (res != CURLE_OK) { cout &lt;&lt; curl_easy_strerror(res) &lt;&lt; endl; } curl_slist_free_all(headers); curl_easy_cleanup(curl); cout &lt;&lt; Utf8ToAscii(respHeadData) &lt;&lt; endl; cout &lt;&lt; Utf8ToAscii(respBodyData) &lt;&lt; endl; return 0;} 其他代码Utils.cpp 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879/********************************************************Copyright (C), 2016-2018,FileName: utilsAuthor: woniu201Email: wangpengfei.201@163.comCreated: 2018/10/15Description: ASSIC--UTF8互转********************************************************/#include &quot;main.h&quot;#include &lt;string&gt;#include &lt;Windows.h&gt;#include &lt;wchar.h&gt;using namespace std; wstring AsciiToUnicode(const string&amp; str) { // 预算-缓冲区中宽字节的长度 int unicodeLen = MultiByteToWideChar(CP_ACP, 0, str.c_str(), -1, nullptr, 0); // 给指向缓冲区的指针变量分配内存 wchar_t *pUnicode = (wchar_t*)malloc(sizeof(wchar_t)*unicodeLen); // 开始向缓冲区转换字节 MultiByteToWideChar(CP_ACP, 0, str.c_str(), -1, pUnicode, unicodeLen); wstring ret_str = pUnicode; free(pUnicode); return ret_str; } string UnicodeToAscii(const wstring&amp; wstr) { // 预算-缓冲区中多字节的长度 int ansiiLen = WideCharToMultiByte(CP_ACP, 0, wstr.c_str(), -1, nullptr, 0, nullptr, nullptr); // 给指向缓冲区的指针变量分配内存 char *pAssii = (char*)malloc(sizeof(char)*ansiiLen); // 开始向缓冲区转换字节 WideCharToMultiByte(CP_ACP, 0, wstr.c_str(), -1, pAssii, ansiiLen, nullptr, nullptr); string ret_str = pAssii; free(pAssii); return ret_str; } wstring Utf8ToUnicode(const string&amp; str) { // 预算-缓冲区中宽字节的长度 int unicodeLen = MultiByteToWideChar(CP_UTF8, 0, str.c_str(), -1, nullptr, 0); // 给指向缓冲区的指针变量分配内存 wchar_t *pUnicode = (wchar_t*)malloc(sizeof(wchar_t)*unicodeLen); // 开始向缓冲区转换字节 MultiByteToWideChar(CP_UTF8, 0, str.c_str(), -1, pUnicode, unicodeLen); wstring ret_str = pUnicode; free(pUnicode); return ret_str; } string UnicodeToUtf8(const wstring&amp; wstr) { // 预算-缓冲区中多字节的长度 int ansiiLen = WideCharToMultiByte(CP_UTF8, 0, wstr.c_str(), -1, nullptr, 0, nullptr, nullptr); // 给指向缓冲区的指针变量分配内存 char *pAssii = (char*)malloc(sizeof(char)*ansiiLen); // 开始向缓冲区转换字节 WideCharToMultiByte(CP_UTF8, 0, wstr.c_str(), -1, pAssii, ansiiLen, nullptr, nullptr); string ret_str = pAssii; free(pAssii); return ret_str; } /************************************@ Brief: ASSIC转UTF8@ Author: woniu201 @ Created: 2018/10/16@ Return: ************************************/string AsciiToUtf8(const string&amp; str) { return UnicodeToUtf8(AsciiToUnicode(str)); } /************************************@ Brief: UTF8转ASSIC@ Author: woniu201 @ Created: 2018/10/16@ Return: ************************************/string Utf8ToAscii(const string&amp; str) { return UnicodeToAscii(Utf8ToUnicode(str)); } main.h 1234567891011121314151617181920#ifndef _MAIN_H#define _MAIN_H #include &lt;iostream&gt;#include &lt;string&gt;#include &quot;include/curl.h&quot; using namespace std; #pragma comment(lib, &quot;ssleay32.lib&quot;)#pragma comment(lib, &quot;libcurl.lib&quot;) string AsciiToUtf8(const string&amp; str);string Utf8ToAscii(const string&amp; str); int HttpGet(char* url);int HttpPost(char* url, char* body);int HttpDownload(char* url, char* filePath);#endif","link":"/2018/10/16/Applied05基于libcurl实现REST风格http-https的get和post/"},{"title":"windows和linux环境下java调用C++代码-JNI技术","text":"最近部门做安卓移动开发的需要调C++的代码，困难重重，最后任务交给了我，查找相关资料，没有一个教程能把不同环境(windows,linux)下怎么调用说明白的，自己在实现的过程中踩了几个坑，在这里总结下，希望看到的以后能少走弯路。 使用工具： 1.JAVA使用的IDE为eclipse 2.windows环境下C++使用的IDE为visual studio 2010 3.linux环境下C++使用的编译器为gcc/g++一.windows环境下java调用C++代码1.1新建java工程，生成相应头文件 eclipse新建工程名为”jniDemo”的java工程，在包名为com.woniu.Native下新建”NativeCpp.java”类，如下： 1234567package com.woniu.Native; public class NativeCpp { public native void fun1(); public native int fun2(int a, int b); public native void fun3(String url1, String url2);} 编译生成.class文件 进入工程下的target\\classes目录下，执行”javah -jni com.woniu.Native.NativeCpp”,运行结果如下： 此时，会在classes目录下生成”com_woniu_Native_NativeCpp.h”头文件，头文件内容如下： 12345678910111213141516171819202122232425262728293031323334353637/* DO NOT EDIT THIS FILE - it is machine generated */#include &lt;jni.h&gt;/* Header for class com_woniu_Native_NativeCpp */ #ifndef _Included_com_woniu_Native_NativeCpp#define _Included_com_woniu_Native_NativeCpp#ifdef __cplusplusextern &quot;C&quot; {#endif/* * Class: com_woniu_Native_NativeCpp * Method: fun1 * Signature: ()V */JNIEXPORT void JNICALL Java_com_woniu_Native_NativeCpp_fun1 (JNIEnv *, jobject); /* * Class: com_woniu_Native_NativeCpp * Method: fun2 * Signature: (II)I */JNIEXPORT jint JNICALL Java_com_woniu_Native_NativeCpp_fun2 (JNIEnv *, jobject, jint, jint); /* * Class: com_woniu_Native_NativeCpp * Method: fun3 * Signature: (Ljava/lang/String;Ljava/lang/String;)V */JNIEXPORT void JNICALL Java_com_woniu_Native_NativeCpp_fun3 (JNIEnv *, jobject, jstring, jstring); #ifdef __cplusplus}#endif#endif 1.2 c++生成动态库vs2010新建工程名为”JniDll”的win32控制台应用程序，win32应用程序向导界面选择 “DLL” 创建完成后，把2.1中生成的”com_woniu_Native_NativeCpp.h”头文件放入该工程，并把头文件中的#include &lt;jni.h&gt;改为 “jni.h”，把JDK下include文件夹下的”jni.h”和include下win32文件夹下的”jni_md.h”头文件也一同放入创建的工程中。 工程目录如下： 编辑JniDll.cpp源码文件，实现头文件中的函数，如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051/********************************************************Copyright (C), 2016-2017,FileName: jniAuthor: woniu201Email: wangpengfei.201@163.comCreated: 2017/09/20Description:Jni function********************************************************/#include &quot;stdafx.h&quot;#include &quot;com_woniu_Native_NativeCpp.h&quot;#include &quot;stdio.h&quot;#include &quot;stdlib.h&quot; JNIEXPORT void JNICALL Java_com_woniu_Native_NativeCpp_fun1 (JNIEnv *, jobject){ printf(&quot;hello world\\n&quot;);} JNIEXPORT jint JNICALL Java_com_woniu_Native_NativeCpp_fun2 (JNIEnv *, jobject, jint a, jint b){ return a + b;} char* jstringToChar(JNIEnv* env, jstring jstr) { char* rtn = NULL; jclass clsstring = env-&gt;FindClass(&quot;java/lang/String&quot;); jstring strencode = env-&gt;NewStringUTF(&quot;GB2312&quot;); jmethodID mid = env-&gt;GetMethodID(clsstring, &quot;getBytes&quot;, &quot;(Ljava/lang/String;)[B&quot;); jbyteArray barr = (jbyteArray) env-&gt;CallObjectMethod(jstr, mid, strencode); jsize alen = env-&gt;GetArrayLength(barr); jbyte* ba = env-&gt;GetByteArrayElements(barr, JNI_FALSE); if (alen &gt; 0) { rtn = (char*) malloc(alen + 1); memcpy(rtn, ba, alen); rtn[alen] = 0; } env-&gt;ReleaseByteArrayElements(barr, ba, 0); return rtn;} JNIEXPORT void JNICALL Java_com_woniu_Native_NativeCpp_fun3 (JNIEnv *env, jobject, jstring url1, jstring url2){ //jstringתchar* char* pUrl1 = jstringToChar(env, url1); char* pUrl2 = jstringToChar(env, url2); printf(&quot;url1 = %s\\n&quot;, pUrl1); printf(&quot;url2 = %s\\n&quot;, pUrl2);} 我本机是64位系统，使用的是64位JDK，这里生成的动态库也要生成64位的库，否则调用的时候报如下错误： 更改vs编译生成64位dll，步骤如下： 编译生成解决方案，这时候会在工程根目录下，生成”x64文件夹”，Debug文件夹下会有动态库”JniDll.dll” 1.3 java调用dll 123456789101112131415package com.woniu.jniDemo; import com.woniu.Native.NativeCpp; public class App { public static void main( String[] args ) { System.load(&quot;D:\\\\VS2010\\\\VC\\\\JniDll\\\\x64\\\\Debug\\\\JniDll.dll&quot;); NativeCpp nativeCpp = new NativeCpp(); nativeCpp.fun1(); System.out.println(nativeCpp.fun2(3, 3)); nativeCpp.fun3(&quot;www.baidu.com&quot;, &quot;www.haoservice.cn&quot;); }} 运行结果如下： 二：linux(CentOS)环境下java调用C++代码2.1 编译环境 a.安装gcc和g++ yum install gcc-c++ b.安装jdk 去官网上下载jdk安装包，建议使用rpm安装包，会自动配置环境变量。安装完后如下： 本机的安装目录为：/usr/java/jdk1.8.0_144/，不同版本可能不同。 这里一定要注意不能安装openjdk,因为openjdk没有include目录，编译时需要用到include目录的头文件。 2.2 制作动态库(so库) a.创建文件夹&quot;jniso&quot;,mkdir jniso。 b.把2.1中生成的头文件&quot;com_woniu_Native_NativeCpp.h&quot;拷贝过来,#include &quot;jni.h&quot;改为#include &lt;jni.h&gt; c.新建jni.cpp源文件，添加如下代码：123456789101112131415161718192021222324252627282930313233343536373839404142#include &lt;jni.h&gt;#include &quot;com_woniu_Native_NativeCpp.h&quot;#include &quot;stdio.h&quot;#include &quot;stdlib.h&quot;#include &quot;string.h&quot; JNIEXPORT void JNICALL Java_com_woniu_Native_NativeCpp_fun1 (JNIEnv *, jobject){ printf(&quot;hello world\\n&quot;);} JNIEXPORT jint JNICALL Java_com_woniu_Native_NativeCpp_fun2 (JNIEnv *, jobject, jint a, jint b){ return a + b;} char* jstringToChar(JNIEnv* env, jstring jstr) { char* rtn = NULL; jclass clsstring = env-&gt;FindClass(&quot;java/lang/String&quot;); jstring strencode = env-&gt;NewStringUTF(&quot;GB2312&quot;); jmethodID mid = env-&gt;GetMethodID(clsstring, &quot;getBytes&quot;, &quot;(Ljava/lang/String;)[B&quot;); jbyteArray barr = (jbyteArray) env-&gt;CallObjectMethod(jstr, mid, strencode); jsize alen = env-&gt;GetArrayLength(barr); jbyte* ba = env-&gt;GetByteArrayElements(barr, JNI_FALSE); if (alen &gt; 0) { rtn = (char*) malloc(alen + 1); memcpy(rtn, ba, alen); rtn[alen] = 0; } env-&gt;ReleaseByteArrayElements(barr, ba, 0); return rtn;} JNIEXPORT void JNICALL Java_com_woniu_Native_NativeCpp_fun3 (JNIEnv *env, jobject, jstring url1, jstring url2){ char* pUrl1 = jstringToChar(env, url1); char* pUrl2 = jstringToChar(env, url2); printf(&quot;url1 = %s\\n&quot;, pUrl1); printf(&quot;url2 = %s\\n&quot;, pUrl2);} d.编译，生成动态库g++ -fPIC -c jni.cpp -I /usr/java/jdk1.8.0_144/include/ -I /usr/java/jdk1.8.0_144/include/linux/g++ -shared jni.o -o jni.so 2.3 java调用jni.so 123456789101112131415161718import com.woniu.Native.NativeCpp; public class App { public static void main( String[] args ) { //windows环境下加载库 //System.load(&quot;D:\\\\VS2010\\\\VC\\\\JniDll\\\\x64\\\\Debug\\\\JniDll.dll&quot;); //linux下加载库 System.load(&quot;/mnt/hgfs/svn/svn/Demo/jniso/jni.so&quot;); NativeCpp nativeCpp = new NativeCpp(); nativeCpp.fun1(); System.out.println(nativeCpp.fun2(3, 3)); nativeCpp.fun3(&quot;www.baidu.com&quot;, &quot;www.haoservice.cn&quot;); }} 运行结果如下： 关注下面公众号，回复”105”获取windows下生成dll源码 关注下面公众号，回复”106”获取linux下生成so源码","link":"/2017/09/20/Applied08JNI技术/"}],"tags":[{"name":"标准输入与输出","slug":"标准输入与输出","link":"/tags/标准输入与输出/"},{"name":"函数重载","slug":"函数重载","link":"/tags/函数重载/"},{"name":"内联函数","slug":"内联函数","link":"/tags/内联函数/"},{"name":"new","slug":"new","link":"/tags/new/"},{"name":"delete","slug":"delete","link":"/tags/delete/"},{"name":"malloc","slug":"malloc","link":"/tags/malloc/"},{"name":"free","slug":"free","link":"/tags/free/"},{"name":"命名空间","slug":"命名空间","link":"/tags/命名空间/"},{"name":"类的分离式写法","slug":"类的分离式写法","link":"/tags/类的分离式写法/"},{"name":"构造函数","slug":"构造函数","link":"/tags/构造函数/"},{"name":"析构函数","slug":"析构函数","link":"/tags/析构函数/"},{"name":"浅拷贝","slug":"浅拷贝","link":"/tags/浅拷贝/"},{"name":"深拷贝","slug":"深拷贝","link":"/tags/深拷贝/"},{"name":"const","slug":"const","link":"/tags/const/"},{"name":"友元","slug":"友元","link":"/tags/友元/"},{"name":"继承","slug":"继承","link":"/tags/继承/"},{"name":"虚继承","slug":"虚继承","link":"/tags/虚继承/"},{"name":"XML","slug":"XML","link":"/tags/XML/"},{"name":"JSON","slug":"JSON","link":"/tags/JSON/"},{"name":"docker","slug":"docker","link":"/tags/docker/"},{"name":"ELK","slug":"ELK","link":"/tags/ELK/"},{"name":"mysql","slug":"mysql","link":"/tags/mysql/"},{"name":"配置文件","slug":"配置文件","link":"/tags/配置文件/"}],"categories":[{"name":"C++基础","slug":"C-基础","link":"/categories/C-基础/"},{"name":"C++应用篇","slug":"C-应用篇","link":"/categories/C-应用篇/"},{"name":"Docker","slug":"Docker","link":"/categories/Docker/"}]}