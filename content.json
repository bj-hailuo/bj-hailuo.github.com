{"pages":[{"title":"","text":"关于我 本科通信工程专业，研究生通信与信息系统，从事开发十余年，coding带来无限乐趣，现就职一家创业公司，有倒下的倾向。 早期开发语言是C/C++，写后台服务，也使用MFC和Qt做过PC客户端开发，近几年在用java，对spring boot，spring cloud略懂一二。 开源项目，一款股票行情的软件：https://github.com/woniu201/WnStock ，如感兴趣记得来个star。 公众号 码农code之路，定期分享优质技术文章，互联网趣事，快讯，还有高薪内推职位，欢迎关注！","link":"/about/index.html"}],"posts":[{"title":"博文导航","text":"我的开源 股票软件简介+源码(蜗牛股票软件) 数据结构与算法 01:通俗易懂说链表 02:单向链表实现与封装(有头) 03:两分钟初识树 04:二叉树的创建，插入，遍历，删除实现 开源组件 01:两分钟搞懂开源许可协议 02:FastDFS极速入门与安装 03:FastDFS集群搭建与实战 04:定时任务框架Quartz(一) 05:定时任务框架Quartz(二) Docker 01:全面认识Docker和基本指令 02:docker安装ELK(logstash,elasticsearch,kibana) 03:docker安装mysql，挂载外部配置和数据 04:docker安装redis，挂载外部配置和数据 C++应用篇 01:C++生成和解析XML文件 02:C++构造和解析JSON 03:纯C++实现操作配置文件(告别跨平台问题) 04:C++操作文件行(读取，删除，修改指定行) 05:基于libcurl实现REST风格http/https的get和post 06:windows和linux环境下使用google的glog日志库 07:一次邮件发送协议SMTP问题排查 08:windows和linux环境下java调用C++代码-JNI技术 09:C++实现16进制字符串转换成int整形值 10:Rabbitmq C++客户端 Rabbitmq Client使用 11:基于Snappy实现数据压缩和解压 C++提高篇 01:指针数组与数组指针 02:指针函数与函数指针 C++基础篇 01:标准输入与标准输出 02:函数重载 03:内联函数 04:new和delete 05:动态分配内存(malloc,free) 06:命名空间(namespace) 07:类的分离式写法 08:构造函数与析构函数 09:拷贝构造函数，浅拷贝和深拷贝 10:const关键字 11:友元 12:类的继承 13虚继承 14:赋值兼容","link":"/2019/07/18/博文导航/"},{"title":"基于Snappy实现数据压缩和解压","text":"Snappy是谷歌开源的一个用来压缩和解压的开发包。相较其他压缩算法速率有明显的优势，官方文档显示在64位 i7处理器上，每秒可达200~500MB的压缩速度，不禁感叹大厂的算法就是厉害。 开源项目地址：https://github.com/google/snappy 开撸1.下载最新版本Snappy 1.1.7，下载地址如下： https://github.com/google/snappy/releases2.解压： tar -zxvf tar -zxvf snappy-1.1.7.tar.gz3.进入该目录 cd snappy-1.1.74.创建build目录 mkdir build5.本机需要安装cmake工具，版本&gt;=3.1。执行cmake cd build &amp; cmake ../6.编译 makebuild目录下回生成静态库libsnappy.a，所需头文件snappy-stubs-public.h和根目录下的snappy.h。 有了库文件和两个头文件，可以使用了。 新建snappy-test目录，把库文件libsnappy.a，snappy.h，snappy-stubs-public.h三个文件放到该目录下新建main.cpp文件。 1234567891011121314151617181920212223242526272829#include &lt;iostream&gt;#include &quot;snappy.h&quot;#include &lt;string.h&gt; using namespace std; int main(){ string input = &quot;i love china!&quot;; for(int i=0; i&lt;5; i++) { input += input; } cout &lt;&lt; &quot;压缩前：&quot; &lt;&lt; input.size() &lt;&lt; endl; cout &lt;&lt; input &lt;&lt; endl; cout &lt;&lt; &quot;=================================&quot; &lt;&lt; endl; string output = &quot;&quot;; snappy::Compress(input.data(), input.size(), &amp;output); cout &lt;&lt; &quot;压缩后：&quot; &lt;&lt; output.size() &lt;&lt; endl; cout &lt;&lt; output &lt;&lt; endl; cout &lt;&lt; &quot;=================================&quot; &lt;&lt; endl; string str = &quot;&quot;; snappy::Uncompress(output.data(), output.size(), &amp;str); cout &lt;&lt; &quot;解压后：&quot; &lt;&lt; str.size() &lt;&lt; endl; cout &lt;&lt; str &lt;&lt; endl; return 1;} 运行结果： 压缩前416字节，压缩后37字节。 不想编译库的可以直接下载： 关注下面公众号，回复”108”获取snappy-windows源码 关注下面公众号，回复”109”获取snappy-linux源码","link":"/2019/07/12/Applied11基于Snappy实现数据压缩和解压/"},{"title":"Qt:StyleSheet使用总结","text":"转眼七年过去了，我是一个彻底拥抱过MFC的人，记得老大的一个需求要把按钮做成圆角，并添加背景颜色，做前端html的可能认为很简单，然而放到MFC上那可真的是很…很麻烦的，自定义类继承Button ，新手估计还搞不定，怎么也有上百行代码，实在不友好，Qt诞生大大简化了这些工作，只需要使用QSS（Qt Style Sheet）就可以轻松做到，最近详细了解了QSS，做了个百度网盘的登录界面，整理好我会把源码放出来，供大家参考。 QSS语法background-color:rgb(6, 168, 255); 背景色 color:red; 字体颜色 border-radius:5px; 边框圆角半径 border:2px solid green; 边框2像素，实现，绿色 font:10pt; 字体大小10 设置QSS方法方法一：UI界面设置 鼠标到按钮上右键，”改变样式表”，在编辑样式表对话框中添加QSS样式。 方法二：程序添加 每一个控件都有setStyleSheet(const QString &amp;styleSheet)方法，样式字符串直接传参即可，例： 1ui.pushButton1-&gt;setStyleSheet(&quot;QPushButton{background-color: white; color: rgb(100, 100, 100) ;}&quot;); 方法三：通过QSS文件添加 新建文件StyleSheet.qss文件，添加内容如下： /*按钮静止无操作样式*/ QPushButton { background-color:rgb(255,255,255); color:rgb(6,168,255); border:2px solid rgb(6,168,255); font-size:14px; border-radius:10px; } /*鼠标悬停在按钮*/ QPushButton:hover { background-color: rgb(212,243,255); color:rgb(6,168,255); border:2px solid rgb(6,168,255); border-radius:14px; } /*鼠标按下按钮*/ QPushButton:pressed { background-color: rgb(175,232,255); color:white; border:2px solid rgb(6,168,255); border-radius:14px; }读取配置文件设置指定按钮样式： 123456789101112131415161718192021222324StyleDialog::StyleDialog(QWidget *parent) : QDialog(parent){ ui.setupUi(this); QString strStyle = ReadQssFile(&quot;StyleSheet.qss&quot;); ui.pushButton2-&gt;setStyleSheet(strStyle);} StyleDialog::~StyleDialog(){} QString StyleDialog::ReadQssFile(const QString&amp; filePath){ QString strStyleSheet = &quot;&quot;; QFile file(filePath); file.open(QFile::ReadOnly); if (file.isOpen()) { strStyleSheet = QLatin1String(file.readAll()); } return strStyleSheet;} 实际项目中一般qss文件直接添加到资源里面，一起打包到EXE文件中，这样文件不会直接暴露给用户。 Selector一个UI界面有很多控件，使用一个qss文件来指定样式时，可以使用Selector来分别设置控件的样式 1.属性覆盖，一个qss文件里，后面定义的style会覆盖先前的style。 2.同一行中多个类型需要用逗号分隔。 1234QPushButton, QLineEdit, QCheckBox{ background: color: black;} 3.属性分类 例如：有6个PushButton控件，3个设置为样式一，另外三个设置为样式二 方法一： 设置前3个控件的whatsThis为style1，后三个控件为style2 修改StyleSheet.qss文件内容 1234567891011QPushButton[whatsThis=&quot;style1&quot;]{ background-color: rgb(63,141,215); color:green;} QPushButton[whatsThis=&quot;style2&quot;]{ background-color: rgb(63,141,215); color:red;} 方法二： 直接在qss文件里指定object name，不推荐这种方式，6个控件需要些六遍，分别指定object name。 12345QPushButton#pushButton1{ background-color: rgb(63,141,215); color:red;} 最后在程序的入口函数设置如下代码： 1234QApplication a(argc, argv); StyleDialog styleDialog;a.setStyleSheet(styleDialog.ReadQssFile(&quot;:/qtlearn/Resources/StyleSheet.qss&quot;)); 最后附上一张使用QSS技术仿的百度网盘界面：","link":"/2019/04/23/Qt06StyleSheet使用总结/"},{"title":"一次邮件发送协议SMTP问题排查","text":"项目中需要用到smtp协议来发送邮件告警，后端的技术栈主要是Java和C++，Java项目里直接在网上找的现成的类完美实现，163邮箱，腾讯邮箱和阿里邮箱均测试通过，不幸的是C++的项目也需要使用smtp协议来发送邮件，惯例先度娘，CSDN逛了一圈，例程也不少但是每个下边留言都有这样和那样的问题，copy过来直接运行，163邮箱完美测试通过，我们用的钉钉全家桶，测试钉钉邮箱时发现不能发送邮件，认证都有问题。好吧，还是先老老实实的学习遍SMTP协议吧 WireShark抓取一次完整的邮件交互过程(关闭ssl) 流程如下： 第一步：发送EHLO指令，申明身份，表示自己身份需要验证，注意这部分需要通过Telnet验证一下，是user@example.com还是user，否则会出错。 第二步：发送AUTH LOGIN指令，登录邮箱，这一部分一般要用base64加密。 第三步：发送MAIL指令，这个命令用来开始传送邮件，它的后面跟随发件方邮件地址（返回邮件地址）。它也用来当邮件无法送达时，发送失败通知。为保证邮件的成功发送，发件方的地址应是被对方或中间转发方同意接受的。这个命令会清空有关的缓冲区，为新的邮件做准备。 第四步：发送RCPT指令，这个命令告诉收件方收件人的邮箱。当有多个收件人时，需要多次使用该命令RCPT TO，每次只能指明一个人。如果接收方服务器不同意转发这个地址的邮件，它必须报550错误代码通知发件方。如果服务器同意转发，它要更改邮件发送路径，把最开始的目的地（该服务器）换成下一个服务器。 第五步：发送DATA指令，收件方把该命令之后的数据作为发送的数据。数据被加入数据缓冲区中，以单独一行是”.”的行结束数据。结束行对于接收方同时意味立即开始缓冲区内的数据传送，传送结束后清空缓冲区。如果传送接受，接收方回复OK。 第六步：发送QUIT指令，SMTP要求接收放必须回答OK，然后中断传输；在收到这个命令并回答OK前，收件方不得中断连接，即使传输出现错误。发件方在发出这个命令并收到OK答复前，也不得中断连接。 分析： 掌握了基本的流程和抓取了数据包，只要C++也按照这种数据格式发送即可，认证不通过，首先怀疑用户名和密码传输的数据有问题，抓取C++发送的数据包，果然User数据BASE64的值不一样，Pass的值是一样的，解Base64后发现一个是user@example.com，一个是user，显然问题出在这，163邮箱要求是user，钉钉邮箱要求是user@example.com，改正后认证成功，接着发送邮件也OK，完事大吉，然而。。。一周后项目完成交给测试人员，告诉我告警邮件发不过来，怎么可能，运行工程，打脸了，只能发送一次，接着就发不出去邮件了，难道钉钉给屏蔽了，Java测试了下，没问题，好吧，继续抓包，认证是没问题的，发送过去就是收不到。 Java发送抓取的DATA数据部分如下： C++发送抓取的DATA数据部分如下： 很明显差别太大了，From，To的格式不对，Content-Type也不对，但是明显差别的是少了Message-ID字段，所以重点先分析Message-ID，又抓取了多次比对后每次的Message-ID都是不同的，怀疑这给C++只能发送一次成功有关系，C++中增加了如下代码： 1234567891011121314151617181920212223 email = &quot;From: &quot;; email += user; email += &quot;\\r\\n&quot;; email += &quot;To: &quot;; email += targetAddr; email += &quot;\\r\\n&quot;; //新增 email += &quot;Message-ID: &quot;; email += “1”; email += &quot;\\r\\n&quot;; email += &quot;Subject: &quot;; email += title; email += &quot;\\r\\n&quot;; email += &quot;MIME-Version: 1.0&quot;; email += &quot;\\r\\n&quot;; email += &quot;Content-Type: multipart/mixed;boundary=qwertyuiop&quot;; email += &quot;\\r\\n&quot;; email += &quot;\\r\\n&quot;; 运行果然成功了，但是在运行又不成功了，把Message-ID值改为2又成功了，问题果然出在这里，大功告成，最终Message-ID改为：机器名+随机数。 总结： WireShark是个很好的工具，善于使用它分析网络传输协议，抓包能够说明一切，让问题一目了然。","link":"/2019/04/08/Applied07一次邮件发送协议SMTP问题排查/"},{"title":"数据结构与算法:通俗易懂说链表","text":"链表（Linked list）由一些节点组成，物理存储非连续的线性表。其中每个节点都会存储下个节点的指针，由于实际存储空间不连续，对链表插入节点，删除节点可以达到O(1)的复杂度，但是对一个节点的访问需要O(n)的时间。 链表有单向链表，双向链表。 一：单向链表单向链表的每个节点有数据项和指针(指向下个节点地址数据)组成，下图为一个单向链表，表头没有数据项，只有指向下一个节点的指针。表尾节点指向下一个节点pNext指针为NULL（空）。 结构体表示为： //单向链表节点数据结构 typedef struct linkNode { void *val; //数据项(任意类型) struct linkNode *next; }node; 插入节点操作：单向链表中由四个数据节点，数据1，数据2，数据3，数据4，现在数据1和数据2节点间插入数据5，只需把数据1节点的pNext指向新的节点，把新节点的pNext指向数据2节点即可。 删除节点操作：删除节点2，只需把第一个节点的pNext执行数据3节点，同时释放节点2的存储空间即可。 二：双向链表双向链表有别于单向的，每个节点除了数据项外有两个指针分别指向前一个节点和后一个节点，占用空间会大一些，可以实现从头到尾的遍历，又可以从尾到头遍历。 结构体表示为： 1234567//双向链表节点数据结构typedef struct dLinkNode{ void *val; //数据项(任意类型) struct dLinkNode *prev; struct dLinkNode *next;}node; 插入节点操作：节点1与节点2之间插入新节点5，需要把节点1的pNext指向节点5，节点5的pHead指向节点1，节点5的pNext指向节点2，节点2的pHead指向节点5，如下图所示： 删除节点操作：删除节点2，把节点1的pNext指向节点3，把节点3的pHead指向节点1，同时释放节点2的存储空间即可。 三：链表与数组区别1.链表存储空间不连续，可以充分利用碎片空间，数组的存储空间是连续的，内存空间要求高，必须要有足够连续的内存空间。 2.链表的插入删除元素简单，无需对元素移动，但查询元素会慢，数组对元素的插入删除较复杂，同时使用时要预先指定长度，但数组的查询会很快。","link":"/2019/04/02/DSA01通俗易懂说链表/"},{"title":"【Docker】：全面认识Docker和基本指令","text":"Docker逐渐成为虚拟化技术的佼佼者，接下来会推出一系列的Docker相关技术文章，Docker技术也是架构师的必备技能。 什么是DockerDocker 是一个开源的应用容器引擎，基于Go语言，诞生于2013年初，最初发起者是dotCloud公司，开发者可以打包应用到一个轻量级、可移植的容器中，然后发布到主流Linux系统上运行。 为什么用Docker 持续交付和部署：使用Docker可以通过定制应用镜像来实现持续集成，持续交付，部署。开发人员构建后的镜像，结合持续集成系统进行集成测试，而运维人员则可以在生产环境中快速部署该镜像，也可以结合持续部署系统进行自动部署。 更高效的资源利用：Docker是基于内核级的虚拟化，可以实现更高效的性能，同时对资源的额外需求很低，相比传统虚拟机方式，相同配置的主机能够运行更多的应用。 更轻松的迁移和扩展：Docker容器几乎可以在任何平台上运行，同时支持主流的操作系统发行版本。 更快速的启动时间：传统的虚拟机技术启动应用服务往往需要数分钟，而Docker容器应用，由于直接运行于宿主内核，无需启动完整的操作系统，因此可以做到妙级，甚至毫秒级的启动时间，大大的节约了开发，测试，部署的时间。 Docker与传统虚拟机差异 传统虚拟化是在硬件层面实现虚拟化，需要有额外的虚拟机管理应用和虚拟机操作系统层，而Docker容器是在操作系统层面实现虚拟化，直接复用本地主机操作系统，更加轻量级。 核心概念 Docker镜像：类似于虚拟机里的镜像，是一个只读的模板，一个独立的文件系统，使用镜像可以创建容器，可以理解为镜像是容器的基石。 Docker容器：是由Docker镜像创建的运行实例，类似于轻量级的沙箱，每个容器之间都是相互隔离的。支持的操作有启动，停止，删除等。 Docker仓库：类似于经常使用的代码仓库，如github，它是Docker集中存放镜像文件的仓所，国内也有网易，阿里等镜像仓库。 镜像操作指令获取镜像： docker pull centos (默认获取centos最新的镜像) docker pull centos:7 (获取指定标签镜像)查看本地镜像： docker images查看镜像详细信息： docker inspect centos:7 查看镜像历史： docker history centos:7删除镜像： A:使用标签删除：docker rmi centos B:使用ID删除：docker rimi构建镜像： A:使用docker commit命令 B:使用Dockerfile构建使用docker commit 例：构建一个带有jdk的镜像 按照如下步骤操作 12345678910111213141516171819[root@localhost ~]# docker run -it centos:7 /bin/bash[root@060793baf536 /]# yum install wget[root@060793baf536 /]# wget --no-check-certificate --no-cookies --header &quot;Cookie: oraclelicense=accept-securebackup-cookie&quot; http://download.oracle.com/otn-pub/java/jdk/8u131-b11/d54c1d3a095b4ff2b6607d096fa80163/jdk-8u131-linux-x64.rpm [root@060793baf536 /]# rpm -ivh jdk-8u131-linux-x64.rpmPreparing... ################################# [100%]Updating / installing... 1:jdk1.8.0_131-2000:1.8.0_131-fcs ################################# [100%]Unpacking JAR files... tools.jar... plugin.jar... javaws.jar... deploy.jar... rt.jar... jsse.jar... charsets.jar... localedata.jar...[root@060793baf536 /]# exit[root@localhost ~]# docker commit 060793baf536 centos/jdk:2.0 通过docker images命令可以看到新增了centos/jdk 标签为2.0的镜像 使用Dockerfile构建 实际使用中不推荐使用docker commit构建，应使用更灵活和强大的Dockerfile构建docker镜像，直接举例来认识Dockerfile。 例：构建一个带有jdk的centos7镜像 12[root@localhost Dockerfile]# mkdir Dockerfile[root@localhost Dockerfile]# cd Dockerfile 编写Dockerfile： 123456FROM centos:7MAINTAINER Java-Road &quot;Java-Road@qq.com&quot; RUN mkdir /usr/local/jdkCOPY jdk-8u171-linux-x64.rpm /usr/local/jdk/RUN rpm -ivh /usr/local/jdk/jdk-8u171-linux-x64.rpm 执行如下指令： 1[root@localhost Dockerfile]# docker build -t centos/jdk . 运行结果如下： docker images可以看到新生成的centos/jdk镜像。 容器操作指令1.创建启动容器： [root@localhost ~]# docker run centos:7 /bin/echo&apos;hello world&apos; 容器运行完后直接退出2.交互形式创建启动容器 [root@localhost ~]# docker run -it centos:7 /bin/bash [root@802e3623e566 /]# ps PID TTY TIME CMD 1 ? 00:00:00 bash 13 ? 00:00:00 ps [root@802e3623e566 /]# exit执行exit才能退出容器 3.守护状态运行容器 [root@localhost ~]# docker run -d centos:7 /bin/sh -c &quot;while true; do echo hello world; sleep 1; done&quot;4.启动已有的容器： docker start 容器ID 例： [root@localhost ~]# docker start 802e3623e5665.停止运行的容器： docker stop 容器ID 例： [root@localhost ~]# docker stop 802e3623e5666.删除容器： [root@localhost ~]# docker stop 89566e38c7fb [root@localhost ~]# docker rm 89566e38c7fb7.进入运行的容器： [root@localhost ~]# docker exec -it cbd8b1f35dcc /bin/bash8.导出容器： 导出容器cbd8b1f35dcc到centos_test.tar文件 [root@localhost ~]# docker export -o centos_test.tar cbd8b1f35dcc 导出的tar文件可以在其他机器上，通过导入来重新运行9.导入容器： 把导出的文件centos_test.tar通过docker import导入变成镜像 [root@localhost ~]# docker import centos_test.tar test/centos 通过docker images命令可以看到增加了个test/centos镜像","link":"/2018/06/29/Docker01全面认识Docker和基本指令/"},{"title":"开源组件:FastDFS集群搭建与实战","text":"FastDFS是一个轻量级的分布式文件系统，在实际生产环境往往以集群的形式部署，保证了服务的高可用。本文重点阐述FastDFS集群的搭建和项目实战。 工作流程上传流程图 下载流程图 基本概念可参考作者上篇文章：FastDFS极速入门 底层原理 FastDFS不会对文件进行分块存储，直接保存到Storage服务上，这也是不适合超大文件存储的原因，官方建议(4K~500M)，优点：简介高效。 FastDFS采用分组存储方式，同一组可以包括多个Storage Server，其中一个Storage接收到上传的文件，会同步文件到同组其他Storage Server。 一个组的存储容量为组内Storage Server容量最小的那个。优点：组内服务压力较大时可以增加Storage Server来缓解压力；系统容量不足时增加组来获得更大的存储空间。 文件上传成功返回的文件ID由组名，磁盘目录和文件名构成。 集群服务器规划 系统环境：centos 7.3 跟踪服务器1(Tracker)：192.168.72.135 跟踪服务器2(Tracker)：192.168.72.136 存储服务器1(Storage)：192.168.72.135—(group1) 存储服务器2(Storage)：192.168.72.136—(group1) 存储服务器3(Storage)：192.168.72.137—(group2) 由于电脑性能有限，但要模拟多group，只虚拟了3个节点，对group1做了两个节点来备份数据，group2为单节点，生产环境要每个组至少两个节点来保证高可用。 安装包 fastdfs-5.11.tar.gz fastdfs-nginx-module-master.zip libfastcommon-1.0.36.tar.gz nginx-1.8.1.tar.gz 集群部署Tracker和Storage部署 1：节点1，节2，节点3分别安装FastDFS，具体安装参考上篇文章：FastDFS极速入门 2：分别关闭三个节点的防火墙，或者配置防火墙开放端口，关闭防火墙: systemctl stop firewalld 3：修改节点1的tracker.conf配置文件： 123&gt;mkdir /data/fdfs-tracker&gt;vi /etc/fdfs/tracker.conf 把base_path修改为：base_path=/data/fdfs-tracker 4：修改节点2的tracker.conf配置文件：同上 5：修改节点1的storage.conf配置文件： 1234567891011121314151617&gt; mkdir /data/fdfs-storage/base&gt; mkdir /data/fdfs-storage/storage0&gt;vi /etc/fdfs/storage.conf把group_name修改为：group_name=group1把base_path修改为：base_path=/data/fdfs-storage/base把store_path0修改为：store_path0=/data/fdfs-storage/storage0把tracker_server修改两个tracker节点地址： tracker_server=192.168.72.135:22122 tracker_server=192.168.72.136:22122 6：修改节点2的storage.conf配置文件，同步骤5。 7：修改节点3的storage.conf配置文件， 把group_name修改为：group_name=group2 其他同步骤5。 8：节点1，节点2上启动tracker服务 service fdfs_trackerd start 9：节点1，节点2和节点3上启动storage服务 &gt;service fdfs_storaged startTracker和Storage安装完成，可以使用FastDFS自带的客户端进行上传下载测试，具体操作方法，参考上篇 fastdfs-nginx-module和nginx安装 所有节点安装fastdfs-nginx-module模块 fastdfs-nginx-module模块作用： 文件上传到组内一个storage存储后，storage服务会吧文件同步到组内其他storage，这就存在时间延时问题，如果此时客户端通过nginx访问到还未同步完成的组内其他storage会导致文件不存在无法访问错误，fastdfs-nginx-module可以解决该问题的发生，通过重定向到源storage节点来获取文件。 root目录解压fastdfs-nginx-module： unzip fastdfs-nginx-module.zip 安装依赖包： yum install gcc gcc-c++ make automake autoconf libtool pcre* zlib openssl openssl-devel 安装nginx tar -zxvf nginx-1.8.1.tar.gzcd nginx-1.8.1./configure –prefix=/opt/nginx –add-module=/roo/fastdfs-nginx-module/srcmake &amp;&amp; make install 复制fastdfs-nginx-module中配置文件到/etc/fdfs目录，并修改配置文件： cp /root/fastdfs-nginx-module/src/mod_fastdfs.conf /etc/fdfsvi /etc/fdfs/mod_fastdfs.conf tracker_server修改为： tracker_server=192.168.72.135:22122 tracker_server=192.168.72.136:22122 group_name修改为： 节点1：group_name=group1 节点2：group_name=group1 节点3：group_name=group2 url_have_group_name修改为： url_have_group_name = true 复制FastDFS部分配置文件到/etc/fdfs目录： cd /root/fastdfs-5.1/confcp http.conf mime.types /etc/fdfs/ 修改nginx.conf配置文件： 启动nginx： ./nginx -c conf/nginx.conf 到此FastDFS集群已经搭建完成，文件上传后可以通过任意storage节点上的nginx来获得文件 实战FastDFS提供了C，PHP和java客户端，选用java客户端来进行实战。 创建maven工程，pom.xml文件添加依赖： 12345&lt;dependency&gt; &lt;groupId&gt;net.oschina.zcx7878&lt;/groupId&gt; &lt;artifactId&gt;fastdfs-client-java&lt;/artifactId&gt; &lt;version&gt;1.27.0.0&lt;/version&gt;&lt;/dependency&gt; 添加配置文件 src/main/resoureces目录下添加fdfs_clent.conf配置文件，内容如下： 12345678connect_timeout = 60network_timeout = 60charset = UTF-8http.tracker_http_port = 8080http.anti_steal_token = no#tracker服务地址tracker_server = 192.168.72.135:22122tracker_server = 192.168.72.136:22122 创建FdfsClient类静态代码块： 12345678910111213141516171819202122 private static StorageClient1 storageClient1 = null; private static String trackerServerUrl = null; //初始化FastDFS Client static{ try{ ClientGlobal.init(&quot;src/main/resources/fdfs_client.conf&quot;); TrackerClient trackerClient = new TrackerClient(ClientGlobal.g_tracker_group); TrackerServer trackerServer = trackerClient.getConnection(); if (trackerServer == null){ System.out.println(&quot;getConnect return null&quot;); } trackerServerUrl = trackerServer.getInetSocketAddress().getHostString(); System.out.println(&quot;trackerServerUrl&quot; + trackerServerUrl); StorageServer storageServer = trackerClient.getStoreStorage(trackerServer); if (storageServer == null){ System.out.println(&quot;getStoreStorage return null&quot;); } storageClient1 = new StorageClient1(trackerServer,storageServer); }catch (Exception e){ e.printStackTrace(); } } 文件上传 1234567891011121314151617181920 public static String uploadFile(File file, String fileExt, Map&lt;String,String&gt; metaList) { try { byte[] buff = FileUtils.getFileByte(file); NameValuePair[] nameValuePairs = null; if (metaList != null) { nameValuePairs = new NameValuePair[metaList.size()]; int index = 0; for (Iterator&lt;Map.Entry&lt;String,String&gt;&gt; iterator = metaList.entrySet().iterator(); iterator.hasNext();) { Map.Entry&lt;String,String&gt; entry = iterator.next(); String name = entry.getKey(); String value = entry.getValue(); nameValuePairs[index++] = new NameValuePair(name,value); } } return &quot;http://&quot;+ trackerServerUrl + &quot;/&quot; + storageClient1.upload_file1(buff, fileExt, nameValuePairs); } catch (Exception e) { e.printStackTrace(); } return null; } 文件下载 12345678910111213141516171819 public static int downloadFile(String fileId, String filePath,String fileName) { FileOutputStream fos = null; try { byte[] content = storageClient1.download_file1(fileId); FileUtils.getFile(content, filePath, fileName); return 0; } catch (Exception e) { e.printStackTrace(); } finally { if (fos != null) { try { fos.close(); } catch (IOException e) { e.printStackTrace(); } } } return -1; } 获得文件属性 123456789101112131415 public static Map&lt;String,String&gt; getFileMetadata(String fileId) { try { NameValuePair[] metaList = storageClient1.get_metadata1(fileId); if (metaList != null) { HashMap&lt;String,String&gt; map = new HashMap&lt;String, String&gt;(); for (NameValuePair metaItem : metaList) { map.put(metaItem.getName(),metaItem.getValue()); } return map; } } catch (Exception e) { e.printStackTrace(); } return null; } 文件删除 12345678 public static int deleteFile(String fileId) { try { return storageClient1.delete_file1(fileId); } catch (Exception e) { e.printStackTrace(); } return -1; }","link":"/2018/06/20/开源组件02FastDFS集群搭建与实战/"},{"title":"windows和linux环境下使用google的glog日志库","text":"glog是google推出的一款轻量级c++开源日志框架，源码在github上，目前最新release版本是v0.3.5。 githut地址：https://github.com/google/glog，避免新版本踏坑，习惯性选用低版本v0.3.3。 一：生成windows库源码下载完成后，根目录下会有google-glog.sln工程文件呢，用visual studio打开会有四个项目，分别如下：1.libglog:生成动态库的源码2.libglog_static:生成静态库的源码3.libglog_unittest:测试动态库的源码工程4.libglog_unittest_static:测试静态库的源码工程 windows下使用动态库演示，编译libglog工程，生成”libglog.dll”和”libglog.lib”库文件 二：windows下使用glog库1.如你使用静态库，需要添加#define GOOGLE_GLOG_DLL_DECL，动态库不需要添加2.如你工程中添加了&lt;windows.h&gt;,直接编译会报如下错误： &quot;ERROR macro is defined. Define GLOG_NO_ABBREVIATED_SEVERITIES before including logging.h. See the document for detail.&quot; 解决办法：添加宏 &quot;#define GLOG_NO_ABBREVIATED_SEVERITIES&quot;，并且代码中的要使用google::GLOG_ERROR代替google::ERROR,google::GLOG_INFO代替google::INFO,google::GLOG_WARNING代替google::WARNING,google::GLOG_FATAL代替google::FATAL 原因：windows.h中定义的宏ERROR与glog中定义的宏ERROR冲突。测试代码如下： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950/********************************************************Copyright (C), 2016-2018,FileName: mainAuthor: woniu201Email: wangpengfei.201@163.comCreated: 2017/08/23Description: Glog使用Demo********************************************************/#include &lt;Windows.h&gt;#define GLOG_NO_ABBREVIATED_SEVERITIES#include &lt;iostream&gt;#include &lt;string&gt;#include &quot;glog/logging.h&quot; using namespace std;#pragma comment(lib, &quot;lib/libglog.lib&quot;) void main(){ //初始化参数 FLAGS_logtostderr = FALSE; //TRUE:标准输出,FALSE:文件输出 FLAGS_alsologtostderr = TRUE; //除了日志文件之外是否需要标准输出 FLAGS_colorlogtostderr = FALSE; //标准输出带颜色 FLAGS_logbufsecs = 0; //设置可以缓冲日志的最大秒数，0指实时输出 FLAGS_max_log_size = 10; //日志文件大小(单位：MB) FLAGS_stop_logging_if_full_disk = true; //磁盘满时是否记录到磁盘 //FLAGS_minloglevel = google::GLOG_INFO //glog初始化 google::InitGoogleLogging(&quot;mqttserver&quot;); google::SetLogDestination(google::GLOG_INFO,&quot;D:\\\\project\\\\vm\\\\test&quot;); while (1) { LOG(INFO)&lt;&lt;&quot;this is info log&quot; ; LOG(WARNING)&lt;&lt;&quot;this is warning log&quot;; LOG(ERROR)&lt;&lt;&quot;this is error log&quot;; //LOG(FATAL) &lt;&lt; &quot;this is fatal log&quot;; Sleep(1000); } //条件日志输出 int i = 4; LOG_IF(INFO, i == 4)&lt;&lt;&quot;if log&quot;; google::ShutdownGoogleLogging(); getchar(); return;} 运行输出结果如下： 三：生成linux库Linux版本使用的centos7.3，编译生成库 1. cd glog-0.3.3 2. ./configure 3. makemake完成后会在.lib下生成相应的库文件 四.Linux下使用glog库Linux使用静态库来测试，copy静态库libglog.a和src/glog的头文件到自己的工程目录，创建main.cpp文件，添加如下代码： 1234567891011121314151617181920212223242526272829/********************************************************Copyright (C), 2016-2018,FileName: mainAuthor: woniu201Email: wangpengfei.201@163.comCreated: 2017/08/23Description: Glog使用Demo********************************************************/#include &lt;stdio.h&gt;#include &quot;glog/logging.h&quot; int main(){ //初始化参数 FLAGS_logtostderr = FALSE; //TRUE:标准输出,FALSE:文件输出 FLAGS_alsologtostderr = TRUE; //除了日志文件之外是否需要标准输出 FLAGS_colorlogtostderr = FALSE; //标准输出带颜色 FLAGS_logbufsecs = 0; //设置可以缓冲日志的最大秒数，0指实时输出 FLAGS_max_log_size = 10; //日志文件大小(单位：MB) FLAGS_stop_logging_if_full_disk = true; //磁盘满时是否记录到磁盘 google::InitGoogleLogging(&quot;mqttserver&quot;); google::SetLogDestination(google::GLOG_INFO,&quot;./test&quot;); LOG(INFO) &lt;&lt; &quot;this is log&quot;; LOG(WARNING) &lt;&lt; &quot;this is warnning&quot;; LOG(ERROR) &lt;&lt; &quot;this is error&quot;; google::ShutdownGoogleLogging();} 编译：g++ main.cpp -o main -L. -lglog -lpthread 运行：./main 输出结果如下： 关注下面公众号，回复”102”获取windows源码 关注下面公众号，回复”103”获取linux源码","link":"/2017/08/23/Applied06windows和linux环境下使用google的glog日志库/"},{"title":"我的开源:股票软件简介+源码(蜗牛股票软件)","text":"蜗牛股票软件是博主在业余时间开发的一款股票软件，运行于Windows环境，目前已经开源到GitHub上，界面使用VC++/MFC开发，IDE选用Visual Studio 2010，后台使用java开发，使用微服务spring boot框架。 目前支持的功能如下： 1.自选股显示实时股票数据。 2.实时显示上证指数，深证成指，创业板指数据。 3.双击自选股自动查看K线数据。 4.查看K线数据，支持左右移动，上下缩放灵活查看K线天数。 5.K线中点击显示十字星线，精准查看数据。 6.K线下部显示成交量。 7.K线中显示5日，10日，20日均线。 8.K线下部显示MACD线，移动十字星线，实时更新MACD,DIF,DEA数据。 9.增加分时图(2017-10-06更新) 10.增加周K线和月K线(2017-11-18更新) 11.增加键盘精灵(2017-11-28更新) 12.BUG修复：解决分时线界面闪屏问题，解决JSON解析崩溃问题(2017-12-11更新)自选股界面 鼠标单击股票选中自选股，更新选中股票的底色。自动判断是否属于交易时间交易时间实时更新自选股中的数据。 底部区域显示上证指数，深圳成指，创业板指和当前时间。 K线界面 K线，5日，10日，20日均线区 十字星线选中当日数据展示区 成交量区 MACD指标区 分时图界面 开源地址蜗牛股票软件源码已经开源道GitHub上，地址：蜗牛股票软件源码 欢迎大家一起开发，一起技术交流或加我QQ：731342182 进一步交流，如有不足请指出，如对您有帮助请在GitHub上给我加星。 本博客未完，后续新加功能持续更新 (最近更新2017-12-11，BUG修复分时闪屏，JSON解析崩溃)","link":"/2017/08/11/开源01股票软件简介源码(蜗牛股票软件)/"},{"title":"Qt:vs2017+qt5.x编译32位应用","text":"最近有同学私信我，问如何使用vs2017+qt5.10编译出32位的应用，需要使用msvc2017_x86的插件，然而qt官网并没有提供，只能使用源码编译生成msvc2017_x86插件，使用nmake进行编译，经尝试是个漫长的过程我的机子性能不错，差不多用了4h，很多小伙伴估计也没这耐心，即使编译完成在使用的时候还发现了qt的bug，编译报错“constexpr函数不会生成常数表达式”，这个bug官网已经解决了，我把编译好解决完bug整理的插件直接打包放到网盘里了，大家直接下载配置使用就可以了。 使用1.下载msvc2017_x86插件： 关注底部公众号，回复110获得下载链接2.解压到你安装Qt SDK的目录下： 3.打开vs2017 4.配置msvc2017_x86路径 5.选择msvc2017_x86 6.设置项目","link":"/2019/05/14/Qt10vs2017+qt5.x编译32位应用/"},{"title":"Qt:菜单栏，工具栏和状态栏","text":"菜单栏，工具栏，状态栏应用中经常见到，下图解释一目了然，实际开发中 两种方式来实现，一种是使用纯代码QMenuBar，QToolBar，QStatusBar来设计开发，另一种使用Qt Designer通过拖拽的形式来实现，减少了大量的代码，使用简单。 菜单栏1.新建项目UI基类选择QMainWindow。 2.双击在这里输入，可修改一级菜单的名称。 3.动作编辑器里添加actionOpen，actionSave两个动作 4.鼠标左键拖拽action到文件下的二级菜单即可，同时打开和保存之间可以添加分隔符 5.头文件中添加槽 123private slots: void OnOpenFile(); void OnSaveFile(); 6.源文件实现槽函数 123456789101112131415161718192021/************************************@ Brief: 打开文件@ Author: 红烧肉 @ Created: 2019/04/22@ Return: ************************************/void MenuDialog::OnOpenFile(){ QMessageBox::information(this, &quot;提示&quot;, &quot;点击了打开Action&quot;, QMessageBox::Yes);} /************************************@ Brief: 保存文件@ Author: 红烧肉@ Created: 2019/04/22@ Return:************************************/void MenuDialog::OnSaveFile(){ QMessageBox::information(this, &quot;提示&quot;, &quot;点击保存Action！&quot;, QMessageBox::Yes)} 7.构造函数里连接信号与槽 connect(ui.actionOpen, &amp;QAction::triggered, this, &amp;MenuDialog::OnOpenFile); connect(ui.actionSave, &amp;QAction::triggered, this, &amp;MenuDialog::OnSaveFile);工具栏菜单下方的区域就是用来存放工具栏。 添加工具栏更简单，直接拖拽acitonOpen，actionSave到该区域即可 常用方法： 12345void setMovable(bool movable)：设置工具栏区域是否可移动void setAllowedAreas(Qt::ToolBarAreas areas)：设置工具栏可移动的范围void setToolButtonStyle(Qt::ToolButtonStyle toolButtonStyle)：设置工具栏按钮的风格，如纯图标，文字，文字图标都有等 状态栏 常用方法 1234567void addWidget(QWidget *widget, int stretch = 0)：状态栏左侧添加一个widget。对widget的拉伸系数为0。void addPermanentWidget(QWidget *widget, int stretch = 0)：状态栏右侧添加一个widget。void setSizeGripEnabled(bool)：设置右下角拖动缩放的控制点。void showMessage(const QString &amp;message, int timeout = 0)：留言显示，过期时间为 timeout。 示例代码： 1234567statusBar()-&gt;addWidget(new QLabel(&quot;label1&quot;));statusBar()-&gt;addWidget(new QLabel(&quot;label2&quot;));statusBar()-&gt;addPermanentWidget(new QLabel(&quot;label3&quot;));statusBar()-&gt;addPermanentWidget(new QLabel(&quot;label4&quot;));statusBar()-&gt;showMessage(&quot;留言&quot;, 5000);statusBar()-&gt;setSizeGripEnabled(false); //不显示右下角拖放控制点statusBar()-&gt;setStyleSheet(QString(&quot;QStatusBar::item{border: 0px}&quot;)); // QSS不显示label的边框","link":"/2019/05/09/Qt09菜单栏工具栏/"},{"title":"Qt:QTime类","text":"QTime类为用户提供一系列时间的函数，封装的很全面，几乎满足了各种时间的需求。 常用方法介绍1.QTime addMSecs(int ms) const 当前时间增加毫秒，ms可为负2.QTime addSecs(int s) const 当前时间增加秒，s可为负3.int elapsed() const 返回自上次调用start()或restart()以来经过的毫秒数。4.int hour() const 返回小时数5.int minute() const 返回分钟数6.second() const 返回秒数7.int msec() const 返回毫秒数8.bool isNull() const 如果时间为空返回true9.bool isValid() const 判断当前时间对象是否有效，比如H的范围是0~23，M和S的范围是0~5910.int msecsSinceStartOfDay() const 返回从一天开始的秒数，即从00:00:00开始的秒数。11.int secsTo(const QTime &amp;t) const 返回从当前时间到t的秒数。如果t比这个时间早，返回的毫秒数为负。12.int msecsTo(const QTime &amp;t) const 返回从当前时间到t的毫秒数。如果t比这个时间早，返回的毫秒数为负。13.int restart()int 将此时间设置为当前时间，并返回自上次调用start()或restart()以来经过的毫秒数。14.bool setHMS(int h, int m, int s, int ms = 0) 将时间设置为小时h、分钟m、秒s和毫秒ms。15.void start() 将当前系统时间记录为当前时间16.QString toString(const QString &amp;format) const 将时间转化为特定的字符串格式17.QString toString(Qt::DateFormat format = Qt::TextDate) const 按照Qt::DateFormat的格式转化18.QTime currentTime() 获得系统当前时间19.QTime fromString(const QString &amp;string, Qt::DateFormat format = Qt::TextDate) 从Qt::DateFormat转化为QTime对象20.QTime fromString(const QString &amp;string, const QString &amp;format) 从特定的字符串格式转化为QTime对象时间字符串格式h:没有补零的小时(如果AM/PM显示，则为0到23或1到12) hh:位数不够需要补零的小时(00至23或01至12，如果是AM/PM显示) m:没有补零的分钟(0到59) mm:位数不够需要补零的分钟(00到59) s:没有补零的秒(0到59) ss:位数不够需要补零的秒(00到59) z:没有补零的毫秒(0到999) zzz:位数不够需要补零的毫秒(000到999) ap/AP:上午/下午，ap为am或pm，AP为AM或PM 例： hh:mm:ss.zzz 08:18:68.138 h:m:s ap 8:18:68 am","link":"/2019/04/23/Qt08QTime类/"},{"title":"Qt:QDate类","text":"QDate为开发者提供日期的类，函数也很丰富 常用方法介绍1.QDate addDays(qint64 ndays) const 当前日期添加n天，n可以为负2.QDate addMonths(int nmonths) const 当前日期添加n月，n可以为负3.QDate addYears(int nyears) const 当前日期添加n年，n可以为负4.int day() const 返回所处月的天数(1到31)5.int month() const 返回日期的月数6.int year() const 返回日期的年数7.int dayOfWeek() const 返回周几(1到7),0表示日期无效8.int dayOfYear() const 返回所处年的天数(1~365/366)9.int daysInMonth() const 返回当前月共多少天(28~31)10.int daysInYear() const 返回当前年共多少天(365/366)11.qint64 daysTo(const QDate &amp;d) const 返回当前日期到d的天数，可为负12.void getDate(int *year, int *month, int *day) const 提取日期的年、月和日，并将它们分配给*年、*月和*日。指针可以为空。13.bool isNull() const 判断日期对象是否为NULL14.bool isValid() const 判断日期对象是否有效，如月的范围(1~12)，不在此范围为无效日期15.bool setDate(int year, int month, int day) 设置日期16.QDate static currentDate() 获得当前日期17.bool static isLeapYear(int year) 判断year是否为闰年18.QString toString(const QString &amp;format) const 按照format格式转换成日期QString19.QDate static fromString(const QString &amp; string, const QString &amp; format) 按照规则生成QDate时间格式显示d 一位表示天数(1到31) dd 两位表示天数(01到31) ddd 英文简写表示(‘Mon’ to ‘Sun’) dddd 英文全写表示( ‘Monday’ to ‘Sunday’) M 一位表示月数(1到12) MM 两位表示月数(01到12) MMM 英文简写表示 (‘Jan’ to ‘Dec’) MMMM 英文全写表示 ( ‘January’ to ‘December’) yy 两位表示年数(00 to 99) yyyy 年数用四位数表示，如年为负数，则在前面加上一个负号 例： dd.MM.yyyy 21.08.2016 ddd MMMM d yy Sun July 20 69 &apos;The day is&apos; dddd The day is Sunday","link":"/2019/04/23/Qt07QDate类/"},{"title":"Qt:常用控件QSpinBox和QDoubleSpinBox","text":"QSpinBox可用于显示和输入整数，并可以在显示框中添加前缀或后缀。 QDoubleSpinBox可用于显示和输入小数，并可以在显示框中添加前缀和后缀。 QSpinBox和QDoubleSpinBox都是QAbstractSpinBox的子类，大多数属性相同。 头文件分别为：#include 和#include 常用方法：1.void setPrefix(const QString &amp;prefix) 设置前缀 2.void setSuffix(const QString &amp;suffix) 设置后缀 3.void setValue(int val) 设置初始值 4.void setSingleStep(int val) 设置步长 5.void setMaximum(int max) 设置最大值 6.void setMinimum(int min) 设置最小值 7.QString prefix() const 获得前缀 8.QString suffix() const 获得后缀 9.int singleStep() const 获得步长值 10.int value() const 获得当前值 常用信号：1.void valueChanged(int i) 值发生变化发出信号，带有当前值信息 2.void valueChanged(const QString &amp;text) 值发生变化发出信号，带有当前文本信息","link":"/2019/04/10/Qt05常用控件QSpinBox和QDoubleSpinBox/"},{"title":"Qt:常用控件QLineEdit","text":"QLineEdit是单行文本编辑控件。比如用户名，密码等输入框可以使用该控件。 所属头文件 常用方法1.void setText(const QString &amp;) 设置编辑框文本内容 2.void setReadOnly(bool) 控件设置为只读模式 3.void setPlaceholderText(const QString &amp;) 设置编辑框中的默认提示信息 4.void setMaxLength(int) 设置编辑中输入的最大长度 5.void setEchoMode(EchoMode) 设置编辑框的输入模式 QLineEdit::Normal：默认模式，输入与现实一致 QLineEdit::Password：密码模式，输入的内容用黑点代替，无法看到输入的内容 QLineEdit::PasswordEchoOnEdit：编辑时内容可现实，否则为密码模式 QLineEdit::NoEcho：输入不可见 6.void setAlignment(Qt::Alignment flag) 设置文本显示位置 Qt::AlignLeft：文本在左侧 Qt::AlignCenter：文本在居中 Qt::AlignRight：文本在右侧 7.void setClearButtonEnabled(bool enable) 添加清楚按钮 显示效果为： 8.void QLineEdit::setValidator(const QValidator *v) 对输入的内容进行限制 setValidator(0)：无限制 setValidator(new QIntValidator(this))：只能输入整数 常用信号 1.void textChanged(const QString &amp;text) 文本变化时发出信号 2.void returnPressed(); 光标在输入框，按回车键发出信号","link":"/2019/04/10/Qt04常用控件QLineEdit/"},{"title":"Qt:实现系统托盘，托盘菜单，托盘消息","text":"系统托盘就是在系统桌面底部特定的区域显示运行的程序。windows在任务栏状态区域，linux在布告栏区域。应用程序系统托盘功能，是比较普遍的功能，本篇将详细的介绍如何实现该功能。 演示Demo实现功能： 1.应用启动后，任务栏，系统托盘可以看到该程序。 2.点击右上角×关闭窗口，自动隐藏窗口，托盘可以看到该程序。 3.鼠标在托盘图标上右键，弹出&quot;退出程序&quot;菜单栏，并带有图标。步骤：1.工程中新建TrayDialog类，基类是QDialog，在界面上添加Text Browser控件和提示信息。 2.在TrayDialog.h头文件中添加#include 包含文件 3.添加成员变量 QSystemTrayIcon m_systray， 信号槽响应函数 int OnSystemTrayClicked(QSystemTrayIcon::ActivationReason reason); int OnExit(); 重写closeEvent(QCloseEvent *event)函数，完整代码如下：1234567891011121314151617181920212223242526#pragma once#pragma execution_character_set(&quot;utf-8&quot;) #include &lt;QDialog&gt;#include &lt;QtWidgets&gt;#include &quot;ui_TrayDialog.h&quot; class TrayDialog : public QDialog{ Q_OBJECT public: TrayDialog(QWidget *parent = Q_NULLPTR); ~TrayDialog(); private: void closeEvent(QCloseEvent *event); private slots: int OnSystemTrayClicked(QSystemTrayIcon::ActivationReason reason); int OnExit(); private: Ui::TrayDialog ui; QSystemTrayIcon m_systray;}; 4.在Qt Designer中添加Action，用于托盘右键退出程序。 5.构造函数TrayDialog(QWidget *parent)中添加如下代码： //设置提示文字 m_systray.setToolTip(“系统托盘演示程序”); // 设置托盘图标 m_systray.setIcon(QIcon(&quot;:/qtlearn/Resources/EXE.ico&quot;)); //托盘菜单项 QMenu * menu = new QMenu(); menu-&gt;addAction(ui.actionExit); m_systray.setContextMenu(menu); // 关联托盘事件 connect(&amp;m_systray, SIGNAL(activated(QSystemTrayIcon::ActivationReason)), this, SLOT(OnSystemTrayClicked(QSystemTrayIcon::ActivationReason))); //显示托盘 m_systray.show(); //托盘菜单响应 connect(ui.actionExit, SIGNAL(triggered()), this, SLOT(OnExit()));6.关闭窗口事件响应函数 1234567891011/************************************@ Brief: 点击关闭窗口@ Author: woniu201 @ Created: 2019/03/21@ Return: ************************************/void TrayDialog::closeEvent(QCloseEvent *event){ this-&gt;hide(); event-&gt;ignore();} 7.双击/单击托盘应用程序响应函数 12345678910111213141516/************************************@ Brief: 双击/单击托盘事件@ Author: woniu201@ Created: 2019/03/21@ Return:************************************/int TrayDialog::OnSystemTrayClicked(QSystemTrayIcon::ActivationReason reason){ if (reason == QSystemTrayIcon::Trigger || reason == QSystemTrayIcon::DoubleClick) { // 显示主窗口 this-&gt;showNormal(); } return 0;} 8.托盘右键退出响应函数 1234567891011/************************************@ Brief: 托盘菜单退出@ Author: woniu201 @ Created: 2019/03/21@ Return: ************************************/int TrayDialog::OnExit(){ QApplication::exit(0); return 0;} 9.启动后效果如下","link":"/2019/04/06/Qt03实现系统托盘/"},{"title":"数据结构与算法:二叉树的创建，插入，遍历，删除实现","text":"二叉树是每个结点最多有两个子树的树结构。使用广泛，使用C来实现对二叉树的操作。 示例：代码实现构造如下二叉树 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233#include &lt;iostream&gt; using namespace std; typedef struct BinaryTree{ int data; struct BinaryTree* lchild; struct BinaryTree* rchild;}BiTNode; /************************************@ Brief: 二叉树中插入节点@ Author: woniu201 @ Created: 2019/07/10@ Return: ************************************/void insertNode(BiTNode** node, int val){ BiTNode* tmpNode = NULL; if (!(* node)) { tmpNode = (BiTNode*)malloc(sizeof(BiTNode)); memset(tmpNode, 0, sizeof(BiTNode)); tmpNode-&gt;data = val; *node = tmpNode; return; } if (val &lt; (*node)-&gt;data) { insertNode(&amp;(*node)-&gt;lchild, val); } else if (val &gt; (*node)-&gt;data) { insertNode(&amp;(*node)-&gt;rchild, val); } return;} /************************************@ Brief: 删除节点@ Author: woniu201@ Created: 2019/07/10@ Return: 参考：https://blog.csdn.net/Future_LL/article/details/79968437************************************/void delNode(BiTNode* node, int val){ BiTNode *L, *LL; //在删除左右子树都有的结点时使用； BiTNode *p = node; BiTNode *parent = node; int child = 0; //0表示左子树，1表示右子树； if (!node) //如果排序树为空，则退出； { return; } while (p) //二叉排序树有效； { if (p-&gt;data == val) { if (!p-&gt;lchild &amp;&amp; !p-&gt;rchild) //叶结点(左右子树都为空)； { if (p == node) //被删除的结点只有根结点； free(p); else if (child == 0) { parent-&gt;lchild = NULL; //设置父结点左子树为空； free(p); //释放结点空间； } else //父结点为右子树； { parent-&gt;rchild = NULL; //设置父结点右子树为空； free(p); //释放结点空间； } } else if (!p-&gt;lchild) //左子树为空，右子树不为空； { if (child == 0) //是父结点的左子树； parent-&gt;lchild = p-&gt;rchild; else //是父结点的右子树； parent-&gt;rchild = p-&gt;rchild; free(p); //释放被删除的结点； } else if (!p-&gt;rchild) //右子树为空，左子树不为空； { if (child == 0) //是父结点的左子树； parent-&gt;lchild = p-&gt;lchild; else //是父结点的右子树； parent-&gt;rchild = p-&gt;lchild; free(p); //释放被删除的结点； } else { LL = p; //保存左子树的结点； L = p-&gt;rchild; //从当前结点的右子树进行查找； if (L-&gt;lchild) //左子树不为空； { LL = L; L = L-&gt;lchild; //查找左子树； p-&gt;data = L-&gt;data; //将左子树的数据保存到被删除结点； LL-&gt;lchild = L-&gt;lchild; //设置父结点的左子树指针为空； for (; L-&gt;lchild; L = L-&gt;lchild); L-&gt;lchild = p-&gt;lchild; p-&gt;lchild = NULL; } else { p-&gt;data = L-&gt;data; LL-&gt;rchild = L-&gt;rchild; } } p = NULL; } else if (val &lt; p-&gt;data) //需删除记录的关键字小于结点的数据； { //要删除的结点p是parent的左子树； child = 0; //标记在当前结点左子树； parent = p;//保存当前结点作为父结点； p = p-&gt;lchild; //查找左子树； } else //需删除记录的关键字大于结点的数据； { //要删除的结点p是parent的右子树； child = 1; //标记在当前结点右子树查找； parent = p; //保存当前结点作为父结点； p = p-&gt;rchild; //查找右子树； } } return;} /************************************@ Brief: 删除树@ Author: woniu201 @ Created: 2019/07/10@ Return: ************************************/void delTree(BiTNode* node){ if (node) { delTree(node-&gt;lchild); delTree(node-&gt;rchild); free(node); node = NULL; }} /************************************@ Brief: 前序遍历@ Author: woniu201 @ Created: 2019/07/10@ Return: ************************************/void proorder(BiTNode* node){ if (node) { printf(&quot;%d &quot;, node-&gt;data); proorder(node-&gt;lchild); proorder(node-&gt;rchild); }} /************************************@ Brief: 中序遍历@ Author: woniu201 @ Created: 2019/07/10@ Return: ************************************/void inorder(BiTNode* node){ if (node) { inorder(node-&gt;lchild); printf(&quot;%d &quot;, node-&gt;data); inorder(node-&gt;rchild); }} /************************************@ Brief: 后序遍历@ Author: woniu201 @ Created: 2019/07/10@ Return: ************************************/void postorder(BiTNode* node){ if (node) { postorder(node-&gt;lchild); postorder(node-&gt;rchild); printf(&quot;%d &quot;, node-&gt;data); }} int main(){ BiTNode* node = NULL; insertNode(&amp;node, 10); insertNode(&amp;node, 15); insertNode(&amp;node, 8); insertNode(&amp;node, 9); insertNode(&amp;node, 17); insertNode(&amp;node, 6); insertNode(&amp;node, 11); //前序遍历 printf(&quot;先序遍历：\\n&quot;); proorder(node); //中序遍历 printf(&quot;\\n中序遍历：\\n&quot;); inorder(node); //后序遍历 printf(&quot;\\n后序遍历：\\n&quot;); postorder(node); //删除节点 delNode(node, 15); //删除树 delTree(node); return 1;}","link":"/2019/04/05/DSA04二叉树创建插入删除实现/"},{"title":"数据结构与算法:两分钟初识树","text":"一：树的定义树是一种数据结构，由n(n&gt;1)个有限结点组成一个有层次关系的集合。形状像一颗倒立的树而得名。分为：无序树，有序树，二叉树，满二叉树，完全二叉树，平衡二叉树（AVL），二叉查找树（二叉搜索树、BST），霍夫曼树，红黑树，B-tree（B-树或者B树），B+树，B*树等。 节点结构体(C/C++)表示为： 123456typedef struct treeNode{ void *val; //数据项，任意类型 struct treeNode *left; //左子节点指针 struct treeNode *right; //右子节点指针}node; 节点类(Java)表示为： 12345public class TreeNode { private Object data; //数据项 private TreeNode leftChild; //左子节点的引用 private TreeNode rightChild; //右子节点的引用} 二：树的特点1.根节点没有父节点。 2.每个非根节点只有一个父节点。 3.每个节点有零个或多个子节点。 三：相关术语1.节点的度：节点含有子树的个数 2.叶子节点：节点的度为0。 3.子节点：一个节点含有的子树的根节点称为该节点的子节点。(这句有点绕口，举例：上图a,b,c是R的子节点) 4.父节点：含有子节点的节点，成为子节点的父节点。 5.兄弟节点：父节点相同的节点。 6.堂兄弟节点：父节点为兄弟节点的节点。 7.树的度：最大的节点的度称为树的度 8.树的高度或深度：树种节点的最大层次。 9.森林：n(n&gt;=0)颗互不相交树的集合。 四：树的遍历 1.前序遍历 遍历顺序：访问根节点—&gt;遍历左子树—&gt;遍历右子树 2.中序遍历 遍历顺序：遍历左子树—&gt;访问根节点—&gt;遍历右子树 3.后序遍历 遍历顺序：遍历左子树—&gt;遍历右子树—&gt;访问根节点","link":"/2019/04/04/DSA03二分钟初识树/"},{"title":"两分钟搞懂开源许可协议","text":"License是软件的授权许可，规定了获得代码后拥有的权利，比如代码是否可用于商业领域，如用到商业领域是否声明版权等信息。 世界上的开源许可证（Open Source License）有上百个，我们在浏览github时候经常见的有：GPL,BSD,MIT,Mozilla，Apache等，据github官方公布数据显示，托管在github上项目使用的最多开源协议是MIT，这些究竟有什么区别呢，直接看介绍会让你晕头转向，小编在查阅资料发现一张图，一目了然，这是国外程序员Paul Bagwell画的，国内大牛阮一峰对这张图进行了翻译，只需两分钟时间彻底搞明白这些复杂的Open Source License，从而选择适合自己的开源协议。 参考： 1.阮一峰的网络日志","link":"/2019/04/02/开源组件两分钟搞懂开源许可协议/"},{"title":"Qt:第一个Qt程序Hello World","text":"一：说在前头我的第一份工作是做生产工具，当时用的MFC，IDE是VC6.0，现在想想真是古董级别，10年至今，微软也一直没有对MFC进行升级，冥冥中感觉微软自己都放弃MFC了，市场上貌似MFC的岗位越来越少了，基本上也都是原先的项目维护，qt已经成为新的客户端开发的趋势，顺者昌，逆者亡，无奈只能放弃MFC转投Qt了，Qt实现了跨平台功能，一套代码可以在windows，linux，mac上运行，大大节省了开发者平台移植工作量，Qt号称要做出像网页一样漂亮的界面，小编会出一系列的Qt开发的文章。 Qt开发，IDE可以用QtCreator也可以用visual studio+qt插件，选个用的最习惯的即可，也可以和我一样喜欢新事物，用原生的Qt Creator来进行演示。 实现功能： 启动程序，点击界面上的按钮提示Hello World，并使用windeployqt来打包发布程序。 二：步骤1.启动Qt Creator，启动后的界面如下 2.点击文件下的新建文件或项目 3.选择Application-Qt Widgets Application功能 4.设置工程名称和项目路径，然后点击下一步，下一步 5.自动生成的代码，目录如下： 6.双击mainwindow.ui，会出现界面编辑框，通过拖拽的方式在界面添加，PushButton和Lable控件，变量名分别为btnHello,lable 7.鼠标放到PushButton按钮，点击右键选择”转到槽”，在弹出界面上选择”clicked()”信号，点击”OK” 8.在Button响应函数添加如下代码。 1234void MainWindow::on_btnHello_clicked(){ ui-&gt;label-&gt;setText(&quot;Hello World!&quot;);} 9.点击编译运行按钮，运行结果如下 三：打包发布1.编译生成的Release版本，直接双击运行会提升缺少dll库 2.在c盘新建一文件夹，把01-helloworld.exe放入该文件夹，执行打包工具，运行打包指令 windeployqt c:\\qt\\01-helloworld.exe 3.这时文件夹下回添加该exe所依赖的dll库","link":"/2019/03/21/Qt01第一个Qt程序Hello World/"},{"title":"Qt:更改应用程序图标和任务栏图标","text":"实际开发过程中，生成的应用文件不会用默认的图标，同时程序启动后任务栏的图标也需要修改，还有窗口的图标，这样显得程序不那么low。更改程序的图标有多种方式，基于Qt Creator或vs开发的方式有区别，任务栏图标和窗口图标，只需加入一段代码即可实现，本文开发环境是qt5.9.7+vs2017。如有MFC开发经验，对于更改程序图标来说基本类似。 更改程序图标1.把下载好的图标EXE.ico文件放到Resources文件夹下 2.右键–》添加–》新建项，选择资源文件，新建资源文件*.rc 3.打开资源视图，右键–》添加资源–》选择Icon–》导入EXE.icon视图 4.重新编译工程，这是生成的应用程序文件，将会有图标 更改任务栏图标任务栏图标默认情况如下： 修改任务栏图标相比更简单些。 1.在Qt Designer添加资源文件 2.在程序主函数入口添加如下代码 QApplication a(argc, argv); //更改程序启动后任务栏图标 a.setWindowIcon(QIcon(&quot;:/qtlearn/Resources/EXE.ico&quot;)); 3.编译启动后任务栏图标生效","link":"/2019/03/21/Qt02更改应用程序图标和任务栏图标/"},{"title":"开源组件:Git分支管理","text":"1.创建分支 a.直接创建 git branch dev(分支名) b.基于某个历史版本创建分支 git branch dev HEAD 2.查看分支 git branch -av3.删除分支 git branch -d dev(分支名)4.切换分支 git checkout dev5.查看分支差异 a.查看分支差异 git diff dev master b.查看分支指定文件差异 git diff dev master -- index6.本地仓库推送到远端仓库 a.Git代码托管平台创建仓库 http地址：https://gitee.com/woniu201/git-test.git b.本地仓库与远端仓库关联 git remote add origin https://gitee.com/woniu201/git-test.git c.如果远端仓库是空的 git push -u origin master 一般远端仓库都会有readme文件，解决方案 git pull --rebase origin master d.提交到远程仓库 git push origin master7.拉取远程分支 a.拉取远程分支,默认拉取主分支 git clone https://gitee.com/woniu201/git-test.git b.拉取远程指定分支 git clone -b dev https://gitee.com/woniu201/git-test.git c.拉取主分支后，基于远端指定分支本次创建新分支 git branch -av 红色部分代表远端分支 git branch dev origin/dev 基于远端的dev分支本次创建dev分支","link":"/2019/01/08/开源组件04Git分支管理/"},{"title":"开源组件:Git简介与基本操作","text":"一：简介GIT是一个开源的分布式的版本控制系统，是由Linus 为了管理Linux内核开发而开发的一个开源的版本控制软件。相比SVN，它采用分布式版本库方式。 二：工作区，暂存区和版本库 左侧为工作区，编辑文件所在的目录，右侧为版本库，其中index区域是暂存区，标记为”master”代表master主分支。 三：基本操作指令1.创建仓库 a.当前目录创建仓库 git initb.指定目录创建仓库 git init 目录名2.设置配置 a.全局配置 git config --global user.name woniu git config --global user.email woniu@163.com b.设置本地仓库配置 git config --local user.name woniu git config --local user.email woniu@163.com c.查看配置信息 git config --global --list3.工作区文件新增到暂存区 a.提交指定文件 git add a.cpp b.提交当前目录所有文件 git add . c.把提交过暂存区，已经发生改变的文件再次提交到暂存区 git add -u4.暂存区文件提交到版本库 git commit -m &quot;初始版本&quot;5.查看git提交日志 a.全部日志 git log b.简化日志 git log --oneline c.查看前5个日志 git log -n5 --oneline d.查看所有日志 git log --all e.图像化查看所有日志 git log --all --graph f.图形化界面查看 gitk6.查看上次提交后是否有修改 git status7.查看差异 a.查看工作区与暂存区差异 git diff b.查看暂存区与仓库之间的差异 git diff --cached c.比较不同commit的差异 git diff HEAD1 HEAD28.清空暂存区，工作区修改 git reset --hard9.删除工作区和暂存区文件 git rm 文件名10.重命名文件 git mv a.cpp b.cpp11.版本回滚 a.恢复暂存区和HEAD一致 git reset HEAD b.恢复暂存区指定文件与HEAD一致 git reset HEAD -- 文件名 c.恢复工作区与暂存区一致 git checkout -- 文件名 d.回退到指定commit，会清楚之后提交的commit git reset --hard HEAD","link":"/2019/01/08/开源组件03Git简介与基本操作/"},{"title":"C++操作文件行(读取，删除，修改指定行)","text":"纯C++实现对文件行的增删改查 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140/********************************************************Copyright (C), 2016-2018,FileName: mainAuthor: woniu201Email: wangpengfei.201@163.comCreated: 2018/08/31Description: 文件操作：读取指定行，删除指定行，修改指定行********************************************************/#include &lt;iostream&gt;#include &lt;fstream&gt;#include &lt;string&gt;using namespace std; /************************************@ Brief: 读取指定行数据@ Author: woniu201 @ Created: 2018/08/31@ Return: ************************************/void ReadLineData(char* fileName, int lineNum, char* data){ ifstream in; in.open(fileName); int line = 1; while (in.getline(data, 1024)) { if (lineNum == line) { break; } line ++ ; } in.close();} /************************************@ Brief: 字符串转string类型@ Author: woniu201 @ Created: 2018/08/31@ Return: ************************************/string CharToStr(char * contentChar){ string tempStr; for (int i=0;contentChar[i]!=&apos;\\0&apos;;i++) { tempStr+=contentChar[i]; } return tempStr;} /************************************@ Brief: 删除指定行@ Author: woniu201 @ Created: 2018/08/31@ Return: ************************************/void DelLineData(char* fileName, int lineNum){ ifstream in; in.open(fileName); string strFileData = &quot;&quot;; int line = 1; char lineData[1024] = {0}; while(in.getline(lineData, sizeof(lineData))) { if (line == lineNum) { strFileData += &quot;\\n&quot;; } else { strFileData += CharToStr(lineData); strFileData += &quot;\\n&quot;; } line++; } in.close(); //写入文件 ofstream out; out.open(fileName); out.flush(); out&lt;&lt;strFileData; out.close();} /************************************@ Brief: 修改行数据@ Author: woniu201 @ Created: 2018/08/31@ Return: ************************************/void ModifyLineData(char* fileName, int lineNum, char* lineData){ ifstream in; in.open(fileName); string strFileData = &quot;&quot;; int line = 1; char tmpLineData[1024] = {0}; while(in.getline(tmpLineData, sizeof(tmpLineData))) { if (line == lineNum) { strFileData += CharToStr(lineData); strFileData += &quot;\\n&quot;; } else { strFileData += CharToStr(tmpLineData); strFileData += &quot;\\n&quot;; } line++; } in.close(); //写入文件 ofstream out; out.open(fileName); out.flush(); out&lt;&lt;strFileData; out.close();} int main(){ char lineData[1024] = {0}; ReadLineData(&quot;D:\\\\project\\\\cpp\\\\2010\\\\jsondemo\\\\jsondemo\\\\1.json&quot;, 21, lineData); cout &lt;&lt; lineData &lt;&lt; endl; DelLineData(&quot;D:\\\\project\\\\cpp\\\\2010\\\\jsondemo\\\\jsondemo\\\\1.json&quot;, 10); ModifyLineData(&quot;D:\\\\project\\\\cpp\\\\2010\\\\jsondemo\\\\jsondemo\\\\1.json&quot;, 10, &quot;aaaaaaaaaaaaaa&quot;); getchar();}","link":"/2018/11/16/Applied04C++操作文件行(读取，删除，修改指定行)/"},{"title":"纯C++实现操作配置文件(告别跨平台问题)","text":"项目中经常用到操作配置文件，考虑到跨平台问题，使用纯C++来实现操作配置文件。 CConfig.h 123456789101112131415161718192021222324252627282930313233343536#ifndef _CCONFIG_H#define _CCONFIG_H#include &lt;iostream&gt;#include &lt;string&gt;#include &lt;fstream&gt;#include &lt;vector&gt; using namespace std; class CConfig{public: CConfig(); ~CConfig(); void SetFilePath(const string &amp;filePath); string GetFilePath(); bool GetValue(const string &amp;section, const string &amp;key, string &amp;value, string &amp;error); bool ModifyValue(const string &amp;section, const string &amp;key, const string &amp;value, string &amp;error); private: bool OpenFile(); bool FindSection(const string &amp;sectionName); bool FindKey(const string &amp;key); bool OpenFileRead(); bool OpenFileWrite(); bool SetValue(const string &amp;key, const string &amp;value); void WriteFile(vector&lt;string&gt; &amp;vContent); string m_filePath; fstream m_fout; fstream m_fin; string m_content; string m_value; string m_error;};#endif CConfig.cpp 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316/********************************************************Copyright (C), 2016-2018,FileName: CConfigAuthor: woniu201Created: 2018/11/16Description: 纯C++实现配置文件的操作********************************************************/#include &quot;CConfig.h&quot; CConfig::CConfig(){ } CConfig::~CConfig(){ } /************************************@ Brief: 设置配置文件路径@ Author: woniu201@ Created: 2018/12/21@ Return:************************************/void CConfig::SetFilePath(const string &amp;filePath){ m_filePath = filePath;} /************************************@ Brief: 读取配置文件路径@ Author: woniu201@ Created: 2018/12/21@ Return:************************************/string CConfig::GetFilePath(){ return this-&gt;m_filePath;} /************************************@ Brief: 打开配置文件@ Author: woniu201@ Created: 2018/12/21@ Return:************************************/bool CConfig::OpenFile(){ if (true == m_fin.is_open()) { m_fin.close(); } m_fin.open(m_filePath.c_str()); if (!m_fin.is_open()) { m_error = &quot;open file fail:&quot; + m_filePath; return false; } return true;} /************************************@ Brief: 找节名@ Author: woniu201@ Created: 2018/12/21@ Return:************************************/bool CConfig::FindSection(const string &amp;sectionName){ if (-1 != m_content.find(&apos;[&apos;)) { string sTemp = m_content.substr(m_content.find(&apos;[&apos;) + 1, m_content.find(&apos;]&apos;) - m_content.find(&apos;[&apos;) - 1); if (0 == strcmp(sTemp.c_str(), sectionName.c_str())) { return true; } else { return false; } } else { return false; }} /************************************@ Brief: 找键名@ Author: woniu201@ Created: 2018/12/21@ Return:************************************/bool CConfig::FindKey(const string &amp;key){ size_t iDelePlace = m_content.find((char)&apos;//&apos;, 0); size_t iFindEqual = m_content.find((char)&apos;=&apos;, 0); //被注释的行，或者是包含key但是已经被注视掉了，过滤 if ((-1 != iDelePlace &amp;&amp; iDelePlace &lt; iFindEqual) || (-1 != iDelePlace &amp;&amp; -1 == iFindEqual) || -1 == iFindEqual) { return false; } string sKey = m_content.substr(0, m_content.find(&apos;=&apos;)); if (0 == strcmp(sKey.c_str(), key.c_str())) { m_value = m_content.substr(m_content.find(&apos;=&apos;) + 1, m_content.length() - m_content.find(&apos;=&apos;) - 1); return true; } return false;} /************************************@ Brief: 读取节下Key对应的value值@ Author: woniu201@ Created: 2018/12/21@ Return:************************************/bool CConfig::GetValue(const string &amp;section, const string &amp;key, string &amp;value, string &amp;error){ m_error = &quot;&quot;; if (false == OpenFile()) { error = m_error; return false; } char str[4096] = { 0 }; bool bFindSection = false; while (m_fin.getline(str, sizeof(str))) { m_content = str; if (!bFindSection) { if (FindSection(section)) { bFindSection = true; } else { m_error = &quot;&quot;; m_error = &quot;节点&quot; + section + &quot;不存在&quot;; } } else { if (FindKey(key)) { m_fin.close(); m_error = &quot;&quot;; value = m_value; return true; } else { m_error = &quot;&quot;; m_error = &quot;键名&quot; + key + &quot;不存在&quot;; } } memset(str, 0, 4096); } error = m_error; m_fin.close(); return false;} /************************************@ Brief: 读的方式打开文件@ Author: woniu201@ Created: 2018/12/21@ Return:************************************/bool CConfig::OpenFileRead(){ m_fout.close(); //关闭后要在清空一下，否则下次打开会出错 m_fout.clear(); m_fout.open(m_filePath.c_str(), ios::in); if (!m_fout.is_open()) { m_error = &quot;open file fail:&quot; + m_filePath; return false; } return true;} /************************************@ Brief: 写的方式打开文件@ Author: woniu201@ Created: 2018/12/21@ Return:************************************/bool CConfig::OpenFileWrite(){ m_fout.close(); //关闭后要在清空一下，否则下次打开会出错 m_fout.clear(); m_fout.open(m_filePath.c_str(), ios::out | ios::trunc); if (!m_fout.is_open()) { m_error = &quot;can not open file &quot; + m_filePath; return false; } return true;} /************************************@ Brief: 找KEY，设置新值@ Author: woniu201@ Created: 2018/12/21@ Return:************************************/bool CConfig::SetValue(const string &amp;key, const string &amp;value){ size_t iDelePlace = m_content.find((char)&apos;//&apos;); size_t iFindEqual = m_content.find((char)&apos;=&apos;); //被注释的行，或者是包含key但是已经被注视掉了，过滤 if ((-1 != iDelePlace &amp;&amp; iDelePlace &lt; iFindEqual) || (-1 != iDelePlace &amp;&amp; -1 == iFindEqual) || -1 == iFindEqual) { return false; } string sKey = m_content.substr(0, m_content.find(&apos;=&apos;)); if (0 == strcmp(sKey.c_str(), key.c_str())) { m_content = m_content.substr(0, m_content.find(&apos;=&apos;) + 1) + value; return true; } return false;} /************************************@ Brief: 修改配置文件KEY对应的value@ Author: woniu201@ Created: 2018/12/21@ Return:************************************/bool CConfig::ModifyValue(const string &amp;section, const string &amp;key, const string &amp;value, string &amp;error){ m_error = &quot;&quot;; if (false == OpenFileRead()) { error = m_error; return false; } char str[4096] = { 0 }; vector&lt;string&gt; vContent; bool isModify = false; bool isFindSection = false; while ( (m_fout.getline(str, sizeof(str)))) { m_content = str; if (!isFindSection) { if (FindSection(section)) { isFindSection = true; } else { m_error = &quot;&quot;; m_error = &quot;节点&quot; + section + &quot;不存在&quot;; } } else { if (!isModify) { if (SetValue(key, value)) { isModify = true; } else { m_error = &quot;&quot;; m_error = &quot;键名&quot; + key + &quot;不存在&quot;; } } } vContent.push_back(m_content); m_content = &quot;&quot;; memset(str, 0, 4096); } error = m_error; WriteFile(vContent); m_fout.flush(); m_fout.close(); return isModify;} /************************************@ Brief: 写文件@ Author: woniu201@ Created: 2018/12/21@ Return:************************************/void CConfig::WriteFile(vector&lt;string&gt; &amp;vContent){ if (false == OpenFileWrite()) { m_fout.close(); return; } for (size_t iIndex = 0; iIndex &lt; vContent.size(); iIndex++) { m_fout &lt;&lt; vContent[iIndex] &lt;&lt; endl; } m_fout.close(); vector&lt;string&gt;().swap(vContent);} main.cpp 12345678910111213141516171819#include &quot;CConfig.h&quot; int main(){ CConfig config; config.SetFilePath(&quot;a.ini&quot;); string value = &quot;&quot;; string error = &quot;&quot;; config.GetValue(&quot;ServerUrl&quot;, &quot;PcName&quot;, value, error); cout &lt;&lt; value &lt;&lt; endl; cout &lt;&lt; error &lt;&lt; endl; error = &quot;&quot;; config.ModifyValue(&quot;ServerUrl&quot;, &quot;PcName&quot;, &quot;5.0&quot;, error); cout &lt;&lt; error &lt;&lt; endl; getchar();} 配置文件a.ini内容如下：","link":"/2018/11/16/Applied03纯C++实现操作配置文件(告别跨平台问题)/"},{"title":"【Docker】：docker安装ELK(logstash,elasticsearch,kibana)","text":"一：安装logstash1.拉取镜像 docker pull logstash:5.6.11 2.创建目录 mkdir /docker/logstash cd /docker/logstash3.创建配置文件 touch logstash.config 文件内容： input { udp { port =&gt; 8888 codec =&gt; json } } output { elasticsearch{ hosts =&gt; &quot;192.168.186.129:9200&quot; index =&gt; &quot;indextest&quot; } stdout{ codec =&gt; rubydebug } }4.创建，启动logstash容器 docker run -p 8888:8888/udp -d -v /docker/logstash:/config-dir logstash:5.6.11 -f /config-dir/logstash.conf二：安装elasticsearch1.拉取镜像 docker pull elasticsearch:5.6.112.创建数据目录 mkdir /docker/es &amp;&amp; mkdir /docker/es/data 3.创建ES容器并启动 docker run -d -p 9200:9200 -p 9300:9300 \\ -v /docker/es/data:/usr/share/elasticsearch/data \\ elasticsearch:5.6.114.测试 5.启动问题排查 默认启动ES分配2G内存，如提示内存不足，可进行修改find /var/lib/docker/overlay/ -name jvm.options 查到如下结果： /var/lib/docker/overlay2/1fb59070a037d02dccfc33e15d6e24cf9127882cc19521a1654192d3d3b1c7ec/diff/etc/logstash/jvm.options /var/lib/docker/overlay2/d2b9e8e913dff7c015cbb27b34ca4b9921bdd43869a1bfb1413af468cb14465e/diff/etc/elasticsearch/jvm.options /var/lib/docker/overlay2/dd2634a4b14f8ef455ae969466af25d147f508c0e9785bb3e7703eb933675ecf/merged/etc/logstash/jvm.options 修改elasticsearch/jvm.options把 -Xms2g 改为 -Xms512m -Xmx2g 改为 -Xmx512m 6.安装IK分词器 a.docker exec -it 容器ID b.elasticsearch-plugin install https://github.com/medcl/elasticsearch-analysis-ik/releases/download/v5.6.11/elasticsearch-analysis-ik-5.6.11.zip 重启容器加载IK分词器时候会保存，IK分词器下缺少配置文件，没搞明白为什么5.6.11安装的IK插件缺少了，宿主机下载了解压后Copy到容器中 docker cp ik/config 容器ID:/usr/share/elasticsearch/plugins/analysis-ik 重启容器测试安装的分词器： GET _analyze?pretty { &quot;analyzer&quot;: &quot;ik_smart&quot;, &quot;text&quot;: &quot;中华人民共和国国歌&quot; }三：安装kibana1.拉取kibana镜像 docker pull kibana:5.6.112.创建kibana容器并启动 docker run -p 5601:5601 -e ELASTICSEARCH_URL=http://192.168.186.129:9200 -d kibana:5.6.11 3.测试","link":"/2018/11/06/Docker02docker安装ELK/"},{"title":"基于libcurl实现REST风格http/https的get和post","text":"c/c++开发中经常要用到http/https协议，直接使用socket工作量很大，要是使用socket实现https，那更不可思议，开源的c/c++的http客户端框架，libcurl是首选，而且也相当成熟稳定，最近C++项目中用到https请求，就做下研究。 一：libcurl简介(来源官网)libcurl是一个跨平台的网络协议库，支持http, https, ftp, gopher, telnet, dict, file, 和ldap 协议。libcurl同样支持HTTPS证书授权，HTTP POST, HTTP PUT, FTP 上传, HTTP基本表单上传，代理，cookies,和用户认证。官网地址：https://curl.haxx.se/libcurl/ 二：实现HTTP/GETGet.cpp 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364/********************************************************Copyright (C), 2016-2018,FileName: GetAuthor: woniu201Email: wangpengfei.201@163.comCreated: 2018/10/15Description: 实现HTTP/HTTPS GET请求********************************************************/#include &quot;main.h&quot; size_t WriteGetResp(void *buffer, size_t size, size_t nmemb, void *userp){ ((string*)userp)-&gt;append((char*)buffer, 0, size*nmemb); return size*nmemb;} /************************************@ Brief: GET请求@ Author: woniu201 @ Created: 2018/10/15@ Return: ************************************/int HttpGet(char* url){ string respData; CURL* curl; CURLcode res; curl = curl_easy_init(); if (curl == NULL) { return 1; } curl_easy_setopt(curl, CURLOPT_URL, url); curl_easy_setopt(curl, CURLOPT_WRITEFUNCTION, WriteGetResp); curl_easy_setopt(curl, CURLOPT_WRITEDATA, &amp;respData); // curl_easy_setopt(curl, CURLOPT_CONNECTTIMEOUT_MS, 5000); //libcurl存在毫秒超时bug,如果设备小于1000ms立即返回失败// curl_easy_setopt(curl, CURLOPT_TIMEOUT_MS, 5000); //设置超时时间 bool bCA = FALSE; if (!bCA) { curl_easy_setopt(curl, CURLOPT_SSL_VERIFYPEER, FALSE);//设定为不验证证书和HOST curl_easy_setopt(curl, CURLOPT_SSL_VERIFYHOST, FALSE); } else { curl_easy_setopt(curl, CURLOPT_SSL_VERIFYPEER, TRUE); curl_easy_setopt(curl, CURLOPT_CAINFO, &quot;&quot;); } res = curl_easy_perform(curl); if (res != CURLE_OK) { cout &lt;&lt; curl_easy_strerror(res) &lt;&lt; endl; } curl_easy_cleanup(curl); cout &lt;&lt; Utf8ToAscii(respData) &lt;&lt; endl; return 0;} 三：实现HTTP/POSTPost.cpp 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182/********************************************************Copyright (C), 2016-2018,FileName: PostAuthor: woniu201Email: wangpengfei.201@163.comCreated: 2018/10/15Description: 实现HTTP/HTTPS POST请求********************************************************/#include &quot;main.h&quot; size_t WritePostBodyResp(void *buffer, size_t size, size_t nmemb, void *userp){ ((string*)userp)-&gt;append((char*)buffer, 0, size*nmemb); return size*nmemb;} size_t WritePostHeaderResp(void *buffer, size_t size, size_t nmemb, void *userp){ ((string*)userp)-&gt;append((char*)buffer, 0, size*nmemb); return size*nmemb;} /************************************@ Brief: POST请求@ Author: woniu201 @ Created: 2018/10/15@ Return: ************************************/int HttpPost(char* url, char* body){ string respBodyData; string respHeadData; CURL* curl; CURLcode res; //设置头 struct curl_slist *headers = NULL; headers = curl_slist_append(headers, &quot;Content-Type:application/json;charset=UTF-8&quot;); curl = curl_easy_init(); if (curl == NULL) { return 1; } curl_easy_setopt(curl, CURLOPT_URL, url); curl_easy_setopt(curl, CURLOPT_POSTFIELDS, body); curl_easy_setopt(curl, CURLOPT_HTTPHEADER, headers); curl_easy_setopt(curl, CURLOPT_HEADERFUNCTION, WritePostHeaderResp); curl_easy_setopt(curl, CURLOPT_WRITEFUNCTION, WritePostBodyResp); curl_easy_setopt(curl, CURLOPT_WRITEHEADER, &amp;respHeadData); curl_easy_setopt(curl, CURLOPT_WRITEDATA, &amp;respBodyData); // curl_easy_setopt(curl, CURLOPT_CONNECTTIMEOUT_MS, 5000); //libcurl存在毫秒超时bug,如果设备小于1000ms立即返回失败 // curl_easy_setopt(curl, CURLOPT_TIMEOUT_MS, 5000); //设置超时时间 bool bCA = FALSE; if (!bCA) { curl_easy_setopt(curl, CURLOPT_SSL_VERIFYPEER, FALSE);//设定为不验证证书和HOST curl_easy_setopt(curl, CURLOPT_SSL_VERIFYHOST, FALSE); } else { curl_easy_setopt(curl, CURLOPT_SSL_VERIFYPEER, TRUE); curl_easy_setopt(curl, CURLOPT_CAINFO, &quot;&quot;); } res = curl_easy_perform(curl); if (res != CURLE_OK) { cout &lt;&lt; curl_easy_strerror(res) &lt;&lt; endl; } curl_slist_free_all(headers); curl_easy_cleanup(curl); cout &lt;&lt; Utf8ToAscii(respHeadData) &lt;&lt; endl; cout &lt;&lt; Utf8ToAscii(respBodyData) &lt;&lt; endl; return 0;} 其他代码Utils.cpp 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879/********************************************************Copyright (C), 2016-2018,FileName: utilsAuthor: woniu201Email: wangpengfei.201@163.comCreated: 2018/10/15Description: ASSIC--UTF8互转********************************************************/#include &quot;main.h&quot;#include &lt;string&gt;#include &lt;Windows.h&gt;#include &lt;wchar.h&gt;using namespace std; wstring AsciiToUnicode(const string&amp; str) { // 预算-缓冲区中宽字节的长度 int unicodeLen = MultiByteToWideChar(CP_ACP, 0, str.c_str(), -1, nullptr, 0); // 给指向缓冲区的指针变量分配内存 wchar_t *pUnicode = (wchar_t*)malloc(sizeof(wchar_t)*unicodeLen); // 开始向缓冲区转换字节 MultiByteToWideChar(CP_ACP, 0, str.c_str(), -1, pUnicode, unicodeLen); wstring ret_str = pUnicode; free(pUnicode); return ret_str; } string UnicodeToAscii(const wstring&amp; wstr) { // 预算-缓冲区中多字节的长度 int ansiiLen = WideCharToMultiByte(CP_ACP, 0, wstr.c_str(), -1, nullptr, 0, nullptr, nullptr); // 给指向缓冲区的指针变量分配内存 char *pAssii = (char*)malloc(sizeof(char)*ansiiLen); // 开始向缓冲区转换字节 WideCharToMultiByte(CP_ACP, 0, wstr.c_str(), -1, pAssii, ansiiLen, nullptr, nullptr); string ret_str = pAssii; free(pAssii); return ret_str; } wstring Utf8ToUnicode(const string&amp; str) { // 预算-缓冲区中宽字节的长度 int unicodeLen = MultiByteToWideChar(CP_UTF8, 0, str.c_str(), -1, nullptr, 0); // 给指向缓冲区的指针变量分配内存 wchar_t *pUnicode = (wchar_t*)malloc(sizeof(wchar_t)*unicodeLen); // 开始向缓冲区转换字节 MultiByteToWideChar(CP_UTF8, 0, str.c_str(), -1, pUnicode, unicodeLen); wstring ret_str = pUnicode; free(pUnicode); return ret_str; } string UnicodeToUtf8(const wstring&amp; wstr) { // 预算-缓冲区中多字节的长度 int ansiiLen = WideCharToMultiByte(CP_UTF8, 0, wstr.c_str(), -1, nullptr, 0, nullptr, nullptr); // 给指向缓冲区的指针变量分配内存 char *pAssii = (char*)malloc(sizeof(char)*ansiiLen); // 开始向缓冲区转换字节 WideCharToMultiByte(CP_UTF8, 0, wstr.c_str(), -1, pAssii, ansiiLen, nullptr, nullptr); string ret_str = pAssii; free(pAssii); return ret_str; } /************************************@ Brief: ASSIC转UTF8@ Author: woniu201 @ Created: 2018/10/16@ Return: ************************************/string AsciiToUtf8(const string&amp; str) { return UnicodeToUtf8(AsciiToUnicode(str)); } /************************************@ Brief: UTF8转ASSIC@ Author: woniu201 @ Created: 2018/10/16@ Return: ************************************/string Utf8ToAscii(const string&amp; str) { return UnicodeToAscii(Utf8ToUnicode(str)); } main.h 1234567891011121314151617181920#ifndef _MAIN_H#define _MAIN_H #include &lt;iostream&gt;#include &lt;string&gt;#include &quot;include/curl.h&quot; using namespace std; #pragma comment(lib, &quot;ssleay32.lib&quot;)#pragma comment(lib, &quot;libcurl.lib&quot;) string AsciiToUtf8(const string&amp; str);string Utf8ToAscii(const string&amp; str); int HttpGet(char* url);int HttpPost(char* url, char* body);int HttpDownload(char* url, char* filePath);#endif","link":"/2018/10/16/Applied05基于libcurl实现REST风格http-https的get和post/"},{"title":"【Docker】：docker安装redis，挂载外部配置和数据","text":"普通安装1.拉取镜像，redis:4.0 docker pull redis:4.0 2.创建redis容器名”redistest1”，并开启持久化 docker run -d -p 6379:6379 --name redistest1 redis:4.0 redis-server --appendonly yes参数说明： --appendonly yes：开启持久化挂载外部配置和数据安装1.创建目录和配置文件redis.conf mkdir /docker mkdir /docker/redis mkdir /docker/redis/conf mkdir /docker/redis/data 创建redis.conf配置文件 touch /docker/redis/conf/redis.conf redis.conf文件内容自行添加： 切记注释掉：#daemonize yes 否则无法启动容器 重要话说三遍：注释掉#daemonize yes，注释掉#daemonize yes，注释掉#daemonize yes2.创建启动容器，加载配置文件并持久化数据 docker run -d --privileged=true -p 6379:6379 -v /docker/redis/conf/redis.conf:/etc/redis/redis.conf -v /docker/redis/data:/data --name redistest2 redis:4.0 redis-server /etc/redis/redis.conf --appendonly yes参数说明： --privileged=true：容器内的root拥有真正root权限，否则容器内root只是外部普通用户权限 -v /docker/redis/conf/redis.conf:/etc/redis/redis.conf：映射配置文件 -v /docker/redis/data:/data：映射数据目录 redis-server /etc/redis/redis.conf：指定配置文件启动redis-server进程 --appendonly yes：开启数据持久化","link":"/2018/07/09/Docker04docker安装redis/"},{"title":"【Docker】：docker安装mysql，挂载外部配置和数据","text":"普通安装1.下载镜像，mysql 5.7 docker pull mysql:5.7 2.创建mysql容器，并后台启动 docker run -d -p 3306:3306 -e MYSQL_USER=&quot;woniu&quot; -e MYSQL_PASSWORD=&quot;123456&quot; -e MYSQL_ROOT_PASSWORD=&quot;123456&quot; --name mysqltest1 mysql:5.7 --character-set-server=utf8 --collation-server=utf8_general_ci参数说明： -e MYSQL_USER=&quot;woniu&quot; ：添加woniu用户 -e MYSQL_PASSWORD=&quot;123456&quot;：设置添加的用户密码 -e MYSQL_ROOT_PASSWORD=&quot;123456&quot;：设置root用户密码 --character-set-server=utf8：设置字符集为utf8 --collation-server=utf8_general_cli：设置字符比较规则为utf8_general_cli挂载外部配置和数据安装1.创建目录和配置文件my.cnf mkdir /docker mkdir /docker/mysql mkdir /docker/mysql/conf mkdir /docker/mysql/data创建my.cnf配置文件touch /docker/mysql/conf/my.cnf my.cnf添加如下内容： [mysqld] user=mysql character-set-server=utf8 default_authentication_plugin=mysql_native_password [client] default-character-set=utf8 [mysql] default-character-set=utf82.创建容器，并后台启动 docker run -d -p 3306:3306 --privileged=true -v /docker/mysql/conf/my.cnf:/etc/mysql/my.cnf -v /docker/mysql/data:/var/lib/mysql -e MYSQL_ROOT_PASSWORD=123456 --name mysqltest2 mysql:5.7参数说明： --privileged=true：容器内的root拥有真正root权限，否则容器内root只是外部普通用户权限 -v /docker/mysql/conf/my.cnf:/etc/my.cnf：映射配置文件 -v /docker/mysql/data:/var/lib/mysql：映射数据目录","link":"/2018/07/09/Docker03docker安装mysql/"},{"title":"开源组件:FastDFS极速入门与安装","text":"FastDFS是一个开源的轻量级的分布式文件系统，为互联网量身定制，充分考虑了冗余备份、负载均衡、线性扩容等机制，并注重高可用、高性能等指标，使用FastDFS很容易搭建一套高性能的文件服务器集群提供文件上传、下载等服务，如果自己搭建文件系统FastDFS是首选！ 架构图FastDFS 系统有三部分组成： 跟踪服务器(Tracker Server)： 跟踪服务器,主要做调度工作，起到均衡的作用；负责管理所有的 storage server和 group，每个 storage 在启动后会连接 Tracker，告知自己所属 group 等信息，并保持周期性心跳。 存储服务器(Storage Server)： 存储服务器，主要提供容量和备份服务；以 group 为单位，每个 group 内可以有多台 storage server，数据互为备份。 客户端(Client)： 客户端，上传下载数据的服务器，也就是我们自己的项目所部署在的服务器。 准备安装包fastdfs-5.11.tar.gz fastdfs-nginx-module-master.zip libfastcommon-1.0.36.tar.gz nginx-1.8.1.tar.gz安装libfastcommontar -zxvf libfastcommon-1.0.36.tar.gz cd libfastcommon-1.0.3 ./make.sh ./make.sh install安装FastDFStar fastdfs-5.11.tar.gz cd fastdfs-5.1 ./make.sh ./make.sh installFastDFS配置 创建两个目录用来存放数据 mkdir -p /data/fdfs-tracker mkdir -p /data/fdfs-storage 复制配置文件 cd /etc/fdfs cp storage.conf.sample storage.conf cp tracker.conf.sample tracker.conf 修改fdfs-tracker.conf配置文件 base_path=/data/fdfs-tracker 修改fdfs-storage.conf配置文件 base_path=/data/fdfs-storage/base 启动服务 service fdfs_trackerd start service fdfs_storaged start ps -ef|grep fdfs: 测试 配置client文件 12345&gt;cd /etc/fdfs&gt;cp client.conf.sample client.conf&gt;vim client.conf 上传测试：1&gt;fdfs_upload_file /etc/fdfs/client.conf 1.txt 下载测试：123&gt;Fdfs_download_file /etc/fdfs/client.conf group1/M00/00/00/wKhAgFqhWoSAJRKlAAAAGncY82Q560.txt 安装Nginx文件上传成功后无法通过http访问。安装nginx来支持http的访问。 123456789101112131415tar nginx-1.8.1.tar.gzcd nginx-1.8.1./configuremakemake install会在/usr/local/下生成nginx安装文件夹 修改nginx下conf文件里的nginx.conf配置文件 添加如下内容： 常用指令： ./nginx -s stop #立即停止服务 ./nginx -s quit #有序停止服务 ./nginx -s reload #从载配置文件 启动nginx 123&gt;cd sbin&gt;./nginx -c conf/nginx 访问测试","link":"/2018/06/05/开源组件01FastDFS极速入门与安装/"},{"title":"开源组件:定时任务框架Quartz(一)","text":"Quartz是OpenSymphony开源组织的一个开源项目，定时任务框架，纯Java语言实现，最新版本为2.3.0。 设计模式Quartz中使用的设计模式如下： 1.Builder模式 2.Factory模式 3.组件模式 4.链式模式 体系结构1.调度器：scheduler 2.任务：JobDetail 3.触发器：Trigger，包括SimpleTrigger和CronTrigger第一个Quartz程序实现每隔1秒打印一个Hello Worlder 1.创建Maven项目，添加依赖： 123456&lt;!-- https://mvnrepository.com/artifact/org.quartz-scheduler/quartz --&gt;&lt;dependency&gt; &lt;groupId&gt;org.quartz-scheduler&lt;/groupId&gt; &lt;artifactId&gt;quartz&lt;/artifactId&gt; &lt;version&gt;2.3.0&lt;/version&gt;&lt;/dependency&gt; 2.创建HelloWorldJob类 1234567891011121314151617181920package quartz; import org.quartz.Job;import org.quartz.JobExecutionContext;import org.quartz.JobExecutionException; import java.text.SimpleDateFormat;import java.util.Date; /** * created by Java-Road * created in 2018/5/26 */public class HelloWorldJob implements Job { @Override public void execute(JobExecutionContext jobExecutionContext) throws JobExecutionException { String strTime = new SimpleDateFormat(&quot;HH-mm-ss&quot;).format(new Date()); System.out.println( strTime + &quot;:Hello World！&quot;); }} 3.创建MyScheduler类 12345678910111213141516171819202122232425262728293031package quartz; import org.quartz.*;import org.quartz.impl.StdSchedulerFactory; /** * created by Java-Road * created in 2018/5/26 */public class MyScheduler { public static void main(String[] args) throws SchedulerException { //创建调度器Schedule SchedulerFactory schedulerFactory = new StdSchedulerFactory(); Scheduler scheduler = schedulerFactory.getScheduler(); //创建JobDetail实例，并与HelloWordlJob类绑定 JobDetail jobDetail = JobBuilder.newJob(HelloWorldJob.class).withIdentity(&quot;job1&quot;, &quot;jobGroup1&quot;) .build(); //创建触发器Trigger实例(立即执行，每隔1S执行一次) Trigger trigger = TriggerBuilder.newTrigger() .withIdentity(&quot;trigger1&quot;, &quot;triggerGroup1&quot;) .startNow() .withSchedule(SimpleScheduleBuilder.simpleSchedule().withIntervalInSeconds(1).repeatForever()) .build(); //开始执行 scheduler.scheduleJob(jobDetail, trigger); scheduler.start(); }}","link":"/2018/05/27/开源组件05定时任务框架Quartz(一)/"},{"title":"开源组件:定时任务框架Quartz(二)","text":"上一篇文章完成了第一个Quartz程序的编写，这篇从Quartz中的几个重要对象来更深一层认识Quartz框架。 Job和JobDetailJob是Quartz中的一个接口，接口下只有execute方法，在这个方法中编写业务逻辑。 该接口的源码： 12345package org.quartz; public interface Job { void execute(JobExecutionContext var1) throws JobExecutionException;} 每次调度执行Job时，调用execute方法前会创建一个新的Job实例，执行完后，关联的Job对象实例会被释放，随后jvm执行GC。 JobDetail是用来绑定Job，为Job实例提供了许多属性，以及JobDataMap成员变量属性。调度器scheduler通过JobDetail对象来添加Job实例。 属性： 1. name 2. group 3. jobClass 4. jobDataMapJobExecutionContext当调度器Scheduler调用一个Job时，就会将JobExecutionContext传递给Job的execute()方法，Job能通过JobExecutionContext对象访问到Quartz运行时的环境以及Job本身的详细数据信息。 代码演示： 12345678910public class HelloWorldJob implements Job { @Override public void execute(JobExecutionContext jobExecutionContext) throws JobExecutionException { String strTime = new SimpleDateFormat(&quot;HH-mm-ss&quot;).format(new Date()); System.out.println( strTime + &quot;:Hello World！&quot;); System.out.println(&quot;JobDetail&apos;name:&quot; + jobExecutionContext.getJobDetail().getKey().getName()); System.out.println(&quot;JobDetail&apos;group:&quot; + jobExecutionContext.getJobDetail().getKey().getGroup()); System.out.println(&quot;JobDetail&apos;class:&quot; + jobExecutionContext.getJobDetail().getClass()); }} JobDataMap任务调度时可以通过JobExecutionContext获取JobDataMap，可以装在任何可序列化的数据对象，JobDataMap实现了JDK的Map接口，可以以Key-Value的形式存储数据。 实战：JobDetail和Trigger传递数据，HelloWorldJob类execute三种方式获取数据。 123456789101112//创建JobDetail实例，并与HelloWordlJob类绑定JobDetail jobDetail = JobBuilder.newJob(HelloWorldJob.class).withIdentity(&quot;job1&quot;, &quot;jobGroup1&quot;) .usingJobData(&quot;key1&quot;,&quot;this is jobDetail&quot;) .build(); //创建触发器Trigger实例(立即执行，每隔1S执行一次)Trigger trigger = TriggerBuilder.newTrigger() .withIdentity(&quot;trigger1&quot;, &quot;triggerGroup1&quot;) .usingJobData(&quot;key2&quot;, &quot;this is trigger&quot;) .startNow() .withSchedule(SimpleScheduleBuilder.simpleSchedule().withIntervalInSeconds(1).repeatForever()) .build(); HelloWorldJob获取数据： 1234567891011121314151617181920212223242526272829303132333435363738public class HelloWorldJob implements Job { private String key1; private String key2; public String getKey1() { return key1; } public void setKey1(String key1) { this.key1 = key1; } public String getKey2() { return key2; } public void setKey2(String key2) { this.key2 = key2; } @Override public void execute(JobExecutionContext jobExecutionContext) throws JobExecutionException { String strTime = new SimpleDateFormat(&quot;HH-mm-ss&quot;).format(new Date()); System.out.println( strTime + &quot;:Hello World！&quot;); //获取DataMap数据方法一 System.out.println(&quot;JobDetail JobDataMap:&quot; + jobExecutionContext.getJobDetail().getJobDataMap().get(&quot;key1&quot;)); System.out.println(&quot;Trigger JobDataMap:&quot; + jobExecutionContext.getTrigger().getJobDataMap().get(&quot;key2&quot;)); //获取DataMap数据方法二 System.out.println(&quot;JobDataMap:&quot; + jobExecutionContext.getMergedJobDataMap().get(&quot;key1&quot;)); System.out.println(&quot;JobDataMap:&quot; + jobExecutionContext.getMergedJobDataMap().get(&quot;key2&quot;)); //获取数据方法三 System.out.println(&quot;通过成员变量获取&quot; + key1); System.out.println(&quot;通过成员变量获取&quot; + key2); }} TriggerTrigger是Quartz中的触发器，任务执行时会通知调度器Scheduler何时出发，几个重要的属性。 1. Jobkey：表示job实例的标识 2. StartTime：表示触发器首次被触发的时间(Java.util.Date)。 3. EndTime：表示触发器结束触发的时间(Java.util.Date)实战：实现5S后执行，10S后结束，期间每隔1S执行一次定时任务 代码演示： MyScheduler类 1234567891011121314151617181920212223242526272829303132public class MyScheduler { public static void main(String[] args) throws SchedulerException { //创建调度器Schedule SchedulerFactory schedulerFactory = new StdSchedulerFactory(); Scheduler scheduler = schedulerFactory.getScheduler(); //创建JobDetail实例，并与HelloWordlJob类绑定 JobDetail jobDetail = JobBuilder.newJob(HelloWorldJob.class).withIdentity(&quot;job1&quot;, &quot;jobGroup1&quot;) .build(); //创建触发器Trigger实例(5S后执行，10S后结束) //开始时间(5S后) Date date1 = new Date(); date1.setTime(date1.getTime() + 5000); //结束时间(10S后) Date date2 = new Date(); date2.setTime(date2.getTime() + 10000); Trigger trigger = TriggerBuilder.newTrigger() .withIdentity(&quot;trigger1&quot;, &quot;triggerGroup1&quot;) .startAt(date1) .endAt(date2) .withSchedule(SimpleScheduleBuilder.simpleSchedule().withIntervalInSeconds(1).repeatForever()) .build(); //开始执行 scheduler.scheduleJob(jobDetail, trigger); scheduler.start(); }} SimpleTriggerSimpleTrigger可以实现在一个指定时间段内执行一次作业任务或一个时间段内多次执行作业任务。 实战：5S后开始执行，间隔时间为1S，第一次执行后连续执行3次 123456789101112131415161718192021222324252627282930313233343536373839package quartz2; import org.quartz.*;import org.quartz.impl.StdSchedulerFactory; import java.util.Date; /** * created by Java-Road * created in 2018/5/27 */public class MyScheduler2 { public static void main(String[] args) throws SchedulerException { //创建调度器Schedule SchedulerFactory schedulerFactory = new StdSchedulerFactory(); Scheduler scheduler = schedulerFactory.getScheduler(); //创建JobDetail实例，并与HelloWordlJob类绑定 JobDetail jobDetail = JobBuilder.newJob(HelloWorldJob.class).withIdentity(&quot;job1&quot;, &quot;jobGroup1&quot;) .build(); //创建触发器Trigger实例(5S后执行,一直执行) //开始时间(5S后) Date date1 = new Date(); date1.setTime(date1.getTime() + 5000); SimpleTrigger trigger = (SimpleTrigger) TriggerBuilder.newTrigger() .withIdentity(&quot;trigger1&quot;, &quot;triggerGroup1&quot;) .startAt(date1) .withSchedule(SimpleScheduleBuilder.simpleSchedule().withIntervalInSeconds(1) .withRepeatCount(3)) .build(); //开始执行 scheduler.scheduleJob(jobDetail, trigger); scheduler.start(); }} CronTriggerCronTrigger功能非常强大，是基于日历的作业调度，而SimpleTrigger是精准指定间隔，所以相比SimpleTrigger，CroTrigger更加常用。CroTrigger是基于Cron表达式的，先了解下Cron表达式： 由7个子表达式组成字符串的，格式如下： [秒] [分] [小时] [日] [月] [周] [年] Cron表达式的语法就不多说了，因为我也记不住只能度娘，给大家提供个在线生成Cron表达式的工具：http://cron.qqe2.com/ 实战：实现每周一到周五上午10:30执行定时任务 12345678910111213141516171819202122232425262728293031323334package quartz2; import org.quartz.*;import org.quartz.impl.StdSchedulerFactory; import java.util.Date; /** * created by Java-Road * created in 2018/5/27 */public class MyScheduler3 { public static void main(String[] args) throws SchedulerException { //创建调度器Schedule SchedulerFactory schedulerFactory = new StdSchedulerFactory(); Scheduler scheduler = schedulerFactory.getScheduler(); //创建JobDetail实例，并与HelloWordlJob类绑定 JobDetail jobDetail = JobBuilder.newJob(HelloWorldJob.class).withIdentity(&quot;job1&quot;, &quot;jobGroup1&quot;) .build(); //创建触发器CronTrigger实例(每周一到周五10:30执行任务) CronTrigger trigger = (CronTrigger) TriggerBuilder.newTrigger() .withIdentity(&quot;trigger1&quot;, &quot;triggerGroup1&quot;) .startNow() .withSchedule(CronScheduleBuilder.cronSchedule(&quot;* 30 10 ? * MON-FRI *&quot;)) .build(); //开始执行 scheduler.scheduleJob(jobDetail, trigger); scheduler.start(); }}","link":"/2018/05/27/开源组件06定时任务框架Quartz(二)/"},{"title":"Spring Boot入门十一:Spring boot同时支持HTTP和HTTPS","text":"自签证书openssl生成服务端证书，不使用CA证书直接生成 # 1、创建服务器私钥，命令会让你输入一个口令： openssl genrsa -des3 -out server.key 1024 # 2、创建签名请求的证书（CSR）： openssl req -new -key server.key -out server.csr # 3、在加载SSL支持的Nginx并使用上述私钥时除去必须的口令： cp server.key server.key.orgopenssl rsa -in server.key.org -out server.key # 4、最后标记证书使用上述私钥和CSR： openssl x509 -req -days 365 -in server.csr -signkey server.key -out server.crt # 5、server证书转换成keystore文件： openssl pkcs12 -export -in server.crt -inkey server.key -out keystore.p12 -name tomcat配置properties把keystore.p12文件放到resources中 配置application.properties文件 123456##同时支持http和httpsserver.port:8443server.ssl.key-store: classpath:keystore.p12server.ssl.key-store-password: 123456server.ssl.keyStoreType: PKCS12server.ssl.keyAlias: tomcat 配置HTTP端口 12345678910111213141516171819202122232425262728293031package com.woniu.learnhttps.config; import org.apache.catalina.connector.Connector;import org.springframework.boot.context.embedded.ConfigurableEmbeddedServletContainer;import org.springframework.boot.context.embedded.EmbeddedServletContainerCustomizer;import org.springframework.boot.context.embedded.tomcat.TomcatEmbeddedServletContainerFactory;import org.springframework.context.annotation.Bean;import org.springframework.context.annotation.Configuration; /** * created by woniu201 * created in 2018/5/4 */@Configurationpublic class MultiConnectionSupport { @Bean public EmbeddedServletContainerCustomizer containerCustomizer() { return new EmbeddedServletContainerCustomizer() { @Override public void customize(ConfigurableEmbeddedServletContainer container) { if (container instanceof TomcatEmbeddedServletContainerFactory) { TomcatEmbeddedServletContainerFactory containerFactory = (TomcatEmbeddedServletContainerFactory) container; Connector connector = new Connector(TomcatEmbeddedServletContainerFactory.DEFAULT_PROTOCOL); connector.setPort(8080); containerFactory.addAdditionalTomcatConnectors(connector); } } }; }} HTTP端口是8080，HTTPS端口是8443","link":"/2018/05/04/SB11Spring boot同时支持HTTP和HTTPS/"},{"title":"数据结构与算法:单向链表实现与封装(有头)","text":"单向链表分为单向有头链表和单线无头链表，本文针对单向有头链表使用C语言来实现并进行封装。 实现list_head.h文件 123456789101112131415161718192021222324252627282930313233#ifndef _LIST_H_#define _LIST_H_ typedef int datatype; #define SUCC#define MALLOC_FAIL 1#define NOHEADNODE 2#define INDEXFAIL 3#define LIST_EMPTY 4#define LIST_NOEMPTY 5#define FAIL 10 typedef struct List_Node { datatype data; struct List_Node* pNext;}list; list*list_create(); int list_insert_at(list* pHead, int i, datatype* pData);int list_order_insert(list* pHead, datatype* pData); int list_delete_at(list* pHead, int index);int list_delete(list* pHead, datatype* pData); int list_isempty(list* pHead);void list_display(list* pHead);void list_destory(list* pHead); #endif // !_LIST_H_ list_head.c文件 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277/********************************************************Copyright (C), 2016-2017,FileName: listAuthor: woniu201Email: wangpengfei.201@163.comCreated: 2018/01/28Description:单向有头链表使用********************************************************/ #include &lt;stdio.h&gt;#include &quot;list_head.h&quot; /************************************@ Brief: 创建链表头@ Author: woniu201 @ Created: 2018/01/28@ Return: ************************************/list* list_create(){ list* pNode = (list *)malloc(sizeof(list)); memset(pNode, 0, sizeof(list)); if (pNode == NULL) { return MALLOC_FAIL; } pNode-&gt;pNext = NULL; return pNode;} /************************************@ Brief: 按位置插入节点@ Author: woniu201@ Created: 2018/01/28@ Return:************************************/int list_insert_at(list* pHead, int i, datatype* pData){ int j = 0; if (pHead == NULL) { return NOHEADNODE; } list* pNode = pHead; if (i&lt;0) { return INDEXFAIL; } while (j&lt; i &amp;&amp; pNode !=NULL) { pNode = pNode-&gt;pNext; j++; } if (pNode == NULL) { return INDEXFAIL; } else { list* newNode = (list*)malloc(sizeof(list)); if (newNode ==NULL) { return MALLOC_FAIL; } memset(newNode, 0, sizeof(list)); newNode-&gt;data = *pData; pNode-&gt;pNext = newNode; } return SUCC;} /************************************@ Brief: 按顺序插入节点@ Author: woniu201@ Created: 2018/01/28@ Return:************************************/int list_order_insert(list* pHead, datatype* pData){ if (pHead == NULL) { return NOHEADNODE; } list* pNewNode = (list*)malloc(sizeof(list)); if (pNewNode == NULL) { return MALLOC_FAIL; } memset(pNewNode, 0, sizeof(list)); pNewNode-&gt;data = *pData; list* pNode = pHead; if (pNode-&gt;pNext == NULL) { pNode-&gt;pNext = pNewNode; return SUCC; } while (pNode-&gt;pNext != NULL &amp;&amp; pNode-&gt;pNext-&gt;data &lt; *pData) { pNode = pNode-&gt;pNext; } if (pNode-&gt;pNext) { pNewNode-&gt;pNext = pNode-&gt;pNext; pNode-&gt;pNext = pNewNode; } else { pNode-&gt;pNext = pNewNode; } return SUCC;} /************************************@ Brief: 按位置删除节点@ Author: woniu201@ Created: 2018/01/28@ Return:************************************/int list_delete_at(list* pHead, int index){ int j = 0; if (pHead == NULL) { return NOHEADNODE; } if (index &lt; 0) { return INDEXFAIL; } list* pCur = pHead; list* pNode = pHead; while (pCur-&gt;pNext) { pNode = pCur; pCur = pCur-&gt;pNext; if (index == j) { break; } j++; } if (j&lt; index) { printf(&quot;不存在该节点\\n&quot;); return INDEXFAIL; } else { if (pCur-&gt;pNext == NULL) { pNode-&gt;pNext = NULL; } else { pNode-&gt;pNext = pCur-&gt;pNext; } free(pCur); pCur = NULL; } return SUCC;} /************************************@ Brief: 按值删除节点@ Author: woniu201@ Created: 2018/01/28@ Return:************************************/int list_delete(list* pHead, datatype* pData){ if (pHead == NULL) { return NOHEADNODE; } list* pCur = pHead; list* pNode = pHead; int bFind = 0; while (pCur-&gt;pNext) { pNode = pCur; pCur = pCur-&gt;pNext; if (pCur-&gt;data == *pData) { bFind = 1; break; } } if (!bFind) { printf(&quot;不存在该节点\\n&quot;); return INDEXFAIL; } else { if (pCur-&gt;pNext == NULL) { pNode-&gt;pNext = NULL; } else { pNode-&gt;pNext = pCur-&gt;pNext; } free(pCur); pCur = NULL; } return SUCC;} /************************************@ Brief: 判断链表是否为空@ Author: woniu201@ Created: 2018/01/28@ Return:************************************/int list_isempty(list* pHead){ if (pHead-&gt;pNext == NULL) { return LIST_EMPTY; } else { return LIST_NOEMPTY; }} /************************************@ Brief: 遍历打印链表@ Author: woniu201@ Created: 2018/01/28@ Return:************************************/void list_display(list* pHead){ if (list_isempty(pHead) == LIST_EMPTY) { printf(&quot;链表为空\\n&quot;); return FAIL; } list* pNode = pHead-&gt;pNext; while (pNode) { printf(&quot;%d\\n&quot;, pNode-&gt;data); pNode = pNode-&gt;pNext; }} /************************************@ Brief: 释放链表内存@ Author: woniu201@ Created: 2018/01/28@ Return:************************************/void list_destory(list* pHead){ list* pCur = pHead; list* pNext = pHead-&gt;pNext; while (pNext) { pNext = pNext-&gt;pNext; free(pCur); pCur = NULL; pCur = pNext; }} main.c 测试 1234567891011121314151617181920212223242526272829#include &lt;stdio.h&gt;#include &quot;list_head.h&quot; int main(){ list* pHead = list_create(); int data1 = 1; int data2 = 3; int data3 = 2; // int ret = list_insert_at(pHead,0, &amp;data1);// ret = list_insert_at(pHead, 1, &amp;data2);// if (ret == INDEXFAIL)// {// printf(&quot;添加索引位置错误\\n&quot;);// } list_order_insert(pHead, &amp;data2); list_order_insert(pHead, &amp;data1); list_order_insert(pHead, &amp;data3); list_delete_at(pHead, 3); int deleteData = 1; list_delete(pHead, &amp;deleteData); list_display(pHead); list_destory(pHead); return 1;}","link":"/2018/01/28/DSA02单向链表实现与封装(有头)/"},{"title":"windows和linux环境下java调用C++代码-JNI技术","text":"最近部门做安卓移动开发的需要调C++的代码，困难重重，最后任务交给了我，查找相关资料，没有一个教程能把不同环境(windows,linux)下怎么调用说明白的，自己在实现的过程中踩了几个坑，在这里总结下，希望看到的以后能少走弯路。 使用工具： 1.JAVA使用的IDE为eclipse 2.windows环境下C++使用的IDE为visual studio 2010 3.linux环境下C++使用的编译器为gcc/g++一.windows环境下java调用C++代码1.1新建java工程，生成相应头文件 eclipse新建工程名为”jniDemo”的java工程，在包名为com.woniu.Native下新建”NativeCpp.java”类，如下： 1234567package com.woniu.Native; public class NativeCpp { public native void fun1(); public native int fun2(int a, int b); public native void fun3(String url1, String url2);} 编译生成.class文件 进入工程下的target\\classes目录下，执行”javah -jni com.woniu.Native.NativeCpp”,运行结果如下： 此时，会在classes目录下生成”com_woniu_Native_NativeCpp.h”头文件，头文件内容如下： 12345678910111213141516171819202122232425262728293031323334353637/* DO NOT EDIT THIS FILE - it is machine generated */#include &lt;jni.h&gt;/* Header for class com_woniu_Native_NativeCpp */ #ifndef _Included_com_woniu_Native_NativeCpp#define _Included_com_woniu_Native_NativeCpp#ifdef __cplusplusextern &quot;C&quot; {#endif/* * Class: com_woniu_Native_NativeCpp * Method: fun1 * Signature: ()V */JNIEXPORT void JNICALL Java_com_woniu_Native_NativeCpp_fun1 (JNIEnv *, jobject); /* * Class: com_woniu_Native_NativeCpp * Method: fun2 * Signature: (II)I */JNIEXPORT jint JNICALL Java_com_woniu_Native_NativeCpp_fun2 (JNIEnv *, jobject, jint, jint); /* * Class: com_woniu_Native_NativeCpp * Method: fun3 * Signature: (Ljava/lang/String;Ljava/lang/String;)V */JNIEXPORT void JNICALL Java_com_woniu_Native_NativeCpp_fun3 (JNIEnv *, jobject, jstring, jstring); #ifdef __cplusplus}#endif#endif 1.2 c++生成动态库vs2010新建工程名为”JniDll”的win32控制台应用程序，win32应用程序向导界面选择 “DLL” 创建完成后，把2.1中生成的”com_woniu_Native_NativeCpp.h”头文件放入该工程，并把头文件中的#include &lt;jni.h&gt;改为 “jni.h”，把JDK下include文件夹下的”jni.h”和include下win32文件夹下的”jni_md.h”头文件也一同放入创建的工程中。 工程目录如下： 编辑JniDll.cpp源码文件，实现头文件中的函数，如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051/********************************************************Copyright (C), 2016-2017,FileName: jniAuthor: woniu201Email: wangpengfei.201@163.comCreated: 2017/09/20Description:Jni function********************************************************/#include &quot;stdafx.h&quot;#include &quot;com_woniu_Native_NativeCpp.h&quot;#include &quot;stdio.h&quot;#include &quot;stdlib.h&quot; JNIEXPORT void JNICALL Java_com_woniu_Native_NativeCpp_fun1 (JNIEnv *, jobject){ printf(&quot;hello world\\n&quot;);} JNIEXPORT jint JNICALL Java_com_woniu_Native_NativeCpp_fun2 (JNIEnv *, jobject, jint a, jint b){ return a + b;} char* jstringToChar(JNIEnv* env, jstring jstr) { char* rtn = NULL; jclass clsstring = env-&gt;FindClass(&quot;java/lang/String&quot;); jstring strencode = env-&gt;NewStringUTF(&quot;GB2312&quot;); jmethodID mid = env-&gt;GetMethodID(clsstring, &quot;getBytes&quot;, &quot;(Ljava/lang/String;)[B&quot;); jbyteArray barr = (jbyteArray) env-&gt;CallObjectMethod(jstr, mid, strencode); jsize alen = env-&gt;GetArrayLength(barr); jbyte* ba = env-&gt;GetByteArrayElements(barr, JNI_FALSE); if (alen &gt; 0) { rtn = (char*) malloc(alen + 1); memcpy(rtn, ba, alen); rtn[alen] = 0; } env-&gt;ReleaseByteArrayElements(barr, ba, 0); return rtn;} JNIEXPORT void JNICALL Java_com_woniu_Native_NativeCpp_fun3 (JNIEnv *env, jobject, jstring url1, jstring url2){ //jstringתchar* char* pUrl1 = jstringToChar(env, url1); char* pUrl2 = jstringToChar(env, url2); printf(&quot;url1 = %s\\n&quot;, pUrl1); printf(&quot;url2 = %s\\n&quot;, pUrl2);} 我本机是64位系统，使用的是64位JDK，这里生成的动态库也要生成64位的库，否则调用的时候报如下错误： 更改vs编译生成64位dll，步骤如下： 编译生成解决方案，这时候会在工程根目录下，生成”x64文件夹”，Debug文件夹下会有动态库”JniDll.dll” 1.3 java调用dll 123456789101112131415package com.woniu.jniDemo; import com.woniu.Native.NativeCpp; public class App { public static void main( String[] args ) { System.load(&quot;D:\\\\VS2010\\\\VC\\\\JniDll\\\\x64\\\\Debug\\\\JniDll.dll&quot;); NativeCpp nativeCpp = new NativeCpp(); nativeCpp.fun1(); System.out.println(nativeCpp.fun2(3, 3)); nativeCpp.fun3(&quot;www.baidu.com&quot;, &quot;www.haoservice.cn&quot;); }} 运行结果如下： 二：linux(CentOS)环境下java调用C++代码2.1 编译环境 a.安装gcc和g++ yum install gcc-c++ b.安装jdk 去官网上下载jdk安装包，建议使用rpm安装包，会自动配置环境变量。安装完后如下： 本机的安装目录为：/usr/java/jdk1.8.0_144/，不同版本可能不同。 这里一定要注意不能安装openjdk,因为openjdk没有include目录，编译时需要用到include目录的头文件。 2.2 制作动态库(so库) a.创建文件夹&quot;jniso&quot;,mkdir jniso。 b.把2.1中生成的头文件&quot;com_woniu_Native_NativeCpp.h&quot;拷贝过来,#include &quot;jni.h&quot;改为#include &lt;jni.h&gt; c.新建jni.cpp源文件，添加如下代码：123456789101112131415161718192021222324252627282930313233343536373839404142#include &lt;jni.h&gt;#include &quot;com_woniu_Native_NativeCpp.h&quot;#include &quot;stdio.h&quot;#include &quot;stdlib.h&quot;#include &quot;string.h&quot; JNIEXPORT void JNICALL Java_com_woniu_Native_NativeCpp_fun1 (JNIEnv *, jobject){ printf(&quot;hello world\\n&quot;);} JNIEXPORT jint JNICALL Java_com_woniu_Native_NativeCpp_fun2 (JNIEnv *, jobject, jint a, jint b){ return a + b;} char* jstringToChar(JNIEnv* env, jstring jstr) { char* rtn = NULL; jclass clsstring = env-&gt;FindClass(&quot;java/lang/String&quot;); jstring strencode = env-&gt;NewStringUTF(&quot;GB2312&quot;); jmethodID mid = env-&gt;GetMethodID(clsstring, &quot;getBytes&quot;, &quot;(Ljava/lang/String;)[B&quot;); jbyteArray barr = (jbyteArray) env-&gt;CallObjectMethod(jstr, mid, strencode); jsize alen = env-&gt;GetArrayLength(barr); jbyte* ba = env-&gt;GetByteArrayElements(barr, JNI_FALSE); if (alen &gt; 0) { rtn = (char*) malloc(alen + 1); memcpy(rtn, ba, alen); rtn[alen] = 0; } env-&gt;ReleaseByteArrayElements(barr, ba, 0); return rtn;} JNIEXPORT void JNICALL Java_com_woniu_Native_NativeCpp_fun3 (JNIEnv *env, jobject, jstring url1, jstring url2){ char* pUrl1 = jstringToChar(env, url1); char* pUrl2 = jstringToChar(env, url2); printf(&quot;url1 = %s\\n&quot;, pUrl1); printf(&quot;url2 = %s\\n&quot;, pUrl2);} d.编译，生成动态库g++ -fPIC -c jni.cpp -I /usr/java/jdk1.8.0_144/include/ -I /usr/java/jdk1.8.0_144/include/linux/g++ -shared jni.o -o jni.so 2.3 java调用jni.so 123456789101112131415161718import com.woniu.Native.NativeCpp; public class App { public static void main( String[] args ) { //windows环境下加载库 //System.load(&quot;D:\\\\VS2010\\\\VC\\\\JniDll\\\\x64\\\\Debug\\\\JniDll.dll&quot;); //linux下加载库 System.load(&quot;/mnt/hgfs/svn/svn/Demo/jniso/jni.so&quot;); NativeCpp nativeCpp = new NativeCpp(); nativeCpp.fun1(); System.out.println(nativeCpp.fun2(3, 3)); nativeCpp.fun3(&quot;www.baidu.com&quot;, &quot;www.haoservice.cn&quot;); }} 运行结果如下： 关注下面公众号，回复”105”获取windows下生成dll源码 关注下面公众号，回复”106”获取linux下生成so源码","link":"/2017/09/20/Applied08JNI技术/"},{"title":"C++构造和解析JSON","text":"JSON是一种轻量级的数据交互格式，易于人阅读和编写，同时也易于机器解析和生成，并有效地提升网络传输效率，实际项目中经常用到，相比xml有很多优点，问问度娘，优点一箩筐。 第三方库json解析选用jsoncpp作为第三方库，jsoncpp使用广泛，c++开发首选。 jsoncpp目前已经托管到了github上，地址：https://github.com/open-source-parsers/jsoncpp 使用使用c++进行构造json和解析json，选用vs2010作为IDE。工程中使用jsoncpp的源码进行编译，没有使用jsoncpp的库，为方便大家使用把dll和lib库也放到了我的工程jsoncpplib文件夹下，有需要的可以直接引用库。 待解析的json数据格式如下图： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156/********************************************************Copyright (C), 2016-2017,FileName: mainAuthor: woniu201Email: wangpengfei.201@163.comCreated: 2017/09/06Description:use jsoncpp src , not use dll, but i also provide dll and lib.********************************************************/ #include &quot;stdio.h&quot;#include &lt;string&gt;#include &quot;jsoncpp/json.h&quot; using namespace std; /************************************@ Brief: read file@ Author: woniu201 @ Created: 2017/09/06@ Return: file data ************************************/char *getfileAll(char *fname){ FILE *fp; char *str; char txt[1000]; int filesize; if ((fp=fopen(fname,&quot;r&quot;))==NULL){ printf(&quot;open file %s fail \\n&quot;,fname); return NULL; } fseek(fp,0,SEEK_END); filesize = ftell(fp); str=(char *)malloc(filesize); str[0]=0; rewind(fp); while((fgets(txt,1000,fp))!=NULL){ strcat(str,txt); } fclose(fp); return str;} /************************************@ Brief: write file@ Author: woniu201 @ Created: 2017/09/06@ Return: ************************************/int writefileAll(char* fname,const char* data){ FILE *fp; if ((fp=fopen(fname, &quot;w&quot;)) == NULL) { printf(&quot;open file %s fail \\n&quot;, fname); return 1; } fprintf(fp, &quot;%s&quot;, data); fclose(fp); return 0;} /************************************@ Brief: parse json data@ Author: woniu201 @ Created: 2017/09/06@ Return: ************************************/int parseJSON(const char* jsonstr){ Json::Reader reader; Json::Value resp; if (!reader.parse(jsonstr, resp, false)) { printf(&quot;bad json format!\\n&quot;); return 1; } int result = resp[&quot;Result&quot;].asInt(); string resultMessage = resp[&quot;ResultMessage&quot;].asString(); printf(&quot;Result=%d; ResultMessage=%s\\n&quot;, result, resultMessage.c_str()); Json::Value &amp; resultValue = resp[&quot;ResultValue&quot;]; for (int i=0; i&lt;resultValue.size(); i++) { Json::Value subJson = resultValue[i]; string cpuRatio = subJson[&quot;cpuRatio&quot;].asString(); string serverIp = subJson[&quot;serverIp&quot;].asString(); string conNum = subJson[&quot;conNum&quot;].asString(); string websocketPort = subJson[&quot;websocketPort&quot;].asString(); string mqttPort = subJson[&quot;mqttPort&quot;].asString(); string ts = subJson[&quot;TS&quot;].asString(); printf(&quot;cpuRatio=%s; serverIp=%s; conNum=%s; websocketPort=%s; mqttPort=%s; ts=%s\\n&quot;,cpuRatio.c_str(), serverIp.c_str(), conNum.c_str(), websocketPort.c_str(), mqttPort.c_str(), ts.c_str()); } return 0;} /************************************@ Brief: create json data@ Author: woniu201 @ Created: 2017/09/06@ Return: ************************************/int createJSON(){ Json::Value req; req[&quot;Result&quot;] = 1; req[&quot;ResultMessage&quot;] = &quot;200&quot;; Json::Value object1; object1[&quot;cpuRatio&quot;] = &quot;4.04&quot;; object1[&quot;serverIp&quot;] = &quot;42.159.116.104&quot;; object1[&quot;conNum&quot;] = &quot;1&quot;; object1[&quot;websocketPort&quot;] = &quot;0&quot;; object1[&quot;mqttPort&quot;] = &quot;8883&quot;; object1[&quot;TS&quot;] = &quot;1504665880572&quot;; Json::Value object2; object2[&quot;cpuRatio&quot;] = &quot;2.04&quot;; object2[&quot;serverIp&quot;] = &quot;42.159.122.251&quot;; object2[&quot;conNum&quot;] = &quot;2&quot;; object2[&quot;websocketPort&quot;] = &quot;0&quot;; object2[&quot;mqttPort&quot;] = &quot;8883&quot;; object2[&quot;TS&quot;] = &quot;1504665896981&quot;; Json::Value jarray; jarray.append(object1); jarray.append(object2); req[&quot;ResultValue&quot;] = jarray; Json::FastWriter writer; string jsonstr = writer.write(req); printf(&quot;%s\\n&quot;, jsonstr.c_str()); writefileAll(&quot;createJson.json&quot;, jsonstr.c_str()); return 0;} int main(){ char* json = getfileAll(&quot;parseJson.json&quot;); parseJSON(json); printf(&quot;===============================\\n&quot;); createJSON(); getchar(); return 1;} 关注下面公众号，回复”104”获取源码","link":"/2017/09/06/Applied02C++构造和解析Json/"},{"title":"C++生成和解析XML文件","text":"1.xml 指可扩展标记语言(EXtensible Markup Language)2.xml 是一种标记语言，类似html3.xml 的设计宗旨是传输数据，而非显示数据4.xml 标签没有被预定义。需要自行定义标签 XML与HTML区别1.xml 不是 html 的替代。2.xml 和 html 为不同的目的而设计：3.xml 被设计为传输和存储数据，其焦点是数据的内容。4.html 被设计用来显示数据，其焦点是数据的外观。5.html 旨在显示信息，而 xml 旨在传输信息。 第三方库XML第三方解析库,选用TinyXML,TinyXML也是一个开源的解析XML解析库，使用简单正如其名，用于C++开发，支持Windows和Linux。TinyXML通过DOM模型遍历和分析XML。官网地址：http://www.grinninglizard.com/tinyxml/ 生成XML文件123456789101112131415161718192021222324252627282930TiXmlDocument xmlDocument;// 添加XML声明xmlDocument.LinkEndChild(new TiXmlDeclaration( &quot;1.0&quot;, &quot;GBK&quot;, &quot;&quot; ));// 添加根元素TiXmlElement * xmlRoot = new TiXmlElement(&quot;root&quot;);xmlDocument.LinkEndChild(xmlRoot);//根元素下添加子元素1TiXmlElement* xmlChild1 = new TiXmlElement(&quot;name&quot;);xmlRoot-&gt;LinkEndChild(xmlChild1);xmlChild1-&gt;LinkEndChild(new TiXmlText(&quot;woniu&quot;));xmlChild1-&gt;SetAttribute(&quot;id&quot;, &quot;0001&quot;);//设置属性//根元素下添加子元素2TiXmlElement* xmlChild2 = new TiXmlElement(&quot;Student&quot;);xmlRoot-&gt;LinkEndChild(xmlChild2);TiXmlElement* xmlChild2_01 = new TiXmlElement(&quot;name&quot;);xmlChild2-&gt;LinkEndChild(xmlChild2_01);xmlChild2_01-&gt;LinkEndChild(new TiXmlText(&quot;woniu201&quot;)); TiXmlElement* xmlChild2_02 = new TiXmlElement(&quot;classes&quot;);xmlChild2-&gt;LinkEndChild(xmlChild2_02);xmlChild2_02-&gt;LinkEndChild(new TiXmlText(&quot;86&quot;));//保存xml文件xmlDocument.SaveFile(&quot;woniu.xml&quot;); 生成XML如下： 解析XML文件123456789101112131415161718192021222324TiXmlDocument xmlDocument;if (!xmlDocument.LoadFile(&quot;woniu.xml&quot;)){ return -1;}//根节点TiXmlElement* xmlRoot = xmlDocument.RootElement();if (xmlRoot == NULL){ return -1;}//获取子节点信息1TiXmlElement* xmlNode1Name = xmlRoot-&gt;FirstChildElement(&quot;name&quot;);const char* node1Name = xmlNode1Name-&gt;GetText();const char* node1AttId = xmlNode1Name-&gt;Attribute(&quot;id&quot;);//获取子节点信息2TiXmlElement* xmlNode2Stu = xmlRoot-&gt;FirstChildElement(&quot;Student&quot;);TiXmlElement* xmlNode2_name = xmlNode2Stu-&gt;FirstChildElement(&quot;name&quot;);TiXmlElement* xmlname2_classes = xmlNode2Stu-&gt;FirstChildElement(&quot;classes&quot;);const char* node2Name = xmlNode2_name-&gt;GetText();const char* node2Classes = xmlname2_classes-&gt;GetText(); 关注下面公众号，回复”101”获取源码","link":"/2017/07/31/Applied01C++生成和解析XML文件/"},{"title":"C++实现16进制字符串转换成int整形值","text":"开发中经常需要把16进制字符串转换成整形，写了个个代码供大家参考下： 1234567891011121314151617181920212223242526272829303132333435363738#include &lt;stdio.h&gt;#include &lt;string.h&gt; //字符转换成整形int hex2int(char c){ if ((c &gt;= &apos;A&apos;) &amp;&amp; (c &lt;= &apos;Z&apos;)) { return c - &apos;A&apos; + 10; } else if ((c &gt;= &apos;a&apos;) &amp;&amp; (c &lt;= &apos;z&apos;)) { return c - &apos;a&apos; + 10; } else if ((c &gt;= &apos;0&apos;) &amp;&amp; (c &lt;= &apos;9&apos;)) { return c - &apos;0&apos;; }}int main(){ //十六进制字符串转换成整形 const char* hexStr = &quot;EFA0&quot;; int data[32] = {0}; int count = 0; for (int i=0; i&lt;strlen(hexStr); i+=2) { int high = hex2int(hexStr[i]); //高四位 int low = hex2int(hexStr[i+1]); //低四位 data[count++] = (high&lt;&lt;4) + low; } //打印输出 for (int i=0; i&lt;strlen(hexStr)/2; i++) { printf(&quot;%d &quot;, data[i]); } return 1;}","link":"/2017/07/28/Applied09C++实现16进制字符串转换成int整形值/"},{"title":"Rabbitmq C++客户端 Rabbitmq Client","text":"最近项目消息队列服务选用了rabbitmq，server端用的C++开发的，于是需要开发rabbitmq的c++客户端，国际惯例先百度了一圈，然后github搜了一圈，竟然发现排名靠前的需要付费才能使用，尼玛这都拿出来骗钱(愤青了)，于是产生了写个客户端给大家使用的念头。 我的应用场景是这样的生产者是用java写的(java别说了，一搜一大堆，改个服务器地址就能用)，服务端作为消费者，老本行用的C++开发的，只需写个c++的rabbitmq客户端嵌入到我的server里就行，所有的消费者监听的一个队列，无需指定routing key和exchange，任何一个消费者消费到数据就行(我的服务端是个集群)。话不多说上代码。 实现我的环境是Linux centos7.2 amqpclient.cpp源码如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118#include &lt;unistd.h&gt;#include &lt;stdlib.h&gt;#include &lt;stdio.h&gt;#include &lt;string.h&gt;#include &lt;stdint.h&gt; #include &quot;amqp_tcp_socket.h&quot;#include &quot;amqp.h&quot;#include &quot;amqp_framing.h&quot;#include &quot;utils.h&quot;#include &quot;platform_utils.h&quot;#include &quot;amqpclient.h&quot; /** 构造函数* hostname,port,user,pwd,vhost*/ AmqpClient::AmqpClient(const char* hostname, const int port, const char* user, const char* pwd, const char* vhost, const char* queuename){ if((hostname != NULL) || (port != 0) || (user != NULL) || (pwd != NULL) || (vhost != NULL) || (queuename != NULL)) { strcpy(this-&gt;m_hostname, hostname); this-&gt;m_port = port; strcpy(this-&gt;m_user, user); strcpy(this-&gt;m_pwd, pwd); strcpy(this-&gt;m_vhost, vhost); strcpy(this-&gt;m_queuename, queuename); }} bool AmqpClient::ConnectRabbitmq(){ amqp_socket_t *socket ; amqp_rpc_reply_t reply ; int status; conn = amqp_new_connection(); socket = amqp_tcp_socket_new(conn); if(!socket) { printf(&quot;amqp new socket error\\n&quot;); return 0; } status = amqp_socket_open(socket, m_hostname, m_port); if(status) { printf(&quot;amqp open socket error\\n&quot;); return 0; } reply = amqp_login(conn, m_vhost, 0, 131072, 0, AMQP_SASL_METHOD_PLAIN, m_user, m_pwd); if (reply.reply_type == AMQP_RESPONSE_SERVER_EXCEPTION) { printf(&quot;amqp login error\\n&quot;); return 0; } amqp_channel_open(conn, 1); reply = amqp_get_rpc_reply(conn); if(reply.reply_type == AMQP_RESPONSE_SERVER_EXCEPTION) { printf(&quot;ConnectRabbitmq::amqp get rpc_reply error\\n&quot;); return 0; }} bool AmqpClient::StartConsumer(){ amqp_rpc_reply_t reply ; //自动回复ACK amqp_basic_consume(conn, 1, amqp_cstring_bytes(m_queuename), amqp_empty_bytes, 0, 1, 0, amqp_empty_table); reply = amqp_get_rpc_reply(conn); if(reply.reply_type == AMQP_RESPONSE_SERVER_EXCEPTION) { printf(&quot;StartConsumer::amqp get rpc_reply error\\n&quot;); return false; } { for (;;) { amqp_rpc_reply_t res; amqp_envelope_t envelope; amqp_maybe_release_buffers(conn); res = amqp_consume_message(conn, &amp;envelope, NULL, 0); if (AMQP_RESPONSE_NORMAL != res.reply_type) { break; } printf(&quot;Delivery %u, exchange %.*s routingkey %.*s\\n&quot;, (unsigned) envelope.delivery_tag, (int) envelope.exchange.len, (char *) envelope.exchange.bytes, (int) envelope.routing_key.len, (char *) envelope.routing_key.bytes); if (envelope.message.properties._flags &amp; AMQP_BASIC_CONTENT_TYPE_FLAG) { printf(&quot;Content-type: %.*s\\n&quot;, (int) envelope.message.properties.content_type.len, (char *) envelope.message.properties.content_type.bytes); } printf(&quot;----\\n&quot;); amqp_dump(envelope.message.body.bytes, envelope.message.body.len); amqp_destroy_envelope(&amp;envelope); } }} void AmqpClient::CloseConnect(){ amqp_rpc_reply_t reply ; amqp_channel_close(conn, 1, AMQP_REPLY_SUCCESS); amqp_connection_close(conn, AMQP_REPLY_SUCCESS); amqp_destroy_connection(conn);} amqpclient.h源码如下： 123456789101112131415161718192021222324#ifndef _AMQPCLIENT_H#define _AMQPCLIENT_H #include &quot;amqp.h&quot; class AmqpClient{public: AmqpClient(const char* hostname, const int port, const char* user, const char* pwd, const char* vhost, const char* queuename); bool ConnectRabbitmq(); bool StartConsumer(); void CloseConnect();private: amqp_connection_state_t conn = NULL; char m_hostname[128]; int m_port; char m_user[128]; char m_pwd[128]; char m_vhost[128]; char m_queuename[128];}; #endif main.cpp源码如下： 12345678910111213141516171819#include &lt;stdio.h&gt;#include &quot;amqpclient.h&quot; int main(){ const char* hostname = &quot;192.168.12.20&quot;; const int port = 5672; const char* user = &quot;woniu201&quot;; const char* pwd = &quot;woniu201&quot;; const char* vhost = &quot;/&quot;; const char* queuename = &quot;queuename001&quot;; AmqpClient amqpClient(hostname, port, user, pwd, vhost, queuename); amqpClient.ConnectRabbitmq(); printf(&quot;connect rabbitmq succ, is consuming!\\n&quot;); amqpClient.StartConsumer(); return 1;} Makefile文件： 12345678910111213141516171819202122232425262728EXE=rabbitmq_consumerSUBDIR=src #CXXFLAGS:编译选项, LDFLAGS:链接选项CXXFLAGS += LDFLAGS += -L/usr/local/lib -lrabbitmq CXX_SOURCES =$(foreach dir,$(SUBDIR), $(wildcard $(dir)/*.cpp))CXX_OBJECTS=$(patsubst %.cpp, %.o, $(CXX_SOURCES))DEP_FILES =$(patsubst %.o, %.d, $(CXX_OBJECTS)) $(EXE): $(CXX_OBJECTS) g++ $(CXX_OBJECTS) -o $(EXE) $(LDFLAGS) %.o: %.cpp g++ -c $(CXXFLAGS) -MMD $&lt; -o $@ -include $(DEP_FILES) clean: rm -rf $(CXX_OBJECTS) $(DEP_FILES) $(EXE) test: echo $(CXX_OBJECTS) initlib: ln -s lib/librabbitmq.so.4.2.0 /usr/local/lib/librabbitmq.so ln -s lib/librabbitmq.so.4.2.0 /usr/lib64/librabbitmq.so.4 这里用到了librabbitmq.so.4动态库，make前先执行make initlib指令，会把所用的librabbitmq.so库放到系统环境中。 make完后会生产rabbitmq_consumer可执行文件，./rabbitmq_consumer执行。 测试结果如下： 关注下面公众号，回复”107”获取源码","link":"/2017/07/26/Applied10Rabbitmq C++客户端 Rabbitmq Client/"},{"title":"Spring Boot入门十:集成Sentinel Redis","text":"前言上一篇文章介绍了spring boot集成单点的redis，然而实际生产环境使用单点的redis风险很高，一旦宕机整个服务将无法使用，这篇文章介绍如何使用基于sentinel的redis高可用方案。 哨兵sentinel的地址如下： 192.168.12.194:26379 192.168.12.194:36379 192.168.12.194:46379Redis的地址如下： 192.168.12.194:6379 192.168.12.194:6380 192.168.12.194:6381实现：properties配置文件中添加配置信息： 12345678910111213spring.redis.database=0spring.redis.password=123456 # pool settings ...池配置 spring.redis.pool.max-idle=8 spring.redis.pool.min-idle=0 spring.redis.pool.max-active=8 spring.redis.pool.max-wait=-1 #哨兵监听redis server名称spring.redis.sentinel.master=mymaster#哨兵的配置列表spring.redis.sentinel.nodes=192.168.12.194:26379,192.168.12.194:36379,192.168.12.194:46379 创建RedisComponent类 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960package com.woniu.RedisComponent; import java.io.UnsupportedEncodingException; import org.springframework.beans.factory.annotation.Autowired;import org.springframework.data.redis.core.RedisTemplate;import org.springframework.data.redis.core.StringRedisTemplate;import org.springframework.data.redis.core.ValueOperations;import org.springframework.stereotype.Component;import org.springframework.stereotype.Service; import com.woniu.bean.User; @Componentpublic class RedisComponent { @Autowired //操作字符串的template，StringRedisTemplate是RedisTemplate的一个子集 private StringRedisTemplate stringRedisTemplate; @Autowired // RedisTemplate，可以进行所有的操作 private RedisTemplate&lt;Object,Object&gt; redisTemplate; public void set(String key, String value){ ValueOperations&lt;String, String&gt; ops = this.stringRedisTemplate.opsForValue(); boolean bExistent = this.stringRedisTemplate.hasKey(key); if (bExistent) { System.out.println(&quot;this key is bExistent!&quot;); }else{ ops.set(key, value); } } public String get(String key){ return this.stringRedisTemplate.opsForValue().get(key); } public void del(String key){ this.stringRedisTemplate.delete(key); } public void sentinelSet(User user){ String key = null; try { key = new String(user.getId().getBytes(&quot;gbk&quot;),&quot;utf-8&quot;); } catch (UnsupportedEncodingException e) { // TODO Auto-generated catch block e.printStackTrace(); } System.out.println(key); redisTemplate.opsForValue().set(key, user.toString()); } public String sentinelGet(String key){ return stringRedisTemplate.opsForValue().get(key); }} 添加测试类的测试代码 12345678910111213141516171819202122232425262728293031323334package com.woniu; import org.junit.Test;import org.junit.runner.RunWith;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.boot.test.context.SpringBootTest;import org.springframework.test.context.junit4.SpringRunner; import com.woniu.RedisComponent.RedisComponent;import com.woniu.bean.User; @RunWith(SpringRunner.class)@SpringBootTestpublic class SpringbootSentinelredisApplicationTests { @Autowired private RedisComponent redisComponet; @Test public void sentinelSet(){ User user = new User(); user.setId(&quot;001&quot;); user.setAge(&quot;30&quot;); user.setName(&quot;wangpengfei&quot;); redisComponet.sentinelSet(user); } @Test public void sentinelGet(){ String str = redisComponet.sentinelGet(&quot;001&quot;); System.out.println(str); }} 工程springboot_sentinelredis源码下载地址：点击打开链接","link":"/2017/01/16/SB10集成SentinelRedis/"},{"title":"Spring Boot入门九:集成redis","text":"一.创建项目项目名称为 “springboot_redis”，创建过程中勾选 “Web”，“Redis”，第一次创建Maven需要下载依赖包(耐心等待) 二.实现properties配置文件中添加配置信息 ##########redis############ #redis的IP地址 spring.redis.host=localhost #redis的端口 spring.redis.port=6379 #redis的密码 spring.redis.password=123456 #redis默认有16个数据库，使用DB0 spring.redis.database=0创建RedisComponent类 1234567891011121314151617181920212223242526272829303132package com.woniu.RedisComponent; import org.apache.hadoop.mapred.gethistory_jsp;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.data.redis.core.StringRedisTemplate;import org.springframework.data.redis.core.ValueOperations;import org.springframework.stereotype.Component; @Componentpublic class RedisComponent { @Autowired private StringRedisTemplate stringRedisTemplate; public void set(String key, String value){ ValueOperations&lt;String, String&gt; ops = this.stringRedisTemplate.opsForValue(); boolean bExistent = this.stringRedisTemplate.hasKey(key); if (bExistent) { System.out.println(&quot;this key is bExistent!&quot;); }else{ ops.set(key, value); } } public String get(String key){ return this.stringRedisTemplate.opsForValue().get(key); } public void del(String key){ this.stringRedisTemplate.delete(key); }} 创建WebController类 1234567891011121314151617181920212223242526272829303132package com.woniu.controller; import org.springframework.beans.factory.annotation.Autowired;import org.springframework.web.bind.annotation.PathVariable;import org.springframework.web.bind.annotation.RequestMapping;import org.springframework.web.bind.annotation.RestController; import com.woniu.RedisComponent.RedisComponent; @RestController@RequestMapping(value=&quot;/web&quot;)public class WebController { @Autowired private RedisComponent redisComponet; @RequestMapping(value=&quot;/set/{key}/{value}&quot;) public String set(@PathVariable String key, @PathVariable String value){ redisComponet.set(key, value); return &quot;set key succ!&quot;; } @RequestMapping(value=&quot;/get/{key}&quot;) public String get(@PathVariable String key){ return redisComponet.get(key); } @RequestMapping(value=&quot;/del/{key}&quot;) public void del(@PathVariable String key){ redisComponet.del(key); }} 本机安装redis，设置密码为123456，启动redis。测试： 工程springboot_redis源码下载地址：点击打开链接","link":"/2017/01/14/SB09集成redis/"},{"title":"Spring Boot入门八:Mybatis使用分页插件PageHelper","text":"一.前言上篇博客中介绍了spring boot集成mybatis的方法，基于上篇文章这里主要介绍如何使用分页插件PageHelper。在MyBatis中提供了拦截器接口，我们可以使用PageHelp最为一个插件装入到SqlSessionFactory，实现拦截器功能。 二.实现pom.xml文件中添加依赖包 12345&lt;dependency&gt; &lt;groupId&gt;com.github.pagehelper&lt;/groupId&gt; &lt;artifactId&gt;pagehelper&lt;/artifactId&gt; &lt;version&gt;4.1.0&lt;/version&gt;&lt;/dependency&gt; 创建MybatisConf类 123456789101112131415161718192021222324252627package com.woniu.mybatisconf; import java.util.Properties; import org.springframework.context.annotation.Bean;import org.springframework.context.annotation.Configuration; import com.github.pagehelper.PageHelper; /* * 注册MyBatis分页插件PageHelper */ @Configurationpublic class MybatisConf { @Bean public PageHelper pageHelper() { System.out.println(&quot;MyBatisConfiguration.pageHelper()&quot;); PageHelper pageHelper = new PageHelper(); Properties p = new Properties(); p.setProperty(&quot;offsetAsPageNum&quot;, &quot;true&quot;); p.setProperty(&quot;rowBoundsWithCount&quot;, &quot;true&quot;); p.setProperty(&quot;reasonable&quot;, &quot;true&quot;); pageHelper.setProperties(p); return pageHelper; }} 这时就可以使用PageHelp插件了，在controller中直接使用。 12345678910111213141516171819202122232425262728package com.woniu.controller; import java.util.List; import org.springframework.beans.factory.annotation.Autowired;import org.springframework.web.bind.annotation.RequestMapping;import org.springframework.web.bind.annotation.RestController; import com.github.pagehelper.PageHelper;import com.woniu.bean.User;import com.woniu.mapper.UserMaper; @RestController@RequestMapping(&quot;/web&quot;)public class WebController { @Autowired private UserMaper mapper; @RequestMapping(&quot;/index&quot;) public List&lt;User&gt; selectAge(int age){ /* * 第一个参数是第几页；第二个参数是每页显示条数。 */ PageHelper.startPage(1,2); return mapper.Select(age); }} 该工程”springboot_mybatis_demo2”下载地址： 点击打开链接","link":"/2017/01/13/SB08Mybatis使用分页插件PageHelper/"},{"title":"Spring Boot入门七:集成MyBatis","text":"一.创建项目项目名称为 “springboot_mybatis_demo”，创建过程中勾选 “Web”，“MyBatis”，“MySQL”，第一次创建Maven需要下载依赖包(耐心等待) 二.实现2.1创建User类 1234567891011121314151617181920212223242526272829303132package com.woniu.bean; public class User { private long id; private String name; private int age; public long getId() { return id; } public void setId(long id) { this.id = id; } public String getName() { return name; } public void setName(String name) { this.name = name; } public int getAge() { return age; } public void setAge(int age) { this.age = age; } @Override public String toString() { return &quot;User [id=&quot; + id + &quot;, name=&quot; + name + &quot;, age=&quot; + age + &quot;]&quot;; } } 2.2创建UserMapper接口 创建接口UserMapper，并添加@Mapper注解 12345678910111213package com.woniu.mapper; import org.apache.ibatis.annotations.Mapper;import org.apache.ibatis.annotations.Select; import com.woniu.bean.User; @Mapperpublic interface UserMaper { @Select(&quot;select * from user where age = #{age}&quot;) User Select(int age);} 2.3创建controller 12345678910111213141516171819202122package com.woniu.controller; import org.springframework.beans.factory.annotation.Autowired;import org.springframework.web.bind.annotation.RequestMapping;import org.springframework.web.bind.annotation.RestController; import com.woniu.bean.User;import com.woniu.mapper.UserMaper; @RestController@RequestMapping(&quot;/web&quot;)public class WebController { @Autowired private UserMaper mapper; @RequestMapping(&quot;/index&quot;,method=RequestMethod.GET) public User selectAge(@RequestParam(&quot;age&quot;) int age){ return mapper.Select(age); }} 2.4设置application.properties 12345# mysqlspring.datasource.url=jdbc:mysql://localhost/spring_boot_demo?useUnicode=true&amp;characterEncoding=utf-8spring.datasource.username=rootspring.datasource.password=123456spring.datasource.driver-class-name=com.mysql.jdbc.Driver 2.5MySQL中创建对应数据库和表 数据库名：”spring_boot_demo”，表名：”user” 三.测试运行项目测试结果如下： springboot_mybatis_demo资源地址：点击打开链接","link":"/2017/01/13/SB07集成MyBatis/"},{"title":"Spring Boot入门六:日志输出配置log4j2","text":"spring boot支持的日志框架有，logback，Log4j2，Log4j和Java Util Logging，默认使用的是logback日志框架，笔者一直在使用log4j2，并且看过某博主写的一篇这几个日志框架的性能比对，决定仍使用log4j2，本文章主要介绍spring boot集成log4j2日志框架。 一.集成log4j2创建名称为“springboot_log4j2”的工程，打开pom.xml文件，去除logback的依赖包，添加log4j2的依赖包 默认的properties配置对log4j2不够友好，我们应用外部配置文件，在资源文件夹src/main/resources下添加log4j2.xml或者log4j2-spring.xml，启动后spring boot自动加载，配置文件的内容如下： 123456789101112131415161718192021&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&lt;configuration&gt; &lt;properties&gt; &lt;!-- 文件输出格式 --&gt; &lt;property name=&quot;PATTERN&quot;&gt;%d{yyyy-MM-dd HH:mm:ss.SSS} |-%-5level [%thread] %c [%L] -| %msg%n&lt;/property&gt; &lt;/properties&gt; &lt;appenders&gt; &lt;Console name=&quot;CONSOLE&quot; target=&quot;system_out&quot;&gt; &lt;PatternLayout pattern=&quot;${PATTERN}&quot; /&gt; &lt;/Console&gt; &lt;/appenders&gt; &lt;loggers&gt; &lt;logger name=&quot;com.roncoo.education&quot; level=&quot;debug&quot; /&gt; &lt;root level=&quot;info&quot;&gt; &lt;appenderref ref=&quot;CONSOLE&quot; /&gt; &lt;/root&gt; &lt;/loggers&gt; &lt;/configuration&gt; 配置完成重启工程，日志输出格式将使用该配置的格式输出 二.多环境分别使用不同的log4j2的配置文件上篇博客中介绍了不同开发环境使用不同的properties配置文件，我们分别创建dev，test，product环境的properties配置文件和log4j2配置文件。 主properties配置文件中激活指定的properties配置文件，如激活 dev的properties文件只需添加“spring.profiles.active=dev ”即可，这是进入”application-dev.properties”配置文件，在该文件中添加“logging.config=classpath:log4j2-dev.xml”，这时候dev开发环境将使用“log4j2-dev.xml”配置信息来输出日志。 改工程”springboot_log4j2”下载地址：点击打开链接","link":"/2017/01/12/SB06日志输出配置log4j2/"},{"title":"Spring Boot入门五:使用properties配置文件实现多环境配置","text":"实际项目开发过程中会用到多个环境，比如dev，test，product环境，不同的环境可能使用不同参数，为便于部署提高效率，本篇主要通过properties配置文件来实现多环境的配置。 一.多环境配置实现分别创建application-dev.properties，application-test.properties，application-pro.properties配置文件，分别代表dev，test和product环境的配置文件。 主配置文件application.properties中添加配置激活选项，例如激活dev环境的配置为： spring.profiles.active=dev这时application-dev.properties配置文件生效，如果主配置文件application.properties和dev配置文件application-dev.properties中有相同的配置信息，那么application-dev.properties中的生效。 二.运行jar指定配置文件启动指定dev配置文件生效 java -jar *.jar --spring.profiles.active=dev 该工程springboot_properties_multienv下载地址：点击打开链接","link":"/2017/01/11/SB05使用properties配置文件实现多环境配置/"},{"title":"Spring Boot入门四:配置文件详解properties","text":"一.配置随机数，使用随机数在application.properties文件添加配置信息 #32位随机数 woniu.secret=${random.value} #随机整数 woniu.number=${random.int} #指定范围随机数 woniu.limitnumber=${random.int[0,9]} controller类中使用这些随机数 1234567891011121314151617181920212223242526272829303132package com.woniu.controller; import java.util.HashMap;import java.util.Map; import org.springframework.beans.factory.annotation.Value;import org.springframework.web.bind.annotation.RequestMapping;import org.springframework.web.bind.annotation.RestController; @RestController@RequestMapping(value=(&quot;/web&quot;))public class WebController { @Value(value=&quot;${woniu.secret}&quot;) private String uuid; @Value(value=&quot;${woniu.number}&quot;) private int randomID; @Value(value=&quot;${woniu.limitnumber}&quot;) private int limitnumber; @RequestMapping(value=&quot;/index&quot;) public Map&lt;String, Object&gt; Index(){ Map&lt;String, Object&gt; map = new HashMap&lt;String, Object&gt;(); map.put(&quot;uuid&quot;, uuid); map.put(&quot;randomID&quot;, randomID); map.put(&quot;limitnumber&quot;, limitnumber); return map; }} 二.属性占位符使用application.properties配置文件中先前定义的值 12woniu.name=&quot;woniu&quot;woniu.desc=${woniu.name} is a domain name 三.application.properties文件的优先级 相同的配置信息在配置在application.properties中，优先级高的生效 四.其他配置介绍12345678#配置tomcat的端口server.port=8080#时间格式化spring.jackson.date-format=yyyy-MM-dd HH:mm:ss#时区设置spring.jackson.time-zone=Asia/Chongqing","link":"/2017/01/10/SB04配置文件详解properties/"},{"title":"Spring Boot入门三:使用devtools实现热部署","text":"Eclipse下使用spring-tool-suite插件创建一个spring boot 工程，通过右键“Run As”—&gt;”Spring Boot App”来启动工程，这时当我们对工程的内容进行修改的时候，需要重新操作刚才的步骤来重启功能，为提高开发效率，我们可以通过使用devtools来实现热部署，修改内容后直接重新加载启动。 一.启动devtools创建一个springboot_devtools_demo工程，工程创建完成后，鼠标放在工程目录上点击右键“Spring Tools”—&gt;”Add Boot Devtools” 点击完成后，pom.xml文件中会增减依赖： 1234&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-devtools&lt;/artifactId&gt;&lt;/dependency&gt; 同时工程名称也会增加debtools标签： 这时对类，配置文件或页面进行修改，ctrl+s保存后会自动重新部署。 二.关闭devtools如果想取消热部署，可以右键“Spring Tools”–&gt;Remove Boot Devtools即可。","link":"/2017/01/10/SB03使用devtools实现热部署/"},{"title":"Spring Boot入门二:创建第一个web工程Hello World","text":"一.创建工程创建名称为”springboot_helloworld”的spring boot工程， new-&gt;Spring Starter Project，直接上图 点击“Finish”后需要耐心等待，这时Maven会自动下载所需spring boot的依赖包。所有的依赖如下： 二.开始编码2.1 新建WebController 1234567891011121314package com.woniu.controller; import org.springframework.web.bind.annotation.RequestMapping;import org.springframework.web.bind.annotation.RestController; @RestController@RequestMapping(value=&quot;/index&quot;)public class WebController { @RequestMapping(value=&quot;/hello&quot;) public String helloworld(){ return &quot;hello world!&quot;; }} 2.2 启动工程 三.测试","link":"/2017/01/08/SB02创建第一个web工程helloworld/"},{"title":"Spring Boot入门一:Eclipse安装spring-tool-suite插件","text":"一直使用eclipse，个人习惯选用Eclipse+spring-tool-suite进行开发，特别注意Eclipse要选用对应的spring-tool-suite进行安装，这点笔者浪费了好长时间，以下为对应的版本。 eclipse-kepler.4.3.1–&gt;springsource-tool-suite-RELEASE-e4.3.1-updatesite.zip eclipse-Mars.4.5.1–&gt;springsource-tool-suite-3.7.2RELEASE-e4.5.1-updatesite.zip eclipse-Mars.4.5.2–&gt;springsource-tool-suite-3.7.3RELEASE-e4.5.2-updatesite.zip eclipse-neno.4.6–&gt;springsource-tool-suite-3.7.3RELEASE-e4.6-updatesite.zip 直接百度Eclipse和对应的spring-tool-suite，切记版本要对应。 安装Eclipse — Help— Install new Sofware 点击Add按钮 ，再点击Archive 选择你刚刚下载的zip文件 直接上图简洁明了： 如果小伙伴们不想浪费时间安装STS插件，给大家送上福利，已经安装好spring-tool-suite插件的各个eclipse版本，直接下载使用： 百度云盘：链接: https://pan.baidu.com/s/1brbHqYr 密码: 92f8 特别说明：spring boot构建使用的是maven，这点对应学spring boot的人来说想必无需再啰嗦了","link":"/2017/01/08/SB01Eclipse安装spring-tool-suite插件/"},{"title":"指针函数与函数指针","text":"指针函数指针函数是一个函数，只不过指针函数返回的类型是某一类型的指针。 格式： 类型名* 函数名(函数参数列表) 如下代码存在问题 12345678910111213void test(char *p){ p = (char*)malloc(10); return;}int main(){ char* p1 = NULL; test(p1); return 1;} test函数执行完后，p1仍为NULL，调用test函数，实参p1为值传递，即使函数内申请的内存，函数外不会得到，可以使用函数指针的形式进行修改，如下： 1234567891011121314char* test(){ char* p = (char*)malloc(10); memset(p, 0, 10); return p;}int main(){ char* p1 = NULL; p1 = test(); return 1;} 函数指针函数指针是指向函数的指针变量。所以函数指针其实是指针变量，只不过该指针变量指向函数。 格式： 类型名 (*指针变量名) (函数参数列表)函数指针的用途： a.调用函数 b.做函数的参数.调用函数使用： 1234567891011121314151617181920212223/** 函数指针，调用函数*/ int fun1(int a, int b){ return a + b;} typedef int(FUNC*)(int a,int b) int main(){//方式一 int(*p)(int, int); p = fun1; printf(&quot;%d\\n&quot;, p(1, 5));//方式二 FUNC f = fun1; printf(&quot;%d\\n&quot;, f(1,5)); getchar(); return 1;} 函数参数使用： 1234567891011121314151617181920/** 函数指针，最为参数*/ int fun2(int a, int b){ return a + b;} int fun3(int a, int b, int(*f)(int, int)){ return f(a, b);} int main(){ printf(&quot;%d\\n&quot;, fun3(1, 5, fun2)); getchar(); return 1;}","link":"/2015/07/24/16指针函数与函数指针/"},{"title":"指针数组与数组指针","text":"指针数组：存储指针的数组，数组找那个的每个一元素都是指针 例： int* p1[4]，p2[0]是一个指向int类型的指针 char* p2[4]，p1[0]是一个指向char类型的指针 数组指针：指向数组的指针 例： int (*p)[4] 这里需要注意下 int a[3] = {1, 2, 3); int (*p)[3] = a; //错误，a为数组元素的首地址 int (*p)[3] = &a; //正确，数组的首地址 虽然数组元素首地址和数组首地址的值是相同的，但两者表示的意义是不同的，如写成数组元素首地址，编译过程中编译器会直接报错。 1234567891011121314//指针数组使用 int a1 = 1; int a2 = 2; int a3 = 3; int *p1[3]; p1[0] = &amp;a1; p1[1] = &amp;a2; p1[2] = &amp;a3; char *p2[3] = {&quot;i love china&quot;, &quot;i love beijing&quot;, &quot;i love changcheng&quot;}; printf(&quot;%d\\n&quot;, *p1[0]); printf(&quot;%s\\n&quot;, p2[0]); 12345678910//数组指针使用 int b[] = {1, 2, 3}; int (*p3)[3]; p3 = &amp;b; printf(&quot;%d\\n&quot;, (*p3)[0]); char c[][4] = {&quot;aaa&quot;, &quot;bbb&quot;, &quot;ccc&quot;}; char (*p4)[4]; p4 = c; printf(&quot;%s\\n&quot;, p4[0]);","link":"/2015/07/24/15指针数组和数组指针/"},{"title":"赋值兼容","text":"赋值兼容的规则时在需要使用基类对象的任何地方都可以使用公有派生类对象来替代。公有继承派生类可获得基类中除构造函数，析构函数外的所有成员，能用基类解决的问题，派生类也能解决。更直白点说，如果一个类是从一个基类公有继承过来，那么这个派生类就可以替代基类，反过来基类不能替代派生类。 常用赋值兼容情况： 1.派生类对象赋值给基类对象。 2.派生类对象初始化基类对象引用。 3.派生类对象地址赋值给指向基类对象指针。12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152#include &lt;iostream&gt; using namespace std; class Father{public: void show() { cout &lt;&lt; &quot;Father show()&quot; &lt;&lt; endl; } void showFather() { cout &lt;&lt; &quot;showFather()&quot; &lt;&lt; endl; }}; class Son : public Father{public: void show() { cout &lt;&lt; &quot;Son show()&quot; &lt;&lt; endl; } void showSon() { cout &lt;&lt; &quot;showSon()&quot; &lt;&lt; endl; }}; int main(){ Father father1; Son son1; father1 = son1; //子类对象赋值给父类对象 father1.show(); //调用父类中的show()方法 father1.showFather(); //调用父类中的showFather()方法 Son son2; Father&amp; father2 = son2; //子类对象初始化父类对象引用 father2.show(); //调用父类中的show()方法 father2.showFather(); //调用父类中的showFather()方法 Son son3; Father* father3 = &amp;son3;//子类对象地址赋值给指向父对象指针 father3-&gt;show(); //调用父类中的show()方法 father3-&gt;showFather(); //调用父类中的showFather()方法 getchar();}","link":"/2015/07/18/14赋值兼容/"},{"title":"虚继承","text":"由于多重继承产生的二义性引入了类的虚继承，先看下什么是二义性。 类D是类B和类C的派生类，而类B，类C就是继承于类A，当D调用类A中的函数时不知道是类B继承A的，还是类C继承A的，引起了二义性。虚继承可以解决这个问题。 使用语法： 123class 派生类:virtual 继承方式 虚基类{}; 上图中类D 实例化过程中的初始化顺序： 祖父类(A)—&gt;父类(从左到又)—&gt;子类，并且最后一次初始化有效 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677#include &lt;iostream&gt;#include &lt;string&gt; using namespace std; class A{public: A(int a):i(a) { cout &lt;&lt; &quot;construct A&quot; &lt;&lt; endl; } void displaya() { cout &lt;&lt; &quot;A:&quot; &lt;&lt; i &lt;&lt; endl; }private: int i;}; class B:virtual public A //虚继承{public: B(int a): A(a),i(a) { cout &lt;&lt; &quot;construct B&quot; &lt;&lt; endl; } void displayb() { cout &lt;&lt; &quot;B:&quot; &lt;&lt; i &lt;&lt; endl; }private: int i;}; class C:virtual public A //虚继承{public: C(int a):A(2),i(a) { cout &lt;&lt; &quot;construct C&quot; &lt;&lt; endl; } void displayc() { cout &lt;&lt; &quot;C:&quot; &lt;&lt; i &lt;&lt; endl; }private: int i;}; class D: public B, public C //多重继承{public: D(int a, int b, int c, int d):A(a), B(b), C(d), i(c) //必须初始化虚基类X,X(d) { cout &lt;&lt; &quot;construct Z&quot; &lt;&lt; endl; } void displayd() { cout &lt;&lt; &quot;D:&quot; &lt;&lt; i &lt;&lt; endl; } private: int i;}; int main(){ D d(1,2,3, 4); d.displaya(); d.displayb(); d.displayc(); d.displayd();} 运行结果： 编译器在实例化D时，之调用了一次虚基类的构造函数，忽略了虚基类A派生类B，C对续虚基类构造函数的调用，保证了虚基类的数据成员不会被初始化多次。","link":"/2015/07/18/13虚继承/"},{"title":"类的继承","text":"面向对象的设计思想，类对数据做了封装，并可以加入访问权限，类的继承是面向对象思想的精髓。类的继承可以让新类从以有的类中获得已有的特征。原有类称为基类或父类，新类称为派生类或子类。 语法： 1234class 子类类名：[继承方式] 父类类名{ } ; 继承的方式有三种： 1.共有继承：(使用最广泛) 在派生类中原来的公有成员，保护成员身份不变。原私有成员仍不可访问。 2.私有继承： 在派生类中原来的公有成员，保护成员都称为了保护成员。原私有成员仍不可访问。 3.保护继承：在派生类中原来的公有成员，保护成员都称为了私有成员。原私有成员仍不可访问。 派生类的构造函数和析构函数派生类继承基类过程中，基类的构造函数和析构是不能继承下来的。所以，派生类必须设置自己的构造函数和析构函数。 派生类构造函数语法： 1234派生类名::派生类名(参数):基类名(参数),派生类新成员(){ } 构造调用顺序： 基类构造---&gt;派生类构造析构函数调用顺序 派生类析构---&gt;基类析构代码演示： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667#include &lt;iostream&gt;#include &lt;string&gt; using namespace std; class Man{public: Man(string sn, int i):name(sn),age(i) { cout &lt;&lt; &quot;Man construct&quot; &lt;&lt; endl; } ~Man() { cout &lt;&lt; &quot;Man destruct&quot; &lt;&lt; endl; } void dis() { cout &lt;&lt; &quot;ame:&quot; &lt;&lt; name &lt;&lt; endl; cout &lt;&lt; &quot;age:&quot; &lt;&lt; age &lt;&lt; endl; }private: string name; int age;}; class Birthday{public: Birthday(int y, int m):year(y), month(m) { cout &lt;&lt; &quot;Birthday construct &quot; &lt;&lt; endl; } ~Birthday() { cout &lt;&lt; &quot;Birthday destruct &quot; &lt;&lt; endl; }private: int year; int month;}; class Student:public Man{public: Student(string name, int age, float fs):Man(name, age),bday(10, 10),_score(fs) { cout &lt;&lt; &quot;Student construct&quot; &lt;&lt; endl; } ~Student() { cout &lt;&lt; &quot;Student destruct&quot; &lt;&lt; endl; }private: float _score; Birthday bday;}; int main(){ Student stu(&quot;wpf&quot;, 18, 100); stu.dis();} 运行结果： 同名隐藏子类中定义了与父类同名的方法（不管参数），子类的该方法将会隐藏掉所有的父类的同名方法； 12345678910111213141516171819202122232425262728293031 class Father{public: void show() { cout &lt;&lt; &quot;Father show()&quot; &lt;&lt; endl; } void show(int a) { cout &lt;&lt; &quot;Father show(int a)&quot; &lt;&lt; endl; }}; class Son : public Father{public: void show() { cout &lt;&lt; &quot;Son show()&quot; &lt;&lt; endl; }}; int main(){ Son son; son.show(); //调用子类中的方法 son.show(1); //父类中的同名方法，void show(int a)被隐藏，无法调用 getchar();} 多继承多继承是的新建的获得多个类(&gt;=2)中获得已有的特征， 并非所有面向对象的语言都有这种语法，如Java，C#取消了多继承，多继承可能引起多种问题，如二义性等。 多继承语法： 1234派生类名:public 基类名1，public 基类名2{ }; 代码演示： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263#include &lt;iostream&gt;#include &lt;string&gt; using namespace std; //基类Xclass X{public: X(int a):i(a) { cout &lt;&lt; &quot;construct X&quot; &lt;&lt; endl; } void displayX() { cout &lt;&lt; &quot;X:&quot; &lt;&lt; i &lt;&lt; endl; }private: int i;}; //基类Yclass Y{public: Y(int a):i(a) { cout &lt;&lt; &quot;construct Y&quot; &lt;&lt; endl; } void displayY() { cout &lt;&lt; &quot;Y:&quot; &lt;&lt; i &lt;&lt; endl; }private: int i;}; //派生类Zclass Z: public X, public Y{public: Z(int a, int b, int c):X(a), Y(b), i(c) { cout &lt;&lt; &quot;construct Z&quot; &lt;&lt; endl; } void displayZ() { cout &lt;&lt; &quot;Z:&quot; &lt;&lt; i &lt;&lt; endl; } private: int i;}; int main(){ Z z(1,2,3); z.displayX(); z.displayY(); z.displayZ();} 运行结果：","link":"/2015/07/18/12类的继承/"},{"title":"友元","text":"C++封装的类增加了对类中数据成员的访问限制，从而保证了安全性。如想访问类中的私有成员需要通过类中提供的公共接口来访问，这样间接的访问方式，无疑使得程序的运行效率有所降低。 友元的提出可以使得类外的函数来访问类中的私有成员，保护成员。 友元的使用分为三类： 1.类外的普通函数声明为该类的友元函数。 格式： friend 类型 函数名(形参)2.其他类的成员函数声明为该类的友元函数。 格式：friend 类型 类名::函数名(形参)3.其他类为该类的友元类，这样类中的所有成员函数都是该类的友元函数。 格式：friend class 类名代码演示： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071#include &lt;iostream&gt;using namespace std;class A;class B{public: //类B的成员函数为类A的友元函数 void display(A &amp;a);};class C{public: //类C是类A的友元类 void display(A &amp;a);};class A{public: A(int i):x(i){} int getX() { return x; } friend void display(A &amp;a); friend void B::display(A &amp;a); friend C;private: int x;};//类外普通函数为类A的友元函数void display(A &amp;a){ cout &lt;&lt; a.x &lt;&lt; endl; //友元函数直接访问类中的私有成员}void B::display(A &amp;a){ cout &lt;&lt; a.x &lt;&lt; endl;}void C::display(A &amp;a){ cout &lt;&lt; a.x &lt;&lt; endl;}int main(){ A a(18); //无法直接访问类A的私有变量x，需要通过对外提供的函数来访问 cout &lt;&lt; a.getX() &lt;&lt; endl; //类B的成员函数为类的A的友元函数 B b; b.display(a); //类C是类A的友元类 C c; c.display(a); return 0;} ###总结： 1.友元声明在类中，但并不属于该类的成员。 2.友元的关系不能继承。 3.在类的任何位置声明友元都行，不受访问权限限制。 4.友元关系提高了程序效率，但破坏了数据的安全性。慎重使用。 5.友元的关系是单向。如类B是类A的友元，反过来类A不一定是类B的友元，看类B中是否有声明。","link":"/2015/07/17/11友元/"},{"title":"const关键字","text":"C++中const关键字无处不在，我这里做下汇总，作为工具文章方便翻阅。 一：修饰数据成员修饰的成员一单定义初始化后不能再进行修改，如： const int a = 10; a =20; //重新赋值直接会报错 当修饰类的成员函数时，先来段错误的代码 12345678910class Student{public: Student(int i) { this-&gt;age = i; //age是const类型直接复制会报错 }private: const int age;}; 解决上面的错误有两种方法 方法一：使用参数列表的形式(推荐使用) 12345678910class Student{public: Student(int i):age(i) { }private: const int age;}; 方法二：定义age时直接赋值 12345678class Student{public: Student ();private: const int age = 20;}; 二：修饰成员函数在声明之后，实现体之前 格式为： 类型 函数名(参数….) const const修饰的成员函数不能修改类中的成员函数，函数中只能调用const修饰的函数。 123456789101112131415161718192021class Student{public: Student (int i ):age(i) { } void update () const { age = age +1; //const 修饰的成员函数不能修改类中的成员变量 display(); //const 修饰的成员函数，函数中只能调用const修饰的成员函数 } void display() { cout &lt;&lt; &quot;age:&quot; &lt;&lt; endl; }private: int age;}; 三：修饰类对象const修饰的对象，只能调用const修饰的成员函数 12345678910111213141516171819202122232425262728class Student{public: Student (int i ):age(i) { } void update () const { cout &lt;&lt; &quot;this is update&quot; &lt;&lt; endl; } void display() { cout &lt;&lt; &quot;age:&quot; &lt;&lt; endl; }private: int age;};int main(){ const Student stu(30); stu.update(); stu.display(); //const修饰的类对象 只能调用const修饰的成员函数 return 1;} 成员函数有无const修饰可以构成重载，非const对象调用时优先调用非const修饰的成员函数，如不构成重载也可以调用const修饰成员函数。 12345678910111213141516171819202122232425262728class Student{public: Student (int i ):age(i) { } void display() { cout &lt;&lt; &quot;void display()&quot; &lt;&lt; endl; } void display() const { cout &lt;&lt; &quot;display() const&quot; &lt;&lt; endl; }private: int age;};int main(){ Student stu(30); stu.display(); return 1;} 输出结果：","link":"/2015/07/17/10const关键字/"},{"title":"拷贝构造函数，浅拷贝和深拷贝","text":"拷贝构造函数是一种特殊的构造函数，遵循如下的规则： 1.函数名和类名一致，没有返回值。 2.必须有一个参数，参数是本类型的一个引用变量。 3.拷贝构造函数可以访问参数对象的任意成员(private也可以)。 4.若自己不提供拷贝构造函数，系统会提供默认构造函数，若自己定义，系统将不再提供。 5.系统提供的拷贝构造是浅拷贝。书写示例如下： 123456789101112class Student{public: //构造函数 Student(int a, char* p); //拷贝构造函数 Student(const Student&amp; stu); char name[32]; int age;}; 拷贝构造函数调用1234567//调用方法1Object obj1;Object obj2(obj1); //或者写成:Object obj2 = obj1;//调用方法2Object obj1;Object* obj2 = new Object(obj1); 浅拷贝浅拷贝不开辟新空间，只增加一个指针，指向原有的内存。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748#include &lt;iostream&gt;using namespace std; class Student{public: //构造函数 Student(const char* myName) { int len = strlen(myName); name = new char[len + 1]{0}; strcpy_s(this-&gt;name, len+1, myName); cout &lt;&lt; &quot;构造：&quot; &lt;&lt; hex &lt;&lt; (int)name &lt;&lt; endl; } //析构函数 ~Student() { if (name) { cout &lt;&lt; &quot;析构：&quot; &lt;&lt; hex &lt;&lt; (int)name &lt;&lt; endl; delete[] name; name = NULL; } } //拷贝构造函数（浅拷贝） Student(const Student&amp; stu) { name = stu.name; cout &lt;&lt; &quot;调用拷贝构造函数&quot; &lt;&lt; endl; } private: char* name;}; int main(){ { Student stu1(&quot;hongshaorou&quot;); Student stu2(stu1); } } 运行过程中发生了崩溃 是因为对相同的内存地址做了两次析构导致，打印出内存地址一目了然。 深拷贝深拷贝会开辟新的内存空间，把原有的对象复制过来。见下图： 对上边浅拷贝代码进行修改 123456789101112131415161718192021222324252627282930313233343536class Student{public: //构造函数 Student(const char* myName) { int len = strlen(myName); name = new char[len + 1]{0}; strcpy_s(this-&gt;name, len+1, myName); cout &lt;&lt; &quot;构造：&quot; &lt;&lt; hex &lt;&lt; (int)name &lt;&lt; endl; } //析构函数 ~Student() { if (name) { cout &lt;&lt; &quot;析构：&quot; &lt;&lt; hex &lt;&lt; (int)name &lt;&lt; endl; delete[] name; name = NULL; } } //拷贝构造函数（深拷贝） Student(const Student&amp; stu) { int len = strlen(stu.name); name = new char[len + 1]; strcpy_s(name, len + 1, stu.name); cout &lt;&lt; &quot;调用拷贝构造函数&quot; &lt;&lt; hex &lt;&lt; (int)name&lt;&lt; endl; } private: char* name;}; 再次运行不会发生崩溃现象，打印内存地址可见，开辟了内存空间。","link":"/2015/07/17/09拷贝构造函数，浅拷贝和深拷贝/"},{"title":"构造函数与析构函数","text":"1.构造函数是种特殊的类成员函数，遵循如下规则： a.函数名与类名必须相同。 b.没有返回值 12345678910例如：class Obj{...public: Obj() { ... }}; 2.构造函数可以带参数，也可以重载 12345678910111213class Obj{...public: Obj() { ... } Obj(int x, int y) { ... }}; 3.构造函数和普通成员函数不一样，一般不显示调用。在创建一个对象时，构造函数自动调用(编译器来完成)。 析构函数(destructor)1.析构和构造是一对相反的过程，对象被创建时调用构造函数，对象被销毁时调用析构函数，遵循如下规则： a.名称固定，类名前加上波浪线~ b.没有返回值 c.不能带参数12345678例如，class Obj{public: ~Obj() { }}; 2.析构函数只能有一个，不允许重载。 3.析构函数不显示调用，对象销毁时编译器自动调用。 重新实现链表(使用类，构造和析构函数)创建DataObj.h头文件 1234567891011121314151617181920212223#ifndef _OBJECT_H_#define _OBJECT_H_ struct Student{ char name[32]; int age; Student* pNext;}; class DataObj{public: DataObj(); ~DataObj(); void add(Student* pStu); void find(int age); void printNode(Student* pNode);private: Student m_head;}; #endif 创建DataObj.cpp源文件 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788#include &lt;stdio.h&gt;#include &lt;string.h&gt;#include &lt;stdlib.h&gt;#include &quot;DataObj.h&quot; //构造有头链表DataObj::DataObj(){ m_head.pNext = NULL;}DataObj::~DataObj(){ //指向每个节点的头部 Student* p = m_head.pNext; //释放所有节点 while(p) { Student *next = p-&gt;pNext; free(p); p = next; } } void DataObj::add(Student* pNode){ //指向每个节点的头部 Student* p = &amp;m_head; //通过头节点查找到链表尾部节点 while (p) { if (p-&gt;pNext == NULL) { break; } p = p-&gt;pNext; } //添加节点到尾部 p-&gt;pNext = pNode;}void DataObj::find(int age){ //标记是否找到 bool bFind = false; Student* p = &amp;m_head; while(p) { if (p-&gt;age == age) { bFind = true; printNode(p); } p = p-&gt;pNext; } if (!bFind) { printf(&quot;没有找到该age的节点&quot;); }}void DataObj::printNode(Student* pNode){ printf(&quot;name = %s, age = %d\\n&quot;, pNode-&gt;name, pNode-&gt;age);} int main(){ //构造节点 Student* pStu = (Student*) malloc(sizeof(Student)); strcpy(pStu-&gt;name, &quot;aaaa&quot;); pStu-&gt;age = 30; pStu-&gt;pNext = NULL; { DataObj dataObj; //添加节点 dataObj.add(pStu); //查找节点 dataObj.find(31); } return 1;}","link":"/2015/07/17/08构造函数与析构函数/"},{"title":"类的分离式写法","text":"类的分离式写法，使得代码更加规范，增强了阅读性。 分离式写法的规则： 1.类的变量：写在类的里面 2.成员函数：类中写函数的声明，函数的定义写在类体外。 3.写在类外函数定义时，类名前加限定(Object: :)，其中， ::理解为表示范围的符号。 代码演示头文件：Object.h 12345678910111213141516#ifndef _OBJECT_H_#define _OBJECT_H_ class Student{private: char name[32]; int age; public: void SetName(char* pName); void SetAge(int age); void Printf_Stu();}; #endif 源文件：Object.cpp 12345678910111213141516171819202122232425262728#include &lt;stdio.h&gt;#include &lt;string.h&gt;#include &quot;Object.h&quot; void Student::SetName(char* pName){ strcpy(this-&gt;name, pName);} void Student::SetAge(int age){ this-&gt;age = age;} void Student::Printf_Stu(){ printf(&quot;name = %s, age = %d\\n&quot;, this-&gt;name, this-&gt;age);} int main(){ Student stu; stu.SetName(&quot;aaaa&quot;); stu.SetAge(30); stu.Printf_Stu(); return 1;}","link":"/2015/07/17/07类的分离式写法/"},{"title":"命名空间(namespace)","text":"命名空间可以解决程序中的同名冲突，尤其大型项目多人开发中经常用到。比如我们使用C++的标准输出std::cout就使用了std命名空间。 使用作用域符:: 123456789101112131415161718192021#include &lt;iostream&gt; using namespace std; int var = 10; void foo(){ cout &lt;&lt; &quot;this is foo&quot; &lt;&lt; endl;} int main(){ int var = 20; cout &lt;&lt; var &lt;&lt; endl; //输出局部变量 cout &lt;&lt; ::var &lt;&lt; endl; //输出全局变量 foo(); //不加作用域符 ::foo(); //加作用域符 return 0;} 命名空间会对全局的变量和函数进行作用域打包。 在某些第三方库中是有namespace的，因此我们在使用这些库的时，要确定是否使用using namespace来解除名字前缀。 使用语法： 12345678910namespace XXX{ int var = 10; class A { public: ... };} //没有分号 使用假设有命名空间namespace Animal； 12345678namespace Animal { int age = 10; void action() { cout &lt;&lt; &quot;eatiing&quot; &lt;&lt; endl; }} 用法一：直接使用命名空间成员 12cout &lt;&lt; Animal::age &lt;&lt; endl;Animal::action(); 用法二： using使用命名空间成员 12using Animal::age;cout &lt;&lt; age &lt;&lt; endl; 用法三：使用命名空间全部成员 123using namespace Animal;cout &lt;&lt; age &lt;&lt; endl;foo(); 同时命名空间也支持嵌 1234567891011121314151617181920#include &lt;stdio.h&gt;namespace XXX{ class A { public: void test() { printf(&quot;this is namespace XXX class A\\n&quot;); } };}using namespace XXX; int main(){ A* p = new A(); p-&gt;test(); return 1;} 相同的命名空间编译时会合并 12345678910111213141516171819#include &lt;iostream&gt; using namespace std; namespace Space { int a = 10;} namespace Space { int b = 20;} using namespace Space;int main(){ cout &lt;&lt; &quot;a = &quot; &lt;&lt; a &lt;&lt; endl; cout &lt;&lt; &quot;b = &quot; &lt;&lt; b &lt;&lt; endl; return 0;}","link":"/2015/07/17/06命名空间(namespace)/"},{"title":"动态分配内存(malloc, free)","text":"操作系统中存在一个内存管理器(Memory Manager)，简称MM，它负责管理内存。 MM提供的服务：应用程序可以向MM申请一块指定大小的内存(借出)，用完之后应用程序应该释放(还回)。 所需头文件 &lt;stdlib.h&gt; 123如：void* p = malloc(1024);//申请，从MMM借出内存free(p); //释放，还回MM 1.MM管理的内存区域成为堆(Heap)。 2.只要应用malloc，MM都会借出，如应用不归还，MM也不会主动要求你free。如果有个应用不停地malloc，而不free，最终会用光MM的内存。 当MM没有更多闲置内存时，malloc返回NULL，表明内存已经用完。 malloc函数123456void* malloc(int size) 参数size：指定要申请内存空间大小 返回值：void*，指向这一块内存地址。(MM不关心你拿这块内存来存储何种数据，所以返回void*)(MM不关心你拿这块内存来存储何种数据，所以返回void*) (MM不关心你拿这块内存来存储何种数据，所以返回void*) free函数1234void free(void* ptr) 参数ptr: 先前malloc返回的内存地址 返回值: void* ，指向这一块内存地址 使用举例123456789101112131415161718192021222324252627#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;string.h&gt; class Object{public: int a; int b; char name[32];}; int main(){ //申请堆内存 Object *object = (Object *)malloc(sizeof(Object)); //存放数据 object-&gt;a = 1; object-&gt;b = 5; strcpy(object-&gt;name, &quot;wpf&quot;); //释放内存 free(object); object = NULL; //良好的编程风格 return 1;}","link":"/2015/07/17/05动态分配内存(malloc,free)/"},{"title":"new和delete","text":"1.malloc,free和new,delete区别。 &emsp;a.malloc,free是C/C++的标准库函数。new,delete是c++的操作符。 &emsp;b.malloc申请的是内存，严格意义不是“对象”，new申请的可以理解为“对象”，new 时会调用构造函数，返回指向该对象的指针。 &emsp;c.对于class类型，必须用new/delete来创建和销毁，自动调用构造和析构函数，malloc/free无法胜任。 2.使用new遵循原则： &emsp;a.用new申请的内存，必须用delete释放。 &emsp;b.用new[]申请的内存，必须用delete[]释放。 &emsp;c.delete释放内存后，指针值不变，良好的风格是释放后指针置为NULL，如,delete p； p = NULL。 使用1.申请一个对象 123int* p1 = new int;delete p1;p1 = NULL; 2.申请多个对象 123int* p1 = new int[12];delete[] p1;p1 = NULL; 3.申请一个长度为1024的char数组 1234567char* pArray = new char[1024];for (int i=0; i &lt; 1024; i++){ pArray[i] = i;}delete[] pArray;pArray = NULL; 4.申请一个类对象 123456789101112131415#include &lt;stdio.h&gt; class Student{public: char name[32]; int age;};int main(){ Student* pStu = new Student(); delete pStu; pStu = NULL; return 1;} 5.申请1024个类对象 123456789101112131415161718192021222324252627#include &lt;stdio.h&gt; class Student{public: int age; Student() { ... } ~Student() { ... }}; int main(){ Student* pStu = new Student[1024]; for (int i=0; i&lt;1024; i++) { pStu[i].age = i+1; } delete[] pStu; pStu = NULL; return 1;} new多个对象不能传参数，要求该类必须有默认构造函数。","link":"/2015/07/17/04new和delete/"},{"title":"内联函数","text":"函数的使用使得相同代码不必多次重写，但会带来额外的开销，函数调用的过程中会有入栈和出栈，这些都会消耗时间。 如果一个函数在程序运行过程中被成千上万次调用，那么这个开销也是不容忽视的，C++中引入了内联函数，直接在函数前面加上inline，在编译过程中直接把函数代码内嵌，避免了运行过程中的函数调用，但会增加程序代码段的空间。可以任务以空间来换取时间。 示例1234inline int foo(int a, int b) { return a+b; } ###总结内联函数优点：程序运行时避免了调用函数入栈，出栈导致的额外开销。 内联函数缺点：编译时直接函数代码内嵌，增加了代码段空间。 一般函数体行数不多(谷歌编程规范明确指出内联函数不超过10行代码)，且被频繁调用的函数适合用内联函数。","link":"/2015/07/17/03内联函数/"},{"title":"函数重载","text":"函数重载指在相同作用域中多个函数名相同，函数的形参不同。 遵循规则： 1.函数名相同 2.函数的参数，类型，个数或顺序不一样都可以构成重载。 3.函数返回值得类型不同不构成重载，编译直接报错，存在二义性(ambiiguous) 12345678910111213141516171819202122232425262728293031#include &lt;iostream&gt; using namespace std; void foo(int a){ cout &lt;&lt; &quot;foo(int a)&quot; &lt;&lt; endl;} void foo(int a, int b){ cout &lt;&lt; &quot;foo(int a, int b)&quot; &lt;&lt; endl;} void foo(double a, int b){ cout &lt;&lt; &quot;foo(double a, int b)&quot; &lt;&lt; endl;} int main(){ int a = 1; int b = 2; int c = 6.8; foo(a); foo(a, b); foo(c, b); return 0;} 运行结果： 实现原理C++的重载使用了name mangling技术，有人翻译成命名粉碎，命名倾轧等。编译器会把原有的名字与其参数结合生成一个新的名字。 验证：把上文源码文件编译成目标namemangling.o，使用nm指令查看该文件：","link":"/2015/07/16/02函数重载/"},{"title":"标准输入与标准输出","text":"概述C语言中使用函数scanf和printf作为标准输入和输出，在C++中引入了类cin和cout进行标准输入和输出，所需头文件为，命名空间是std。这里所说的标准输入和输出是相对程序而言，输入是通过IO设备，如键盘输入到程序，输出是指输出到IO设备，如程序输出到屏幕。 标准输入cin是标准输入流对象，是istream类的对象。cin是从缓冲区读取数据，如果缓冲区数据为空，cin对象的成员函数就会阻塞等待数据到来，直到检测到缓冲区有数据了才去读取。 开发过程中经常用到cin &gt;&gt;abc, cin.get()，cin.getline() cin&gt;&gt;abcabc为cin接受的类型，经常用到的是变量，先看张图： 12345678910111213141516#include &lt;iostream&gt; using namespace std; int main(){ int a; short b; char c; cin &gt;&gt; a &gt;&gt; b &gt;&gt; c; cout &lt;&lt; a &lt;&lt; endl; cout &lt;&lt; b &lt;&lt; endl; cout &lt;&lt; c &lt;&lt; endl;} 运行输入11[空格/回车]22[空格/回车]a[回车]，程序输出结果如下： cin.get()表示获取输入的一个字符，常用方式如下： 1234567char a;a = cin.get();cout &lt;&lt; a &lt;&lt; endl; char b;cin.get(b);cout &lt;&lt; b &lt;&lt; endl; cin.getline():表示读取多个字符，包括空白字符。直到读满N-1个，或遇到指定的结束符为止。可以指定结束符，默认结束符为’\\0’。 用法： cin.getline(字符指针(char*),字符个数N(int),结束符(char)); 123456789//使用默认结束符char a[32] = {0};cin.getline(a, 3);cout &lt;&lt; a &lt;&lt; endl; //指定结束符为&apos;p&apos;char b[32] = {0};cin.getline(b, 12, &apos;p&apos;);cout &lt;&lt; b &lt;&lt; endl; 标准输出cout是标准输入流对象，是ostream类的对象。 cout对象属性包括一个插入运算符(&lt;&lt;)，右侧的信息可以插入到流中。 12//简单使用cout &lt;&lt; &quot;this is cout!&quot; &lt;&lt; endl; //控制符endl，光标会另起一行 进制输出： dec:十进制输出整数，效果所及：长效，头文件： hex:十六进制输出整数，效果所及：长效，头文件： oct:八进制输出整数，效果所及：长效，头文件： 长效意思：设置后对以后所有的输入输出有效，直到重新设置为止。 短效：只对当前输入输出有效。 setbase(n) :表示以 n 进制显示，头文件&lt; iomanip &gt; 中，n 只能取 8, 10, 16 三个值 12345678910111213141516int a = 28; //十进制输出cout &lt;&lt; dec &lt;&lt; a &lt;&lt; endl;//十六进制输出cout &lt;&lt; hex &lt;&lt; a &lt;&lt; endl;//八进制输出cout &lt;&lt; oct &lt;&lt; a &lt;&lt; endl; //设置十进制输出cout &lt;&lt; setbase(10);cout &lt;&lt; a &lt;&lt; endl; //设置字符为大写cout &lt;&lt; setiosflags(ios::uppercase) ;cout &lt;&lt; hex &lt;&lt; a &lt;&lt; endl; setw(int n):设置输出数据的域宽为n，靠域宽右侧显示，域余填充空格，数据超出域宽按实际数据显示。效果所及：短效，头文件。 setfill(char c):对输出域余用字符c填充。效果所及：长效，头文件。 setprecision(int n):设置输出精度为n，float最多可取6位有效数，double最多可取15位有效数。效果所及：长效，头文件。","link":"/2015/07/15/01标准输入与标准输出/"}],"tags":[{"name":"标准输入与输出","slug":"标准输入与输出","link":"/tags/标准输入与输出/"},{"name":"函数重载","slug":"函数重载","link":"/tags/函数重载/"},{"name":"内联函数","slug":"内联函数","link":"/tags/内联函数/"},{"name":"new","slug":"new","link":"/tags/new/"},{"name":"delete","slug":"delete","link":"/tags/delete/"},{"name":"malloc","slug":"malloc","link":"/tags/malloc/"},{"name":"free","slug":"free","link":"/tags/free/"},{"name":"命名空间","slug":"命名空间","link":"/tags/命名空间/"},{"name":"类的分离式写法","slug":"类的分离式写法","link":"/tags/类的分离式写法/"},{"name":"构造函数","slug":"构造函数","link":"/tags/构造函数/"},{"name":"析构函数","slug":"析构函数","link":"/tags/析构函数/"},{"name":"浅拷贝","slug":"浅拷贝","link":"/tags/浅拷贝/"},{"name":"深拷贝","slug":"深拷贝","link":"/tags/深拷贝/"},{"name":"const","slug":"const","link":"/tags/const/"},{"name":"友元","slug":"友元","link":"/tags/友元/"},{"name":"继承","slug":"继承","link":"/tags/继承/"},{"name":"虚继承","slug":"虚继承","link":"/tags/虚继承/"},{"name":"指针数组","slug":"指针数组","link":"/tags/指针数组/"},{"name":"数组指针","slug":"数组指针","link":"/tags/数组指针/"},{"name":"指针函数","slug":"指针函数","link":"/tags/指针函数/"},{"name":"函数指针","slug":"函数指针","link":"/tags/函数指针/"},{"name":"XML","slug":"XML","link":"/tags/XML/"},{"name":"JSON","slug":"JSON","link":"/tags/JSON/"},{"name":"rabbitmq","slug":"rabbitmq","link":"/tags/rabbitmq/"},{"name":"Snappy","slug":"Snappy","link":"/tags/Snappy/"},{"name":"链表","slug":"链表","link":"/tags/链表/"},{"name":"树","slug":"树","link":"/tags/树/"},{"name":"docker","slug":"docker","link":"/tags/docker/"},{"name":"ELK","slug":"ELK","link":"/tags/ELK/"},{"name":"mysql","slug":"mysql","link":"/tags/mysql/"},{"name":"redis","slug":"redis","link":"/tags/redis/"},{"name":"配置文件","slug":"配置文件","link":"/tags/配置文件/"}],"categories":[{"name":"C++基础","slug":"C-基础","link":"/categories/C-基础/"},{"name":"C++提高","slug":"C-提高","link":"/categories/C-提高/"},{"name":"C++应用篇","slug":"C-应用篇","link":"/categories/C-应用篇/"},{"name":"数据结构与算法","slug":"数据结构与算法","link":"/categories/数据结构与算法/"},{"name":"Docker","slug":"Docker","link":"/categories/Docker/"},{"name":"Qt","slug":"Qt","link":"/categories/Qt/"},{"name":"Spring Boot","slug":"Spring-Boot","link":"/categories/Spring-Boot/"},{"name":"开源","slug":"开源","link":"/categories/开源/"},{"name":"开源组件","slug":"开源组件","link":"/categories/开源组件/"}]}