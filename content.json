{"pages":[],"posts":[{"title":"标准输入与标准输出","text":"概述C语言中使用函数scanf和printf作为标准输入和输出，在C++中引入了类cin和cout进行标准输入和输出，所需头文件为，命名空间是std。这里所说的标准输入和输出是相对程序而言，输入是通过IO设备，如键盘输入到程序，输出是指输出到IO设备，如程序输出到屏幕。 标准输入cin是标准输入流对象，是istream类的对象。cin是从缓冲区读取数据，如果缓冲区数据为空，cin对象的成员函数就会阻塞等待数据到来，直到检测到缓冲区有数据了才去读取。 开发过程中经常用到cin &gt;&gt;abc, cin.get()，cin.getline() cin&gt;&gt;abcabc为cin接受的类型，经常用到的是变量，先看张图： 12345678910111213141516#include &lt;iostream&gt; using namespace std; int main(){ int a; short b; char c; cin &gt;&gt; a &gt;&gt; b &gt;&gt; c; cout &lt;&lt; a &lt;&lt; endl; cout &lt;&lt; b &lt;&lt; endl; cout &lt;&lt; c &lt;&lt; endl;} 运行输入11[空格/回车]22[空格/回车]a[回车]，程序输出结果如下： cin.get()表示获取输入的一个字符，常用方式如下： 1234567char a;a = cin.get();cout &lt;&lt; a &lt;&lt; endl; char b;cin.get(b);cout &lt;&lt; b &lt;&lt; endl; cin.getline():表示读取多个字符，包括空白字符。直到读满N-1个，或遇到指定的结束符为止。可以指定结束符，默认结束符为’\\0’。 用法： cin.getline(字符指针(char*),字符个数N(int),结束符(char)); 123456789//使用默认结束符char a[32] = {0};cin.getline(a, 3);cout &lt;&lt; a &lt;&lt; endl; //指定结束符为&apos;p&apos;char b[32] = {0};cin.getline(b, 12, &apos;p&apos;);cout &lt;&lt; b &lt;&lt; endl; 标准输出cout是标准输入流对象，是ostream类的对象。 cout对象属性包括一个插入运算符(&lt;&lt;)，右侧的信息可以插入到流中。 12//简单使用cout &lt;&lt; &quot;this is cout!&quot; &lt;&lt; endl; //控制符endl，光标会另起一行 进制输出： dec:十进制输出整数，效果所及：长效，头文件： hex:十六进制输出整数，效果所及：长效，头文件： oct:八进制输出整数，效果所及：长效，头文件： 长效意思：设置后对以后所有的输入输出有效，直到重新设置为止。 短效：只对当前输入输出有效。 setbase(n) :表示以 n 进制显示，头文件&lt; iomanip &gt; 中，n 只能取 8, 10, 16 三个值 12345678910111213141516int a = 28; //十进制输出cout &lt;&lt; dec &lt;&lt; a &lt;&lt; endl;//十六进制输出cout &lt;&lt; hex &lt;&lt; a &lt;&lt; endl;//八进制输出cout &lt;&lt; oct &lt;&lt; a &lt;&lt; endl; //设置十进制输出cout &lt;&lt; setbase(10);cout &lt;&lt; a &lt;&lt; endl; //设置字符为大写cout &lt;&lt; setiosflags(ios::uppercase) ;cout &lt;&lt; hex &lt;&lt; a &lt;&lt; endl; setw(int n):设置输出数据的域宽为n，靠域宽右侧显示，域余填充空格，数据超出域宽按实际数据显示。效果所及：短效，头文件。 setfill(char c):对输出域余用字符c填充。效果所及：长效，头文件。 setprecision(int n):设置输出精度为n，float最多可取6位有效数，double最多可取15位有效数。效果所及：长效，头文件。","link":"/2015/07/15/01标准输入与标准输出/"},{"title":"函数重载","text":"函数重载指在相同作用域中多个函数名相同，函数的形参不同。 遵循规则： 1.函数名相同 2.函数的参数，类型，个数或顺序不一样都可以构成重载。 3.函数返回值得类型不同不构成重载，编译直接报错，存在二义性(ambiiguous) 12345678910111213141516171819202122232425262728293031#include &lt;iostream&gt; using namespace std; void foo(int a){ cout &lt;&lt; &quot;foo(int a)&quot; &lt;&lt; endl;} void foo(int a, int b){ cout &lt;&lt; &quot;foo(int a, int b)&quot; &lt;&lt; endl;} void foo(double a, int b){ cout &lt;&lt; &quot;foo(double a, int b)&quot; &lt;&lt; endl;} int main(){ int a = 1; int b = 2; int c = 6.8; foo(a); foo(a, b); foo(c, b); return 0;} 运行结果： 实现原理C++的重载使用了name mangling技术，有人翻译成命名粉碎，命名倾轧等。编译器会把原有的名字与其参数结合生成一个新的名字。 验证：把上文源码文件编译成目标namemangling.o，使用nm指令查看该文件：","link":"/2015/07/16/02函数重载/"},{"title":"内联函数","text":"函数的使用使得相同代码不必多次重写，但会带来额外的开销，函数调用的过程中会有入栈和出栈，这些都会消耗时间。 如果一个函数在程序运行过程中被成千上万次调用，那么这个开销也是不容忽视的，C++中引入了内联函数，直接在函数前面加上inline，在编译过程中直接把函数代码内嵌，避免了运行过程中的函数调用，但会增加程序代码段的空间。可以任务以空间来换取时间。 示例1234inline int foo(int a, int b) { return a+b; } ###总结内联函数优点：程序运行时避免了调用函数入栈，出栈导致的额外开销。 内联函数缺点：编译时直接函数代码内嵌，增加了代码段空间。 一般函数体行数不多(谷歌编程规范明确指出内联函数不超过10行代码)，且被频繁调用的函数适合用内联函数。","link":"/2015/07/17/03内联函数/"},{"title":"new和delete","text":"1.malloc,free和new,delete区别。 &emsp;a.malloc,free是C/C++的标准库函数。new,delete是c++的操作符。 &emsp;b.malloc申请的是内存，严格意义不是“对象”，new申请的可以理解为“对象”，new 时会调用构造函数，返回指向该对象的指针。 &emsp;c.对于class类型，必须用new/delete来创建和销毁，自动调用构造和析构函数，malloc/free无法胜任。 2.使用new遵循原则： &emsp;a.用new申请的内存，必须用delete释放。 &emsp;b.用new[]申请的内存，必须用delete[]释放。 &emsp;c.delete释放内存后，指针值不变，良好的风格是释放后指针置为NULL，如,delete p； p = NULL。 使用1.申请一个对象 123int* p1 = new int;delete p1;p1 = NULL; 2.申请多个对象 123int* p1 = new int[12];delete[] p1;p1 = NULL; 3.申请一个长度为1024的char数组 1234567char* pArray = new char[1024];for (int i=0; i &lt; 1024; i++){ pArray[i] = i;}delete[] pArray;pArray = NULL; 4.申请一个类对象 123456789101112131415#include &lt;stdio.h&gt; class Student{public: char name[32]; int age;};int main(){ Student* pStu = new Student(); delete pStu; pStu = NULL; return 1;} 5.申请1024个类对象 123456789101112131415161718192021222324252627#include &lt;stdio.h&gt; class Student{public: int age; Student() { ... } ~Student() { ... }}; int main(){ Student* pStu = new Student[1024]; for (int i=0; i&lt;1024; i++) { pStu[i].age = i+1; } delete[] pStu; pStu = NULL; return 1;} new多个对象不能传参数，要求该类必须有默认构造函数。","link":"/2015/07/17/04new和delete/"},{"title":"动态分配内存(malloc, free)","text":"操作系统中存在一个内存管理器(Memory Manager)，简称MM，它负责管理内存。 MM提供的服务：应用程序可以向MM申请一块指定大小的内存(借出)，用完之后应用程序应该释放(还回)。 所需头文件 &lt;stdlib.h&gt; 123如：void* p = malloc(1024);//申请，从MMM借出内存free(p); //释放，还回MM 1.MM管理的内存区域成为堆(Heap)。 2.只要应用malloc，MM都会借出，如应用不归还，MM也不会主动要求你free。如果有个应用不停地malloc，而不free，最终会用光MM的内存。 当MM没有更多闲置内存时，malloc返回NULL，表明内存已经用完。 malloc函数123456void* malloc(int size) 参数size：指定要申请内存空间大小 返回值：void*，指向这一块内存地址。(MM不关心你拿这块内存来存储何种数据，所以返回void*)(MM不关心你拿这块内存来存储何种数据，所以返回void*) (MM不关心你拿这块内存来存储何种数据，所以返回void*) free函数1234void free(void* ptr) 参数ptr: 先前malloc返回的内存地址 返回值: void* ，指向这一块内存地址 使用举例123456789101112131415161718192021222324252627#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;string.h&gt; class Object{public: int a; int b; char name[32];}; int main(){ //申请堆内存 Object *object = (Object *)malloc(sizeof(Object)); //存放数据 object-&gt;a = 1; object-&gt;b = 5; strcpy(object-&gt;name, &quot;wpf&quot;); //释放内存 free(object); object = NULL; //良好的编程风格 return 1;}","link":"/2015/07/17/05动态分配内存(malloc,free)/"},{"title":"命名空间(namespace)","text":"命名空间可以解决程序中的同名冲突，尤其大型项目多人开发中经常用到。比如我们使用C++的标准输出std::cout就使用了std命名空间。 使用作用域符:: 123456789101112131415161718192021#include &lt;iostream&gt; using namespace std; int var = 10; void foo(){ cout &lt;&lt; &quot;this is foo&quot; &lt;&lt; endl;} int main(){ int var = 20; cout &lt;&lt; var &lt;&lt; endl; //输出局部变量 cout &lt;&lt; ::var &lt;&lt; endl; //输出全局变量 foo(); //不加作用域符 ::foo(); //加作用域符 return 0;} 命名空间会对全局的变量和函数进行作用域打包。 在某些第三方库中是有namespace的，因此我们在使用这些库的时，要确定是否使用using namespace来解除名字前缀。 使用语法： 12345678910namespace XXX{ int var = 10; class A { public: ... };} //没有分号 使用假设有命名空间namespace Animal； 12345678namespace Animal { int age = 10; void action() { cout &lt;&lt; &quot;eatiing&quot; &lt;&lt; endl; }} 用法一：直接使用命名空间成员 12cout &lt;&lt; Animal::age &lt;&lt; endl;Animal::action(); 用法二： using使用命名空间成员 12using Animal::age;cout &lt;&lt; age &lt;&lt; endl; 用法三：使用命名空间全部成员 123using namespace Animal;cout &lt;&lt; age &lt;&lt; endl;foo(); 同时命名空间也支持嵌 1234567891011121314151617181920#include &lt;stdio.h&gt;namespace XXX{ class A { public: void test() { printf(&quot;this is namespace XXX class A\\n&quot;); } };}using namespace XXX; int main(){ A* p = new A(); p-&gt;test(); return 1;} 相同的命名空间编译时会合并 12345678910111213141516171819#include &lt;iostream&gt; using namespace std; namespace Space { int a = 10;} namespace Space { int b = 20;} using namespace Space;int main(){ cout &lt;&lt; &quot;a = &quot; &lt;&lt; a &lt;&lt; endl; cout &lt;&lt; &quot;b = &quot; &lt;&lt; b &lt;&lt; endl; return 0;}","link":"/2015/07/17/06命名空间(namespace)/"},{"title":"类的分离式写法","text":"类的分离式写法，使得代码更加规范，增强了阅读性。 分离式写法的规则： 1.类的变量：写在类的里面 2.成员函数：类中写函数的声明，函数的定义写在类体外。 3.写在类外函数定义时，类名前加限定(Object: :)，其中， ::理解为表示范围的符号。 代码演示头文件：Object.h 12345678910111213141516#ifndef _OBJECT_H_#define _OBJECT_H_ class Student{private: char name[32]; int age; public: void SetName(char* pName); void SetAge(int age); void Printf_Stu();}; #endif 源文件：Object.cpp 12345678910111213141516171819202122232425262728#include &lt;stdio.h&gt;#include &lt;string.h&gt;#include &quot;Object.h&quot; void Student::SetName(char* pName){ strcpy(this-&gt;name, pName);} void Student::SetAge(int age){ this-&gt;age = age;} void Student::Printf_Stu(){ printf(&quot;name = %s, age = %d\\n&quot;, this-&gt;name, this-&gt;age);} int main(){ Student stu; stu.SetName(&quot;aaaa&quot;); stu.SetAge(30); stu.Printf_Stu(); return 1;}","link":"/2015/07/17/07类的分离式写法/"},{"title":"构造函数与析构函数","text":"1.构造函数是种特殊的类成员函数，遵循如下规则： a.函数名与类名必须相同。 b.没有返回值 12345678910例如：class Obj{...public: Obj() { ... }}; 2.构造函数可以带参数，也可以重载 12345678910111213class Obj{...public: Obj() { ... } Obj(int x, int y) { ... }}; 3.构造函数和普通成员函数不一样，一般不显示调用。在创建一个对象时，构造函数自动调用(编译器来完成)。 析构函数(destructor)1.析构和构造是一对相反的过程，对象被创建时调用构造函数，对象被销毁时调用析构函数，遵循如下规则： a.名称固定，类名前加上波浪线~ b.没有返回值 c.不能带参数12345678例如，class Obj{public: ~Obj() { }}; 2.析构函数只能有一个，不允许重载。 3.析构函数不显示调用，对象销毁时编译器自动调用。 重新实现链表(使用类，构造和析构函数)创建DataObj.h头文件 1234567891011121314151617181920212223#ifndef _OBJECT_H_#define _OBJECT_H_ struct Student{ char name[32]; int age; Student* pNext;}; class DataObj{public: DataObj(); ~DataObj(); void add(Student* pStu); void find(int age); void printNode(Student* pNode);private: Student m_head;}; #endif 创建DataObj.cpp源文件 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788#include &lt;stdio.h&gt;#include &lt;string.h&gt;#include &lt;stdlib.h&gt;#include &quot;DataObj.h&quot; //构造有头链表DataObj::DataObj(){ m_head.pNext = NULL;}DataObj::~DataObj(){ //指向每个节点的头部 Student* p = m_head.pNext; //释放所有节点 while(p) { Student *next = p-&gt;pNext; free(p); p = next; } } void DataObj::add(Student* pNode){ //指向每个节点的头部 Student* p = &amp;m_head; //通过头节点查找到链表尾部节点 while (p) { if (p-&gt;pNext == NULL) { break; } p = p-&gt;pNext; } //添加节点到尾部 p-&gt;pNext = pNode;}void DataObj::find(int age){ //标记是否找到 bool bFind = false; Student* p = &amp;m_head; while(p) { if (p-&gt;age == age) { bFind = true; printNode(p); } p = p-&gt;pNext; } if (!bFind) { printf(&quot;没有找到该age的节点&quot;); }}void DataObj::printNode(Student* pNode){ printf(&quot;name = %s, age = %d\\n&quot;, pNode-&gt;name, pNode-&gt;age);} int main(){ //构造节点 Student* pStu = (Student*) malloc(sizeof(Student)); strcpy(pStu-&gt;name, &quot;aaaa&quot;); pStu-&gt;age = 30; pStu-&gt;pNext = NULL; { DataObj dataObj; //添加节点 dataObj.add(pStu); //查找节点 dataObj.find(31); } return 1;}","link":"/2015/07/17/08构造函数与析构函数/"},{"title":"拷贝构造函数，浅拷贝和深拷贝","text":"拷贝构造函数是一种特殊的构造函数，遵循如下的规则： 1.函数名和类名一致，没有返回值。 2.必须有一个参数，参数是本类型的一个引用变量。 3.拷贝构造函数可以访问参数对象的任意成员(private也可以)。 4.若自己不提供拷贝构造函数，系统会提供默认构造函数，若自己定义，系统将不再提供。 5.系统提供的拷贝构造是浅拷贝。书写示例如下： 123456789101112class Student{public: //构造函数 Student(int a, char* p); //拷贝构造函数 Student(const Student&amp; stu); char name[32]; int age;}; 拷贝构造函数调用1234567//调用方法1Object obj1;Object obj2(obj1); //或者写成:Object obj2 = obj1;//调用方法2Object obj1;Object* obj2 = new Object(obj1); 浅拷贝浅拷贝不开辟新空间，只增加一个指针，指向原有的内存。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748#include &lt;iostream&gt;using namespace std; class Student{public: //构造函数 Student(const char* myName) { int len = strlen(myName); name = new char[len + 1]{0}; strcpy_s(this-&gt;name, len+1, myName); cout &lt;&lt; &quot;构造：&quot; &lt;&lt; hex &lt;&lt; (int)name &lt;&lt; endl; } //析构函数 ~Student() { if (name) { cout &lt;&lt; &quot;析构：&quot; &lt;&lt; hex &lt;&lt; (int)name &lt;&lt; endl; delete[] name; name = NULL; } } //拷贝构造函数（浅拷贝） Student(const Student&amp; stu) { name = stu.name; cout &lt;&lt; &quot;调用拷贝构造函数&quot; &lt;&lt; endl; } private: char* name;}; int main(){ { Student stu1(&quot;hongshaorou&quot;); Student stu2(stu1); } } 运行过程中发生了崩溃 是因为对相同的内存地址做了两次析构导致，打印出内存地址一目了然。 深拷贝深拷贝会开辟新的内存空间，把原有的对象复制过来。见下图： 对上边浅拷贝代码进行修改 123456789101112131415161718192021222324252627282930313233343536class Student{public: //构造函数 Student(const char* myName) { int len = strlen(myName); name = new char[len + 1]{0}; strcpy_s(this-&gt;name, len+1, myName); cout &lt;&lt; &quot;构造：&quot; &lt;&lt; hex &lt;&lt; (int)name &lt;&lt; endl; } //析构函数 ~Student() { if (name) { cout &lt;&lt; &quot;析构：&quot; &lt;&lt; hex &lt;&lt; (int)name &lt;&lt; endl; delete[] name; name = NULL; } } //拷贝构造函数（深拷贝） Student(const Student&amp; stu) { int len = strlen(stu.name); name = new char[len + 1]; strcpy_s(name, len + 1, stu.name); cout &lt;&lt; &quot;调用拷贝构造函数&quot; &lt;&lt; hex &lt;&lt; (int)name&lt;&lt; endl; } private: char* name;}; 再次运行不会发生崩溃现象，打印内存地址可见，开辟了内存空间。","link":"/2015/07/17/09拷贝构造函数，浅拷贝和深拷贝/"},{"title":"const关键字","text":"C++中const关键字无处不在，我这里做下汇总，作为工具文章方便翻阅。 一：修饰数据成员修饰的成员一单定义初始化后不能再进行修改，如： const int a = 10; a =20; //重新赋值直接会报错 当修饰类的成员函数时，先来段错误的代码 12345678910class Student{public: Student(int i) { this-&gt;age = i; //age是const类型直接复制会报错 }private: const int age;}; 解决上面的错误有两种方法 方法一：使用参数列表的形式(推荐使用) 12345678910class Student{public: Student(int i):age(i) { }private: const int age;}; 方法二：定义age时直接赋值 12345678class Student{public: Student ();private: const int age = 20;}; 二：修饰成员函数在声明之后，实现体之前 格式为： 类型 函数名(参数….) const const修饰的成员函数不能修改类中的成员函数，函数中只能调用const修饰的函数。 123456789101112131415161718192021class Student{public: Student (int i ):age(i) { } void update () const { age = age +1; //const 修饰的成员函数不能修改类中的成员变量 display(); //const 修饰的成员函数，函数中只能调用const修饰的成员函数 } void display() { cout &lt;&lt; &quot;age:&quot; &lt;&lt; endl; }private: int age;}; 三：修饰类对象const修饰的对象，只能调用const修饰的成员函数 12345678910111213141516171819202122232425262728class Student{public: Student (int i ):age(i) { } void update () const { cout &lt;&lt; &quot;this is update&quot; &lt;&lt; endl; } void display() { cout &lt;&lt; &quot;age:&quot; &lt;&lt; endl; }private: int age;};int main(){ const Student stu(30); stu.update(); stu.display(); //const修饰的类对象 只能调用const修饰的成员函数 return 1;} 成员函数有无const修饰可以构成重载，非const对象调用时优先调用非const修饰的成员函数，如不构成重载也可以调用const修饰成员函数。 12345678910111213141516171819202122232425262728class Student{public: Student (int i ):age(i) { } void display() { cout &lt;&lt; &quot;void display()&quot; &lt;&lt; endl; } void display() const { cout &lt;&lt; &quot;display() const&quot; &lt;&lt; endl; }private: int age;};int main(){ Student stu(30); stu.display(); return 1;} 输出结果：","link":"/2015/07/17/10const关键字/"},{"title":"友元","text":"C++封装的类增加了对类中数据成员的访问限制，从而保证了安全性。如想访问类中的私有成员需要通过类中提供的公共接口来访问，这样间接的访问方式，无疑使得程序的运行效率有所降低。 友元的提出可以使得类外的函数来访问类中的私有成员，保护成员。 友元的使用分为三类： 1.类外的普通函数声明为该类的友元函数。 格式： friend 类型 函数名(形参)2.其他类的成员函数声明为该类的友元函数。 格式：friend 类型 类名::函数名(形参)3.其他类为该类的友元类，这样类中的所有成员函数都是该类的友元函数。 格式：friend class 类名代码演示： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071#include &lt;iostream&gt;using namespace std;class A;class B{public: //类B的成员函数为类A的友元函数 void display(A &amp;a);};class C{public: //类C是类A的友元类 void display(A &amp;a);};class A{public: A(int i):x(i){} int getX() { return x; } friend void display(A &amp;a); friend void B::display(A &amp;a); friend C;private: int x;};//类外普通函数为类A的友元函数void display(A &amp;a){ cout &lt;&lt; a.x &lt;&lt; endl; //友元函数直接访问类中的私有成员}void B::display(A &amp;a){ cout &lt;&lt; a.x &lt;&lt; endl;}void C::display(A &amp;a){ cout &lt;&lt; a.x &lt;&lt; endl;}int main(){ A a(18); //无法直接访问类A的私有变量x，需要通过对外提供的函数来访问 cout &lt;&lt; a.getX() &lt;&lt; endl; //类B的成员函数为类的A的友元函数 B b; b.display(a); //类C是类A的友元类 C c; c.display(a); return 0;} ###总结： 1.友元声明在类中，但并不属于该类的成员。 2.友元的关系不能继承。 3.在类的任何位置声明友元都行，不受访问权限限制。 4.友元关系提高了程序效率，但破坏了数据的安全性。慎重使用。 5.友元的关系是单向。如类B是类A的友元，反过来类A不一定是类B的友元，看类B中是否有声明。","link":"/2015/07/17/11友元/"},{"title":"类的继承","text":"面向对象的设计思想，类对数据做了封装，并可以加入访问权限，类的继承是面向对象思想的精髓。类的继承可以让新类从以有的类中获得已有的特征。原有类称为基类或父类，新类称为派生类或子类。 语法： 1234class 子类类名：[继承方式] 父类类名{ } ; 继承的方式有三种： 1.共有继承：(使用最广泛) 在派生类中原来的公有成员，保护成员身份不变。原私有成员仍不可访问。 2.私有继承： 在派生类中原来的公有成员，保护成员都称为了保护成员。原私有成员仍不可访问。 3.保护继承：在派生类中原来的公有成员，保护成员都称为了私有成员。原私有成员仍不可访问。 派生类的构造函数和析构函数派生类继承基类过程中，基类的构造函数和析构是不能继承下来的。所以，派生类必须设置自己的构造函数和析构函数。 派生类构造函数语法： 1234派生类名::派生类名(参数):基类名(参数),派生类新成员(){ } 构造调用顺序： 基类构造---&gt;派生类构造析构函数调用顺序 派生类析构---&gt;基类析构代码演示： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667#include &lt;iostream&gt;#include &lt;string&gt; using namespace std; class Man{public: Man(string sn, int i):name(sn),age(i) { cout &lt;&lt; &quot;Man construct&quot; &lt;&lt; endl; } ~Man() { cout &lt;&lt; &quot;Man destruct&quot; &lt;&lt; endl; } void dis() { cout &lt;&lt; &quot;ame:&quot; &lt;&lt; name &lt;&lt; endl; cout &lt;&lt; &quot;age:&quot; &lt;&lt; age &lt;&lt; endl; }private: string name; int age;}; class Birthday{public: Birthday(int y, int m):year(y), month(m) { cout &lt;&lt; &quot;Birthday construct &quot; &lt;&lt; endl; } ~Birthday() { cout &lt;&lt; &quot;Birthday destruct &quot; &lt;&lt; endl; }private: int year; int month;}; class Student:public Man{public: Student(string name, int age, float fs):Man(name, age),bday(10, 10),_score(fs) { cout &lt;&lt; &quot;Student construct&quot; &lt;&lt; endl; } ~Student() { cout &lt;&lt; &quot;Student destruct&quot; &lt;&lt; endl; }private: float _score; Birthday bday;}; int main(){ Student stu(&quot;wpf&quot;, 18, 100); stu.dis();} 运行结果： 同名隐藏子类中定义了与父类同名的方法（不管参数），子类的该方法将会隐藏掉所有的父类的同名方法； 12345678910111213141516171819202122232425262728293031 class Father{public: void show() { cout &lt;&lt; &quot;Father show()&quot; &lt;&lt; endl; } void show(int a) { cout &lt;&lt; &quot;Father show(int a)&quot; &lt;&lt; endl; }}; class Son : public Father{public: void show() { cout &lt;&lt; &quot;Son show()&quot; &lt;&lt; endl; }}; int main(){ Son son; son.show(); //调用子类中的方法 son.show(1); //父类中的同名方法，void show(int a)被隐藏，无法调用 getchar();} 多继承多继承是的新建的获得多个类(&gt;=2)中获得已有的特征， 并非所有面向对象的语言都有这种语法，如Java，C#取消了多继承，多继承可能引起多种问题，如二义性等。 多继承语法： 1234派生类名:public 基类名1，public 基类名2{ }; 代码演示： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263#include &lt;iostream&gt;#include &lt;string&gt; using namespace std; //基类Xclass X{public: X(int a):i(a) { cout &lt;&lt; &quot;construct X&quot; &lt;&lt; endl; } void displayX() { cout &lt;&lt; &quot;X:&quot; &lt;&lt; i &lt;&lt; endl; }private: int i;}; //基类Yclass Y{public: Y(int a):i(a) { cout &lt;&lt; &quot;construct Y&quot; &lt;&lt; endl; } void displayY() { cout &lt;&lt; &quot;Y:&quot; &lt;&lt; i &lt;&lt; endl; }private: int i;}; //派生类Zclass Z: public X, public Y{public: Z(int a, int b, int c):X(a), Y(b), i(c) { cout &lt;&lt; &quot;construct Z&quot; &lt;&lt; endl; } void displayZ() { cout &lt;&lt; &quot;Z:&quot; &lt;&lt; i &lt;&lt; endl; } private: int i;}; int main(){ Z z(1,2,3); z.displayX(); z.displayY(); z.displayZ();} 运行结果：","link":"/2015/07/18/12类的继承/"},{"title":"虚继承","text":"由于多重继承产生的二义性引入了类的虚继承，先看下什么是二义性。 类D是类B和类C的派生类，而类B，类C就是继承于类A，当D调用类A中的函数时不知道是类B继承A的，还是类C继承A的，引起了二义性。虚继承可以解决这个问题。 使用语法： 123class 派生类:virtual 继承方式 虚基类{}; 上图中类D 实例化过程中的初始化顺序： 祖父类(A)—&gt;父类(从左到又)—&gt;子类，并且最后一次初始化有效 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677#include &lt;iostream&gt;#include &lt;string&gt; using namespace std; class A{public: A(int a):i(a) { cout &lt;&lt; &quot;construct A&quot; &lt;&lt; endl; } void displaya() { cout &lt;&lt; &quot;A:&quot; &lt;&lt; i &lt;&lt; endl; }private: int i;}; class B:virtual public A //虚继承{public: B(int a): A(a),i(a) { cout &lt;&lt; &quot;construct B&quot; &lt;&lt; endl; } void displayb() { cout &lt;&lt; &quot;B:&quot; &lt;&lt; i &lt;&lt; endl; }private: int i;}; class C:virtual public A //虚继承{public: C(int a):A(2),i(a) { cout &lt;&lt; &quot;construct C&quot; &lt;&lt; endl; } void displayc() { cout &lt;&lt; &quot;C:&quot; &lt;&lt; i &lt;&lt; endl; }private: int i;}; class D: public B, public C //多重继承{public: D(int a, int b, int c, int d):A(a), B(b), C(d), i(c) //必须初始化虚基类X,X(d) { cout &lt;&lt; &quot;construct Z&quot; &lt;&lt; endl; } void displayd() { cout &lt;&lt; &quot;D:&quot; &lt;&lt; i &lt;&lt; endl; } private: int i;}; int main(){ D d(1,2,3, 4); d.displaya(); d.displayb(); d.displayc(); d.displayd();} 运行结果： 编译器在实例化D时，之调用了一次虚基类的构造函数，忽略了虚基类A派生类B，C对续虚基类构造函数的调用，保证了虚基类的数据成员不会被初始化多次。","link":"/2015/07/18/13虚继承/"},{"title":"赋值兼容","text":"赋值兼容的规则时在需要使用基类对象的任何地方都可以使用公有派生类对象来替代。公有继承派生类可获得基类中除构造函数，析构函数外的所有成员，能用基类解决的问题，派生类也能解决。更直白点说，如果一个类是从一个基类公有继承过来，那么这个派生类就可以替代基类，反过来基类不能替代派生类。 常用赋值兼容情况： 1.派生类对象赋值给基类对象。 2.派生类对象初始化基类对象引用。 3.派生类对象地址赋值给指向基类对象指针。12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152#include &lt;iostream&gt; using namespace std; class Father{public: void show() { cout &lt;&lt; &quot;Father show()&quot; &lt;&lt; endl; } void showFather() { cout &lt;&lt; &quot;showFather()&quot; &lt;&lt; endl; }}; class Son : public Father{public: void show() { cout &lt;&lt; &quot;Son show()&quot; &lt;&lt; endl; } void showSon() { cout &lt;&lt; &quot;showSon()&quot; &lt;&lt; endl; }}; int main(){ Father father1; Son son1; father1 = son1; //子类对象赋值给父类对象 father1.show(); //调用父类中的show()方法 father1.showFather(); //调用父类中的showFather()方法 Son son2; Father&amp; father2 = son2; //子类对象初始化父类对象引用 father2.show(); //调用父类中的show()方法 father2.showFather(); //调用父类中的showFather()方法 Son son3; Father* father3 = &amp;son3;//子类对象地址赋值给指向父对象指针 father3-&gt;show(); //调用父类中的show()方法 father3-&gt;showFather(); //调用父类中的showFather()方法 getchar();}","link":"/2015/07/18/14赋值兼容/"},{"title":"C++生成和解析XML文件","text":"1.xml 指可扩展标记语言(EXtensible Markup Language)2.xml 是一种标记语言，类似html3.xml 的设计宗旨是传输数据，而非显示数据4.xml 标签没有被预定义。需要自行定义标签 XML与HTML区别1.xml 不是 html 的替代。2.xml 和 html 为不同的目的而设计：3.xml 被设计为传输和存储数据，其焦点是数据的内容。4.html 被设计用来显示数据，其焦点是数据的外观。5.html 旨在显示信息，而 xml 旨在传输信息。 第三方库XML第三方解析库,选用TinyXML,TinyXML也是一个开源的解析XML解析库，使用简单正如其名，用于C++开发，支持Windows和Linux。TinyXML通过DOM模型遍历和分析XML。官网地址：http://www.grinninglizard.com/tinyxml/ 生成XML文件123456789101112131415161718192021222324252627282930TiXmlDocument xmlDocument;// 添加XML声明xmlDocument.LinkEndChild(new TiXmlDeclaration( &quot;1.0&quot;, &quot;GBK&quot;, &quot;&quot; ));// 添加根元素TiXmlElement * xmlRoot = new TiXmlElement(&quot;root&quot;);xmlDocument.LinkEndChild(xmlRoot);//根元素下添加子元素1TiXmlElement* xmlChild1 = new TiXmlElement(&quot;name&quot;);xmlRoot-&gt;LinkEndChild(xmlChild1);xmlChild1-&gt;LinkEndChild(new TiXmlText(&quot;woniu&quot;));xmlChild1-&gt;SetAttribute(&quot;id&quot;, &quot;0001&quot;);//设置属性//根元素下添加子元素2TiXmlElement* xmlChild2 = new TiXmlElement(&quot;Student&quot;);xmlRoot-&gt;LinkEndChild(xmlChild2);TiXmlElement* xmlChild2_01 = new TiXmlElement(&quot;name&quot;);xmlChild2-&gt;LinkEndChild(xmlChild2_01);xmlChild2_01-&gt;LinkEndChild(new TiXmlText(&quot;woniu201&quot;)); TiXmlElement* xmlChild2_02 = new TiXmlElement(&quot;classes&quot;);xmlChild2-&gt;LinkEndChild(xmlChild2_02);xmlChild2_02-&gt;LinkEndChild(new TiXmlText(&quot;86&quot;));//保存xml文件xmlDocument.SaveFile(&quot;woniu.xml&quot;); 生成XML如下： 解析XML文件123456789101112131415161718192021222324TiXmlDocument xmlDocument;if (!xmlDocument.LoadFile(&quot;woniu.xml&quot;)){ return -1;}//根节点TiXmlElement* xmlRoot = xmlDocument.RootElement();if (xmlRoot == NULL){ return -1;}//获取子节点信息1TiXmlElement* xmlNode1Name = xmlRoot-&gt;FirstChildElement(&quot;name&quot;);const char* node1Name = xmlNode1Name-&gt;GetText();const char* node1AttId = xmlNode1Name-&gt;Attribute(&quot;id&quot;);//获取子节点信息2TiXmlElement* xmlNode2Stu = xmlRoot-&gt;FirstChildElement(&quot;Student&quot;);TiXmlElement* xmlNode2_name = xmlNode2Stu-&gt;FirstChildElement(&quot;name&quot;);TiXmlElement* xmlname2_classes = xmlNode2Stu-&gt;FirstChildElement(&quot;classes&quot;);const char* node2Name = xmlNode2_name-&gt;GetText();const char* node2Classes = xmlname2_classes-&gt;GetText(); 关注下面公众号，回复”101”获取源码","link":"/2017/07/31/Applied01C++生成和解析XML文件/"},{"title":"C++构造和解析JSON","text":"JSON是一种轻量级的数据交互格式，易于人阅读和编写，同时也易于机器解析和生成，并有效地提升网络传输效率，实际项目中经常用到，相比xml有很多优点，问问度娘，优点一箩筐。 第三方库json解析选用jsoncpp作为第三方库，jsoncpp使用广泛，c++开发首选。 jsoncpp目前已经托管到了github上，地址：https://github.com/open-source-parsers/jsoncpp 使用使用c++进行构造json和解析json，选用vs2010作为IDE。工程中使用jsoncpp的源码进行编译，没有使用jsoncpp的库，为方便大家使用把dll和lib库也放到了我的工程jsoncpplib文件夹下，有需要的可以直接引用库。 待解析的json数据格式如下图： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156/********************************************************Copyright (C), 2016-2017,FileName: mainAuthor: woniu201Email: wangpengfei.201@163.comCreated: 2017/09/06Description:use jsoncpp src , not use dll, but i also provide dll and lib.********************************************************/ #include &quot;stdio.h&quot;#include &lt;string&gt;#include &quot;jsoncpp/json.h&quot; using namespace std; /************************************@ Brief: read file@ Author: woniu201 @ Created: 2017/09/06@ Return: file data ************************************/char *getfileAll(char *fname){ FILE *fp; char *str; char txt[1000]; int filesize; if ((fp=fopen(fname,&quot;r&quot;))==NULL){ printf(&quot;open file %s fail \\n&quot;,fname); return NULL; } fseek(fp,0,SEEK_END); filesize = ftell(fp); str=(char *)malloc(filesize); str[0]=0; rewind(fp); while((fgets(txt,1000,fp))!=NULL){ strcat(str,txt); } fclose(fp); return str;} /************************************@ Brief: write file@ Author: woniu201 @ Created: 2017/09/06@ Return: ************************************/int writefileAll(char* fname,const char* data){ FILE *fp; if ((fp=fopen(fname, &quot;w&quot;)) == NULL) { printf(&quot;open file %s fail \\n&quot;, fname); return 1; } fprintf(fp, &quot;%s&quot;, data); fclose(fp); return 0;} /************************************@ Brief: parse json data@ Author: woniu201 @ Created: 2017/09/06@ Return: ************************************/int parseJSON(const char* jsonstr){ Json::Reader reader; Json::Value resp; if (!reader.parse(jsonstr, resp, false)) { printf(&quot;bad json format!\\n&quot;); return 1; } int result = resp[&quot;Result&quot;].asInt(); string resultMessage = resp[&quot;ResultMessage&quot;].asString(); printf(&quot;Result=%d; ResultMessage=%s\\n&quot;, result, resultMessage.c_str()); Json::Value &amp; resultValue = resp[&quot;ResultValue&quot;]; for (int i=0; i&lt;resultValue.size(); i++) { Json::Value subJson = resultValue[i]; string cpuRatio = subJson[&quot;cpuRatio&quot;].asString(); string serverIp = subJson[&quot;serverIp&quot;].asString(); string conNum = subJson[&quot;conNum&quot;].asString(); string websocketPort = subJson[&quot;websocketPort&quot;].asString(); string mqttPort = subJson[&quot;mqttPort&quot;].asString(); string ts = subJson[&quot;TS&quot;].asString(); printf(&quot;cpuRatio=%s; serverIp=%s; conNum=%s; websocketPort=%s; mqttPort=%s; ts=%s\\n&quot;,cpuRatio.c_str(), serverIp.c_str(), conNum.c_str(), websocketPort.c_str(), mqttPort.c_str(), ts.c_str()); } return 0;} /************************************@ Brief: create json data@ Author: woniu201 @ Created: 2017/09/06@ Return: ************************************/int createJSON(){ Json::Value req; req[&quot;Result&quot;] = 1; req[&quot;ResultMessage&quot;] = &quot;200&quot;; Json::Value object1; object1[&quot;cpuRatio&quot;] = &quot;4.04&quot;; object1[&quot;serverIp&quot;] = &quot;42.159.116.104&quot;; object1[&quot;conNum&quot;] = &quot;1&quot;; object1[&quot;websocketPort&quot;] = &quot;0&quot;; object1[&quot;mqttPort&quot;] = &quot;8883&quot;; object1[&quot;TS&quot;] = &quot;1504665880572&quot;; Json::Value object2; object2[&quot;cpuRatio&quot;] = &quot;2.04&quot;; object2[&quot;serverIp&quot;] = &quot;42.159.122.251&quot;; object2[&quot;conNum&quot;] = &quot;2&quot;; object2[&quot;websocketPort&quot;] = &quot;0&quot;; object2[&quot;mqttPort&quot;] = &quot;8883&quot;; object2[&quot;TS&quot;] = &quot;1504665896981&quot;; Json::Value jarray; jarray.append(object1); jarray.append(object2); req[&quot;ResultValue&quot;] = jarray; Json::FastWriter writer; string jsonstr = writer.write(req); printf(&quot;%s\\n&quot;, jsonstr.c_str()); writefileAll(&quot;createJson.json&quot;, jsonstr.c_str()); return 0;} int main(){ char* json = getfileAll(&quot;parseJson.json&quot;); parseJSON(json); printf(&quot;===============================\\n&quot;); createJSON(); getchar(); return 1;} 关注下面公众号，回复”104”获取源码","link":"/2017/09/06/Applied02C++构造和解析Json/"},{"title":"纯C++实现操作配置文件(告别跨平台问题)","text":"项目中经常用到操作配置文件，考虑到跨平台问题，使用纯C++来实现操作配置文件。 CConfig.h 123456789101112131415161718192021222324252627282930313233343536#ifndef _CCONFIG_H#define _CCONFIG_H#include &lt;iostream&gt;#include &lt;string&gt;#include &lt;fstream&gt;#include &lt;vector&gt; using namespace std; class CConfig{public: CConfig(); ~CConfig(); void SetFilePath(const string &amp;filePath); string GetFilePath(); bool GetValue(const string &amp;section, const string &amp;key, string &amp;value, string &amp;error); bool ModifyValue(const string &amp;section, const string &amp;key, const string &amp;value, string &amp;error); private: bool OpenFile(); bool FindSection(const string &amp;sectionName); bool FindKey(const string &amp;key); bool OpenFileRead(); bool OpenFileWrite(); bool SetValue(const string &amp;key, const string &amp;value); void WriteFile(vector&lt;string&gt; &amp;vContent); string m_filePath; fstream m_fout; fstream m_fin; string m_content; string m_value; string m_error;};#endif CConfig.cpp 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316/********************************************************Copyright (C), 2016-2018,FileName: CConfigAuthor: woniu201Created: 2018/11/16Description: 纯C++实现配置文件的操作********************************************************/#include &quot;CConfig.h&quot; CConfig::CConfig(){ } CConfig::~CConfig(){ } /************************************@ Brief: 设置配置文件路径@ Author: woniu201@ Created: 2018/12/21@ Return:************************************/void CConfig::SetFilePath(const string &amp;filePath){ m_filePath = filePath;} /************************************@ Brief: 读取配置文件路径@ Author: woniu201@ Created: 2018/12/21@ Return:************************************/string CConfig::GetFilePath(){ return this-&gt;m_filePath;} /************************************@ Brief: 打开配置文件@ Author: woniu201@ Created: 2018/12/21@ Return:************************************/bool CConfig::OpenFile(){ if (true == m_fin.is_open()) { m_fin.close(); } m_fin.open(m_filePath.c_str()); if (!m_fin.is_open()) { m_error = &quot;open file fail:&quot; + m_filePath; return false; } return true;} /************************************@ Brief: 找节名@ Author: woniu201@ Created: 2018/12/21@ Return:************************************/bool CConfig::FindSection(const string &amp;sectionName){ if (-1 != m_content.find(&apos;[&apos;)) { string sTemp = m_content.substr(m_content.find(&apos;[&apos;) + 1, m_content.find(&apos;]&apos;) - m_content.find(&apos;[&apos;) - 1); if (0 == strcmp(sTemp.c_str(), sectionName.c_str())) { return true; } else { return false; } } else { return false; }} /************************************@ Brief: 找键名@ Author: woniu201@ Created: 2018/12/21@ Return:************************************/bool CConfig::FindKey(const string &amp;key){ size_t iDelePlace = m_content.find((char)&apos;//&apos;, 0); size_t iFindEqual = m_content.find((char)&apos;=&apos;, 0); //被注释的行，或者是包含key但是已经被注视掉了，过滤 if ((-1 != iDelePlace &amp;&amp; iDelePlace &lt; iFindEqual) || (-1 != iDelePlace &amp;&amp; -1 == iFindEqual) || -1 == iFindEqual) { return false; } string sKey = m_content.substr(0, m_content.find(&apos;=&apos;)); if (0 == strcmp(sKey.c_str(), key.c_str())) { m_value = m_content.substr(m_content.find(&apos;=&apos;) + 1, m_content.length() - m_content.find(&apos;=&apos;) - 1); return true; } return false;} /************************************@ Brief: 读取节下Key对应的value值@ Author: woniu201@ Created: 2018/12/21@ Return:************************************/bool CConfig::GetValue(const string &amp;section, const string &amp;key, string &amp;value, string &amp;error){ m_error = &quot;&quot;; if (false == OpenFile()) { error = m_error; return false; } char str[4096] = { 0 }; bool bFindSection = false; while (m_fin.getline(str, sizeof(str))) { m_content = str; if (!bFindSection) { if (FindSection(section)) { bFindSection = true; } else { m_error = &quot;&quot;; m_error = &quot;节点&quot; + section + &quot;不存在&quot;; } } else { if (FindKey(key)) { m_fin.close(); m_error = &quot;&quot;; value = m_value; return true; } else { m_error = &quot;&quot;; m_error = &quot;键名&quot; + key + &quot;不存在&quot;; } } memset(str, 0, 4096); } error = m_error; m_fin.close(); return false;} /************************************@ Brief: 读的方式打开文件@ Author: woniu201@ Created: 2018/12/21@ Return:************************************/bool CConfig::OpenFileRead(){ m_fout.close(); //关闭后要在清空一下，否则下次打开会出错 m_fout.clear(); m_fout.open(m_filePath.c_str(), ios::in); if (!m_fout.is_open()) { m_error = &quot;open file fail:&quot; + m_filePath; return false; } return true;} /************************************@ Brief: 写的方式打开文件@ Author: woniu201@ Created: 2018/12/21@ Return:************************************/bool CConfig::OpenFileWrite(){ m_fout.close(); //关闭后要在清空一下，否则下次打开会出错 m_fout.clear(); m_fout.open(m_filePath.c_str(), ios::out | ios::trunc); if (!m_fout.is_open()) { m_error = &quot;can not open file &quot; + m_filePath; return false; } return true;} /************************************@ Brief: 找KEY，设置新值@ Author: woniu201@ Created: 2018/12/21@ Return:************************************/bool CConfig::SetValue(const string &amp;key, const string &amp;value){ size_t iDelePlace = m_content.find((char)&apos;//&apos;); size_t iFindEqual = m_content.find((char)&apos;=&apos;); //被注释的行，或者是包含key但是已经被注视掉了，过滤 if ((-1 != iDelePlace &amp;&amp; iDelePlace &lt; iFindEqual) || (-1 != iDelePlace &amp;&amp; -1 == iFindEqual) || -1 == iFindEqual) { return false; } string sKey = m_content.substr(0, m_content.find(&apos;=&apos;)); if (0 == strcmp(sKey.c_str(), key.c_str())) { m_content = m_content.substr(0, m_content.find(&apos;=&apos;) + 1) + value; return true; } return false;} /************************************@ Brief: 修改配置文件KEY对应的value@ Author: woniu201@ Created: 2018/12/21@ Return:************************************/bool CConfig::ModifyValue(const string &amp;section, const string &amp;key, const string &amp;value, string &amp;error){ m_error = &quot;&quot;; if (false == OpenFileRead()) { error = m_error; return false; } char str[4096] = { 0 }; vector&lt;string&gt; vContent; bool isModify = false; bool isFindSection = false; while ( (m_fout.getline(str, sizeof(str)))) { m_content = str; if (!isFindSection) { if (FindSection(section)) { isFindSection = true; } else { m_error = &quot;&quot;; m_error = &quot;节点&quot; + section + &quot;不存在&quot;; } } else { if (!isModify) { if (SetValue(key, value)) { isModify = true; } else { m_error = &quot;&quot;; m_error = &quot;键名&quot; + key + &quot;不存在&quot;; } } } vContent.push_back(m_content); m_content = &quot;&quot;; memset(str, 0, 4096); } error = m_error; WriteFile(vContent); m_fout.flush(); m_fout.close(); return isModify;} /************************************@ Brief: 写文件@ Author: woniu201@ Created: 2018/12/21@ Return:************************************/void CConfig::WriteFile(vector&lt;string&gt; &amp;vContent){ if (false == OpenFileWrite()) { m_fout.close(); return; } for (size_t iIndex = 0; iIndex &lt; vContent.size(); iIndex++) { m_fout &lt;&lt; vContent[iIndex] &lt;&lt; endl; } m_fout.close(); vector&lt;string&gt;().swap(vContent);} main.cpp 12345678910111213141516171819#include &quot;CConfig.h&quot; int main(){ CConfig config; config.SetFilePath(&quot;a.ini&quot;); string value = &quot;&quot;; string error = &quot;&quot;; config.GetValue(&quot;ServerUrl&quot;, &quot;PcName&quot;, value, error); cout &lt;&lt; value &lt;&lt; endl; cout &lt;&lt; error &lt;&lt; endl; error = &quot;&quot;; config.ModifyValue(&quot;ServerUrl&quot;, &quot;PcName&quot;, &quot;5.0&quot;, error); cout &lt;&lt; error &lt;&lt; endl; getchar();} 配置文件a.ini内容如下：","link":"/2018/11/16/Applied03纯C++实现操作配置文件(告别跨平台问题)/"}],"tags":[{"name":"标准输入与输出","slug":"标准输入与输出","link":"/tags/标准输入与输出/"},{"name":"函数重载","slug":"函数重载","link":"/tags/函数重载/"},{"name":"内联函数","slug":"内联函数","link":"/tags/内联函数/"},{"name":"new","slug":"new","link":"/tags/new/"},{"name":"delete","slug":"delete","link":"/tags/delete/"},{"name":"malloc","slug":"malloc","link":"/tags/malloc/"},{"name":"free","slug":"free","link":"/tags/free/"},{"name":"命名空间","slug":"命名空间","link":"/tags/命名空间/"},{"name":"类的分离式写法","slug":"类的分离式写法","link":"/tags/类的分离式写法/"},{"name":"构造函数","slug":"构造函数","link":"/tags/构造函数/"},{"name":"析构函数","slug":"析构函数","link":"/tags/析构函数/"},{"name":"浅拷贝","slug":"浅拷贝","link":"/tags/浅拷贝/"},{"name":"深拷贝","slug":"深拷贝","link":"/tags/深拷贝/"},{"name":"const","slug":"const","link":"/tags/const/"},{"name":"友元","slug":"友元","link":"/tags/友元/"},{"name":"继承","slug":"继承","link":"/tags/继承/"},{"name":"虚继承","slug":"虚继承","link":"/tags/虚继承/"},{"name":"XML","slug":"XML","link":"/tags/XML/"},{"name":"JSON","slug":"JSON","link":"/tags/JSON/"},{"name":"配置文件","slug":"配置文件","link":"/tags/配置文件/"}],"categories":[{"name":"C++基础","slug":"C-基础","link":"/categories/C-基础/"},{"name":"C++应用篇","slug":"C-应用篇","link":"/categories/C-应用篇/"}]}